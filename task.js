// @name         思源笔记任务管理器
// @version      1.5.1
// @description  任务管理器，支持自定义筛选规则分组和排序
// @author       5KYFKR

(function() {
    'use strict';
    
    const __tmNsKey = 'siyuan-plugin-task-horizon';
    const __tmNs = (() => {
        try {
            const w = window;
            const existing = w[__tmNsKey];
            if (!existing || typeof existing !== 'object') w[__tmNsKey] = {};
            return w[__tmNsKey];
        } catch (e) {
            return {};
        }
    })();
    const __tmWindowKeysBefore = (() => {
        try {
            return new Set(Object.getOwnPropertyNames(window));
        } catch (e) {
            return new Set();
        }
    })();

    const __tmStyleEl = document.createElement('style');
    __tmStyleEl.dataset.tmTaskHorizonStyle = '1';
    __tmStyleEl.textContent = `
        :root {
            --tm-bg-color: #ffffff;
            --tm-text-color: #333333;
            --tm-border-color: #e9ecef;
            --tm-table-border-color: #e9ecef;
            --tm-hover-bg: #f8f9fa;
            --tm-gantt-weekend-bg: rgba(0,0,0,0.12);
            --tm-secondary-text: #666666;
            --tm-modal-overlay: rgba(0,0,0,0.5);
            --tm-shadow: 0 10px 40px rgba(0,0,0,0.2);
            --tm-header-bg: #f8f9fa;
            --tm-input-bg: #ffffff;
            --tm-input-border: #ddd;
            --tm-table-header-bg: #f8f9fa;
            --tm-table-border: #e9ecef;
            --tm-task-done-color: #999999;
            --tm-doc-item-bg: #f8f9fa;
            --tm-doc-item-hover: #e8f0fe;
            --tm-doc-count-bg: #e8f0fe;
            --tm-doc-count-color: #4285f4;
            --tm-rule-group-bg: #f8f9fa;
            --tm-rule-item-bg: #f8f9fa;
            --tm-subgroup-bg: #f1f3f5;
            --tm-primary-color: #4285f4;
            --tm-success-color: #34a853;
            --tm-danger-color: #ea4335;
            --tm-info-bg: #f0f9ff;
            --tm-info-border: #4285f4;
            --tm-section-bg: #f8f9fa;
            --tm-card-bg: #ffffff;
            --tm-font-size: 14px;
            --tm-header-height: 44px;
            --tm-table-header-height: 36px;
            --tm-row-height-scale: 1.25;
            --tm-row-height-offset: 12px;
            --tm-row-height-min: 24px;
            --tm-row-height-max: 42px;
            --tm-row-height: clamp(var(--tm-row-height-min), calc(var(--tm-font-size) * var(--tm-row-height-scale) + var(--tm-row-height-offset)), var(--tm-row-height-max));
            --tm-gantt-bar-height: clamp(12px, calc(var(--tm-row-height) * 0.6), 22px);
            --tm-empty-cell-bg: #f1f3f4;
            --tm-topbar-grad-start: #667eea;
            --tm-topbar-grad-end: #764ba2;
            --tm-topbar-text-color: #ffffff;
            --tm-topbar-control-bg: rgba(255,255,255,0.12);
            --tm-topbar-control-text: #ffffff;
            --tm-topbar-control-border: rgba(255,255,255,0.34);
            --tm-topbar-control-hover: rgba(0,0,0,0.12);
            --tm-topbar-seg-bg: rgba(255,255,255,0.18);
            --tm-topbar-seg-border: rgba(255,255,255,0.26);
            --tm-topbar-seg-item-text: rgba(255,255,255,0.86);
            --tm-topbar-seg-item-sep: rgba(255,255,255,0.22);
            --tm-topbar-seg-item-hover: rgba(0,0,0,0.12);
            --tm-topbar-seg-item-active-bg: rgba(0,0,0,0.26);
            --tm-topbar-seg-item-active-hover: rgba(0,0,0,0.32);
            --tm-topbar-search-bg: rgba(255,255,255,0.9);
            --tm-topbar-search-text: #333333;
            --tm-topbar-search-border: rgba(255,255,255,0.3);
            --tm-topbar-scrollbar-thumb: rgba(255,255,255,0.25);
            --tm-task-content-color: var(--tm-text-color);
            --tm-group-doc-label-color: var(--tm-text-color);
            --tm-time-group-base-color: #1a73e8;
            --tm-time-group-overdue-color: #d93025;
            --tm-quadrant-red: #ea4335;
            --tm-quadrant-yellow: #f9ab00;
            --tm-quadrant-blue: #1a73e8;
            --tm-quadrant-green: #34a853;
            --tm-whiteboard-grid-color: rgba(0,0,0,0.06);
        }

        [data-theme-mode="dark"] {
            --tm-bg-color: #1e1e1e;
            --tm-text-color: #e0e0e0;
            --tm-border-color: #333333;
            --tm-table-border-color: #333333;
            --tm-hover-bg: #2d2d2d;
            --tm-gantt-weekend-bg: rgba(0,0,0,0.46);
            --tm-secondary-text: #aaaaaa;
            --tm-modal-overlay: rgba(0,0,0,0.7);
            --tm-shadow: 0 10px 40px rgba(0,0,0,0.5);
            --tm-header-bg: #252525;
            --tm-input-bg: #2d2d2d;
            --tm-input-border: #444444;
            --tm-table-header-bg: #252525;
            --tm-table-border: #333333;
            --tm-task-done-color: #666666;
            --tm-doc-item-bg: #252525;
            --tm-doc-item-hover: #333333;
            --tm-doc-count-bg: #333333;
            --tm-doc-count-color: #6ba5ff;
            --tm-rule-group-bg: #252525;
            --tm-rule-item-bg: #2d2d2d;
            --tm-subgroup-bg: #2b3037;
            --tm-primary-color: #6ba5ff;
            --tm-success-color: #4caf50;
            --tm-danger-color: #ef5350;
            --tm-info-bg: #1a2733;
            --tm-info-border: #6ba5ff;
            --tm-section-bg: #252525;
            --tm-card-bg: #2d2d2d;
            --tm-empty-cell-bg: #1a1a1a;
            --tm-topbar-grad-start: #3b49b7;
            --tm-topbar-grad-end: #5b2d7a;
            --tm-topbar-text-color: #ffffff;
            --tm-task-content-color: var(--tm-text-color);
            --tm-group-doc-label-color: var(--tm-text-color);
            --tm-time-group-base-color: #6ba5ff;
            --tm-time-group-overdue-color: #ff6b6b;
            --tm-quadrant-red: #ef5350;
            --tm-quadrant-yellow: #f9ab00;
            --tm-quadrant-blue: #6ba5ff;
            --tm-quadrant-green: #4caf50;
            --tm-whiteboard-grid-color: rgba(255,255,255,0.10);
        }

        .tm-color-picker-backdrop {
            position: fixed;
            inset: 0;
            background: var(--tm-modal-overlay);
            z-index: 200005;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding: 12px;
            box-sizing: border-box;
        }

        .tm-color-picker-dialog {
            width: 100%;
            max-width: 520px;
            background: var(--tm-bg-color);
            border: 1px solid var(--tm-border-color);
            border-radius: 14px;
            box-shadow: var(--tm-shadow);
            padding: 14px;
            box-sizing: border-box;
        }

        .tm-color-grid-10 {
            display: grid;
            grid-template-columns: repeat(10, minmax(0, 1fr));
            gap: 8px;
        }

        .tm-color-grid-10 button {
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 8px;
            border: 1px solid var(--tm-border-color);
            padding: 0;
        }

        .tm-color-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 12px;
        }

        .tm-color-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            border: 1px solid var(--tm-border-color);
            border-radius: 8px;
            background: var(--tm-input-bg);
            color: var(--tm-text-color);
            cursor: pointer;
            min-width: 120px;
            justify-content: space-between;
        }

        .tm-color-swatch {
            width: 18px;
            height: 18px;
            border-radius: 6px;
            border: 1px solid var(--tm-border-color);
            flex: 0 0 auto;
        }

        .tm-color-text {
            font-size: 12px;
            opacity: 0.9;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        .tm-cell-editable {
            cursor: pointer;
            user-select: none;
            white-space: normal;
            word-break: break-all;
        }

        .tm-cell-editable:hover {
            background: var(--tm-hover-bg);
        }

        .tm-inline-editor {
            position: fixed;
            z-index: 100003;
            background: var(--tm-bg-color);
            border: 1px solid var(--tm-border-color);
            border-radius: 10px;
            padding: 10px;
            box-shadow: var(--tm-shadow);
            min-width: 220px;
            color: var(--tm-text-color);
        }

        .tm-inline-editor input,
        .tm-inline-editor select {
            width: 100%;
            box-sizing: border-box;
            padding: 8px 10px;
            border: 1px solid var(--tm-input-border);
            border-radius: 8px;
            font-size: 13px;
            background: var(--tm-input-bg);
            color: var(--tm-text-color);
        }

        .tm-inline-editor-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 10px;
        }

        .tm-cell-editor-input,
        .tm-cell-editor-select {
            width: 100%;
            box-sizing: border-box;
            padding: 4px 8px;
            border: 1px solid var(--tm-input-border);
            border-radius: 6px;
            font-size: 12px;
            height: 28px;
            background: var(--tm-input-bg);
            color: var(--tm-text-color);
        }

        .tm-group-row td {
            background: var(--tm-header-bg);
            color: var(--tm-text-color);
            font-weight: 600;
            border-bottom: none;
            overflow: visible;
        }

        .tm-table .tm-group-row td {
            padding: 0;
            height: var(--tm-row-height);
        }

        .tm-group-row[data-group-kind="h2"] td {
            background: var(--tm-subgroup-bg) !important;
        }

        .tm-group-sticky {
            position: sticky;
            left: 0;
            z-index: 3;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 0 12px;
            height: var(--tm-row-height);
            background: var(--tm-header-bg);
            box-shadow: inset 0 -1px 0 var(--tm-table-border-color);
        }

        .tm-group-row[data-group-kind="h2"] .tm-group-sticky {
            background: var(--tm-subgroup-bg);
        }

        .tm-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            font-weight: normal;
            font-size: 12px;
            padding: 1px 6px;
            border-radius: 10px;
            line-height: 1;
            height: 18px;
            box-sizing: border-box;
            vertical-align: middle;
            flex-shrink: 0;
        }

        .tm-badge--count {
            color: var(--tm-secondary-text);
            background: var(--tm-doc-count-bg);
        }

        .tm-badge--duration {
            color: var(--tm-primary-color);
            background: var(--tm-info-bg);
            border: 1px solid var(--tm-info-border);
        }

        .tm-badge__icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            height: 1em;
        }
        
        /* 四象限分组样式 */
        .tm-quadrant-group {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        
        .tm-quadrant-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .tm-quadrant-red { color: var(--tm-quadrant-red); }
        .tm-quadrant-yellow { color: var(--tm-quadrant-yellow); }
        .tm-quadrant-blue { color: var(--tm-quadrant-blue); }
        .tm-quadrant-green { color: var(--tm-quadrant-green); }
        
        .tm-quadrant-bg-red { background: var(--tm-quadrant-red); }
        .tm-quadrant-bg-yellow { background: var(--tm-quadrant-yellow); }
        .tm-quadrant-bg-blue { background: var(--tm-quadrant-blue); }
        .tm-quadrant-bg-green { background: var(--tm-quadrant-green); }
        
        /* 规则管理器样式 */
        .tm-rules-manager {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--tm-modal-overlay);
            z-index: 100002;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tm-rules-box {
            background: var(--tm-bg-color);
            width: 800px;
            max-width: 90vw;
            max-height: 80vh;
            border-radius: 12px;
            box-shadow: var(--tm-shadow);
            padding: 24px;
            display: flex;
            flex-direction: column;
            color: var(--tm-text-color);
        }
        
        .tm-rules-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .tm-rules-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--tm-text-color);
        }
        
        .tm-rules-body {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        
        .tm-rule-group {
            background: var(--tm-rule-group-bg);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            border: 1px solid var(--tm-border-color);
        }
        
        .tm-rule-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .tm-rule-group-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--tm-text-color);
            flex: 1;
        }
        
        .tm-rule-group-controls {
            display: flex;
            gap: 8px;
        }
        
        .tm-rule-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--tm-input-border);
            border-radius: 6px;
            font-size: 13px;
            margin-bottom: 10px;
            background: var(--tm-input-bg);
            color: var(--tm-text-color);
        }
        
        .tm-rule-input:focus {
            border-color: var(--tm-primary-color);
            outline: none;
        }
        
        .tm-rule-section {
            background: var(--tm-bg-color);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
            border: 1px solid var(--tm-border-color);
        }
        
        .tm-rule-section-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--tm-secondary-text);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tm-status-tag {
            display: inline-flex;
            align-items: center;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            color: #fff;
            white-space: nowrap;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .tm-status-tag:hover {
            opacity: 0.8;
        }

        .tm-status-select-modal {
            position: fixed;
            background: var(--tm-bg-color);
            border: 1px solid var(--tm-border-color);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            border-radius: 4px;
            z-index: 100005;
            padding: 4px;
            max-height: 200px;
            overflow-y: auto;
        }

        .tm-status-option {
            display: flex;
            align-items: center;
            padding: 6px 10px;
            cursor: pointer;
            border-radius: 4px;
            color: var(--tm-text-color);
            font-size: 13px;
        }

        .tm-status-option:hover {
            background: var(--tm-rule-item-bg);
        }

        .tm-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .tm-rule-conditions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .tm-rule-condition {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px;
            background: var(--tm-rule-item-bg);
            border-radius: 4px;
        }
        
        .tm-rule-condition-field {
            width: 120px;
            font-size: 12px;
            font-weight: 500;
            background: var(--tm-input-bg);
            color: var(--tm-text-color);
            border: 1px solid var(--tm-input-border);
            padding: 4px;
            border-radius: 4px;
        }
        
        .tm-rule-condition-operator {
            width: 80px;
            font-size: 12px;
            background: var(--tm-input-bg);
            color: var(--tm-text-color);
            border: 1px solid var(--tm-input-border);
            padding: 4px;
            border-radius: 4px;
        }
        
        .tm-rule-condition-value {
            flex: 1;
            font-size: 12px;
            background: var(--tm-input-bg);
            color: var(--tm-text-color);
            border: 1px solid var(--tm-input-border);
            padding: 4px;
            border-radius: 4px;
        }
        
        .tm-rule-sort-items {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .tm-rule-sort-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px;
            background: var(--tm-rule-item-bg);
            border-radius: 4px;
        }
        
        .tm-rule-sort-field {
            width: 120px;
            font-size: 12px;
            background: var(--tm-input-bg);
            color: var(--tm-text-color);
            border: 1px solid var(--tm-input-border);
            padding: 4px;
            border-radius: 4px;
        }
        
        .tm-rule-sort-order {
            width: 100px;
            font-size: 12px;
            background: var(--tm-input-bg);
            color: var(--tm-text-color);
            border: 1px solid var(--tm-input-border);
            padding: 4px;
            border-radius: 4px;
        }
        
        .tm-rule-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 10px;
        }
        
        .tm-rules-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--tm-border-color);
        }
        
        /* 规则选择器样式 */
        .tm-rule-selector {
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: 0;
        }
        
        .tm-rule-select {
            min-width: 72px;
            max-width: 160px;
            padding: 4px 8px;
            border: 1px solid var(--tm-input-border);
            border-radius: 4px;
            font-size: 12px;
            background: var(--tm-input-bg);
            color: var(--tm-text-color);
            height: 28px;
            min-height: 28px;
            line-height: 18px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .tm-rule-label {
            color: var(--tm-topbar-text-color);
            font-size: 12px;
            white-space: nowrap;
            flex: 0 0 auto;
        }

        @media (max-width: 1280px) {
            .tm-header-selectors .tm-rule-label {
                display: none;
            }
            .tm-header-selectors .tm-rule-select {
                max-width: 120px;
            }
        }

        .tm-rule-select:focus {
            border-color: var(--tm-primary-color);
            outline: none;
        }
        
        .tm-rule-info {
            font-size: 12px;
            color: var(--tm-secondary-text);
            background: var(--tm-info-bg);
            padding: 4px 8px;
            border-radius: 4px;
            border-left: 3px solid var(--tm-info-border);
        }
        
        .tm-rule-applied {
            font-size: 12px;
            color: var(--tm-success-color);
            font-weight: 500;
        }
        
        /* 时间范围选择器样式 */
        .tm-time-range {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tm-time-input {
            padding: 4px 8px;
            border: 1px solid var(--tm-input-border);
            border-radius: 4px;
            font-size: 12px;
            width: 140px;
            background: var(--tm-input-bg);
            color: var(--tm-text-color);
        }
        
        .tm-time-separator {
            color: var(--tm-secondary-text);
            font-size: 12px;
        }
        
        /* 规则按钮样式 */
        .tm-rule-btn {
            padding: 4px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .tm-rule-btn-primary {
            background: var(--tm-primary-color);
            color: white;
        }
        
        .tm-rule-btn-secondary {
            background: #757575;
            color: white;
        }
        
        .tm-rule-btn-success {
            background: var(--tm-success-color);
            color: white;
        }
        
        .tm-rule-btn-danger {
            background: var(--tm-danger-color);
            color: white;
        }
        
        .tm-rule-btn-add {
            background: var(--tm-info-bg);
            color: var(--tm-primary-color);
            border: 1px dashed var(--tm-primary-color);
        }
        
        /* 新增的筛选工具栏样式 */
        .tm-filter-rule-bar {
            padding: 12px 24px;
            background: linear-gradient(135deg, var(--tm-topbar-grad-start) 0%, var(--tm-topbar-grad-end) 100%);
            color: var(--tm-topbar-text-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tm-filter-rule-bar .tm-btn-info {
            background: var(--tm-topbar-control-bg);
            color: var(--tm-topbar-control-text);
            border: 1px solid var(--tm-topbar-control-border);
        }

        .tm-filter-rule-bar .tm-btn-info:hover {
            background: var(--tm-topbar-control-hover);
            opacity: 1;
        }

        .tm-filter-rule-bar .tm-rule-select {
            background: var(--tm-topbar-control-bg);
            color: var(--tm-topbar-control-text);
            border: 1px solid var(--tm-topbar-control-border);
        }

        .tm-filter-rule-bar .tm-rule-select:focus {
            border-color: var(--tm-topbar-control-text);
        }

        .tm-filter-rule-bar .tm-rule-select option {
            color: #111827;
            background: #ffffff;
        }

        .tm-filter-rule-bar .tm-popup-menu .tm-btn-info,
        .tm-filter-rule-bar #tmMobileMenu .tm-btn-info {
            background: var(--tm-info-bg);
            color: var(--tm-primary-color);
            border: 1px solid var(--tm-primary-color);
        }

        .tm-filter-rule-bar .tm-popup-menu .tm-btn-info:hover,
        .tm-filter-rule-bar #tmMobileMenu .tm-btn-info:hover {
            opacity: 0.9;
        }

        .tm-filter-rule-bar #tmMobileMenu .tm-rule-select {
            background: var(--tm-input-bg);
            color: var(--tm-text-color);
            border: 1px solid var(--tm-input-border);
        }

        .tm-filter-rule-bar #tmMobileMenu .tm-view-segmented {
            background: var(--tm-input-bg);
            border: 1px solid var(--tm-input-border);
        }

        .tm-filter-rule-bar #tmMobileMenu .tm-view-seg-item {
            color: var(--tm-text-color);
        }

        .tm-filter-rule-bar #tmMobileMenu .tm-view-seg-item + .tm-view-seg-item {
            border-left-color: var(--tm-input-border);
        }

        .tm-filter-rule-bar #tmMobileMenu .tm-view-seg-item:hover {
            background: var(--tm-hover-bg);
        }

        .tm-filter-rule-bar #tmMobileMenu .tm-view-seg-item--active {
            background: var(--tm-primary-color);
            color: #ffffff;
        }

        .tm-filter-rule-bar #tmMobileMenu .tm-view-seg-item--active:hover {
            opacity: 0.92;
        }

        .tm-filter-rule-bar #tmMobileMenu .tm-mobile-only-item {
            min-width: 0;
        }

        .tm-filter-rule-bar #tmMobileMenu .tm-mobile-only-item .tm-btn {
            min-width: 0;
        }

        .tm-filter-rule-bar #tmMobileMenu .tm-rule-select option {
            color: #111827;
            background: #ffffff;
        }

        .tm-header-selectors {
            min-width: 0;
            flex-wrap: nowrap;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .tm-header-selectors::-webkit-scrollbar {
            height: 4px;
        }

        .tm-header-selectors::-webkit-scrollbar-thumb {
            background: var(--tm-topbar-scrollbar-thumb);
            border-radius: 999px;
        }
        
        .tm-rule-display {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .tm-rule-name {
            font-weight: 600;
            font-size: 14px;
        }
        
        .tm-rule-stats {
            font-size: 12px;
            opacity: 0.9;
        }
        
        .tm-filter-active {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(66, 133, 244, 0.4); }
            70% { box-shadow: 0 0 0 5px rgba(66, 133, 244, 0); }
            100% { box-shadow: 0 0 0 0 rgba(66, 133, 244, 0); }
        }

        /* 浮动的任务管理按钮样式 */
        .tm-fab {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--tm-topbar-grad-start) 0%, var(--tm-topbar-grad-end) 100%);
            color: white;
            font-size: 14px;
            font-weight: 600;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 9999;
            padding: 10px;
        }

        .tm-fab:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .tm-fab:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.3);
        }

        /* 任务管理器弹窗样式 */
        .tm-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--tm-modal-overlay);
            z-index: 100001;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tm-modal.tm-modal--mobile {
            align-items: stretch;
            justify-content: stretch;
        }

        .tm-modal.tm-modal--mobile .tm-box {
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
            border-radius: 0;
        }

        .tm-modal.tm-modal--mobile .tm-body {
            max-height: none;
        }

        @media (max-width: 768px) {
            .tm-modal {
                align-items: stretch;
                justify-content: stretch;
            }
            .tm-modal .tm-box {
                width: 100%;
                height: 100%;
                max-width: none;
                max-height: none;
                border-radius: 0;
            }
            .tm-header {
                padding: 12px 14px;
            }
            .tm-body {
                max-height: none;
            }
        }

        /* Tab 模式下的容器样式（非遮罩层） */
        .tm-modal.tm-modal--tab {
            position: relative;
            top: auto;
            left: auto;
            width: 100%;
            height: 100%;
            z-index: auto;
            background: transparent;
            display: block;
        }

        .tm-modal.tm-modal--tab .tm-box {
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
            border-radius: 0;
            box-shadow: none;
        }

        .tm-modal.tm-modal--tab .tm-body {
            max-height: none;
            /* Tab 模式下也需要启用滚动以支持表头固定 */
            overflow-y: auto;
            overflow-x: auto;
        }

        .tm-modal.tm-modal--tab .tm-table th,
        .tm-modal.tm-modal--tab .tm-table thead th {
            /* Tab 模式下启用表头固定 */
            position: -webkit-sticky;
            position: sticky;
            top: 0;
            z-index: 10;
            /* 确保边框在滚动时可见 */
            box-shadow: inset 0 -1px 0 var(--tm-table-border-color);
        }

        .tm-box {
            background: var(--tm-bg-color);
            width: 90%;
            max-width: 95vw;
            max-height: 90vh;
            border-radius: 12px;
            box-shadow: var(--tm-shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            color: var(--tm-text-color);
        }

        .tm-modal:not(.tm-modal--mobile):not(.tm-modal--tab) .tm-box {
            height: 90vh;
        }

        .tm-header {
            padding: 20px 24px;
            background: var(--tm-header-bg);
            border-bottom: 1px solid var(--tm-border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .tm-stats {
            font-size: 13px;
            color: var(--tm-secondary-text);
        }

        .tm-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .tm-btn-secondary {
            background: var(--tm-bg-color);
            color: var(--tm-text-color);
            border: 1px solid var(--tm-border-color);
        }

        .tm-btn-secondary:hover {
            background: var(--tm-hover-bg);
            border-color: var(--tm-text-color);
        }

        select.tm-btn-secondary {
            background: var(--tm-bg-color) !important;
            color: var(--tm-text-color) !important;
            border: 1px solid var(--tm-border-color) !important;
        }

        .tm-btn-primary {
            background: var(--tm-primary-color);
            color: white;
        }

        .tm-btn-primary:hover {
            opacity: 0.9;
        }

        .tm-btn-success {
            background: var(--tm-success-color);
            color: white;
        }

        .tm-btn-success:hover {
            opacity: 0.9;
        }

        .tm-btn-gray {
            background: #757575;
            color: white;
        }

        .tm-btn-gray:hover {
            background: #616161;
        }

        .tm-btn-danger {
            background: var(--tm-danger-color);
            color: white;
        }

        .tm-btn-danger:hover {
            opacity: 0.9;
        }

        .tm-btn-info {
            background: var(--tm-info-bg);
            color: var(--tm-primary-color);
            border: 1px solid var(--tm-primary-color);
        }

        .tm-btn-info:hover {
            opacity: 0.9;
        }

        .tm-filter-rule-bar {
            padding: 12px 24px;
            background: linear-gradient(135deg, var(--tm-topbar-grad-start) 0%, var(--tm-topbar-grad-end) 100%);
            color: var(--tm-topbar-text-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tm-search-box {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tm-view-segmented {
            display: inline-flex;
            align-items: stretch;
            height: 30px;
            border-radius: 999px;
            overflow: hidden;
            background: var(--tm-topbar-seg-bg);
            border: 1px solid var(--tm-topbar-seg-border);
            flex: none;
        }

        .tm-view-seg-item {
            appearance: none;
            border: none;
            background: transparent;
            color: var(--tm-topbar-seg-item-text);
            padding: 0 12px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            line-height: 30px;
            white-space: nowrap;
            user-select: none;
        }

        .tm-view-seg-item + .tm-view-seg-item {
            border-left: 1px solid var(--tm-topbar-seg-item-sep);
        }

        .tm-view-seg-item:hover {
            background: var(--tm-topbar-seg-item-hover);
        }

        .tm-view-seg-item--active {
            background: var(--tm-topbar-seg-item-active-bg);
            color: var(--tm-topbar-control-text);
        }

        .tm-view-seg-item--active:hover {
            background: var(--tm-topbar-seg-item-active-hover);
        }

        .tm-search-input {
            padding: 6px 12px;
            border: 1px solid var(--tm-topbar-search-border);
            border-radius: 4px;
            font-size: 13px;
            background: var(--tm-topbar-search-bg);
            width: 200px;
            color: var(--tm-topbar-search-text);
        }

        .tm-search-input:focus {
            outline: none;
            border-color: var(--tm-topbar-control-text);
        }

        .tm-body {
            flex: 1;
            overflow: auto;
            padding: 0;
            /* 允许水平滚动 */
            overflow-x: auto;
            /* 最大高度限制，启用表头冻结 */
            max-height: calc(100vh - 200px);
            position: relative;
            /* 显式设置 overflow-y，确保 sticky 表头生效 */
            overflow-y: auto;
        }

        .tm-body.tm-body--timeline {
            overflow: hidden;
            overflow-x: hidden;
            overflow-y: hidden;
            display: flex;
            flex-direction: column;
        }

        .tm-body.tm-body--kanban {
            overflow: hidden;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 10px;
            max-height: none;
            height: 100%;
            min-height: 0;
            overscroll-behavior: contain;
        }

        .tm-body.tm-body--whiteboard {
            overflow: hidden;
            overflow-x: hidden;
            overflow-y: hidden;
            padding: 0;
            max-height: none;
            min-height: 0;
            background: var(--tm-bg-color);
        }

        .tm-whiteboard-viewport {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 0;
            overflow: hidden;
            cursor: grab;
            background:
                linear-gradient(0deg, transparent 31px, var(--tm-whiteboard-grid-color) 32px),
                linear-gradient(90deg, transparent 31px, var(--tm-whiteboard-grid-color) 32px),
                var(--tm-bg-color);
            background-size: 32px 32px, 32px 32px, auto;
            background-position: 0 0, 0 0, 0 0;
        }

        .tm-whiteboard-viewport.tm-whiteboard-viewport--panning {
            cursor: grabbing;
        }

        .tm-whiteboard-viewport.tm-whiteboard-viewport--tool-pan .tm-whiteboard-card {
            cursor: grab;
        }

        .tm-whiteboard-viewport.tm-whiteboard-viewport--tool-pan {
            touch-action: none;
        }

        .tm-whiteboard-viewport.tm-whiteboard-viewport--tool-pan.tm-whiteboard-viewport--panning,
        .tm-whiteboard-viewport.tm-whiteboard-viewport--tool-pan.tm-whiteboard-viewport--panning .tm-whiteboard-card {
            cursor: grabbing;
        }

        .tm-whiteboard-world {
            position: absolute;
            top: 0;
            left: 0;
            width: 50000px;
            min-height: 30000px;
            transform-origin: 0 0;
            will-change: transform;
            pointer-events: none;
        }

        .tm-whiteboard-world > * {
            pointer-events: auto;
        }

        .tm-whiteboard {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 1600px;
            min-height: 1200px;
            padding: 20px;
            box-sizing: border-box;
        }

        .tm-whiteboard-layout {
            display: flex;
            width: 100%;
            height: 100%;
            min-height: 0;
        }

        .tm-whiteboard-sidebar {
            width: var(--tm-wb-sidebar-width, 300px);
            min-width: var(--tm-wb-sidebar-width, 300px);
            max-width: var(--tm-wb-sidebar-width, 300px);
            border-right: 1px solid var(--tm-border-color);
            background: var(--tm-section-bg);
            overflow: auto;
            padding: 10px;
            box-sizing: border-box;
            z-index: 8;
            transition: width 220ms ease, min-width 220ms ease, max-width 220ms ease, padding 220ms ease, opacity 180ms ease, border-color 220ms ease;
        }

        .tm-whiteboard-layout.tm-whiteboard-layout--sidebar-collapsed .tm-whiteboard-sidebar {
            width: 0;
            min-width: 0;
            max-width: 0;
            padding: 0;
            opacity: 0;
            border-right-color: transparent;
            overflow: hidden;
            pointer-events: none;
        }

        .tm-whiteboard-sidebar-resizer {
            width: 8px;
            min-width: 8px;
            cursor: col-resize;
            background: transparent;
            border-right: 1px solid var(--tm-border-color);
            transition: background 140ms ease, width 220ms ease, min-width 220ms ease, opacity 180ms ease, border-color 220ms ease;
            z-index: 9;
        }

        .tm-whiteboard-sidebar-resizer:hover {
            background: rgba(127, 127, 127, 0.18);
        }

        .tm-whiteboard-layout.tm-whiteboard-layout--sidebar-collapsed .tm-whiteboard-sidebar-resizer {
            width: 0;
            min-width: 0;
            opacity: 0;
            border-right-color: transparent;
            pointer-events: none;
        }

        .tm-whiteboard-sidebar-title {
            font-size: 13px;
            font-weight: 700;
            color: var(--tm-text-color);
            margin-bottom: 8px;
        }

        .tm-whiteboard-sidebar-title-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 8px;
        }

        .tm-whiteboard-sidebar-switch {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            color: var(--tm-secondary-text);
            user-select: none;
        }

        .tm-whiteboard-pool-doc {
            margin-bottom: 10px;
            border: 1px solid var(--tm-border-color);
            border-radius: 10px;
            background: var(--tm-bg-color);
            overflow: hidden;
        }

        .tm-whiteboard-pool-doc-head {
            padding: 6px 8px;
            border-bottom: 1px solid var(--tm-border-color);
            background: var(--tm-table-header-bg);
            font-size: 12px;
            font-weight: 700;
        }

        .tm-whiteboard-pool-list {
            padding: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .tm-whiteboard-pool-node {
            display: block;
        }

        .tm-whiteboard-pool-h2 {
            font-size: 12px;
            font-weight: 700;
            color: var(--tm-secondary-text);
            padding: 2px 4px;
            cursor: grab;
            user-select: none;
        }

        .tm-whiteboard-pool-item {
            border: 1px solid var(--tm-border-color);
            border-radius: 8px;
            background: var(--tm-bg-color);
            padding: 7px 8px;
            font-size: 12px;
            line-height: 1.3;
            cursor: grab;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 1px 0 rgba(0,0,0,0.03);
        }

        .tm-whiteboard-pool-item.tm-whiteboard-pool-item--done {
            color: var(--tm-task-done-color);
            text-decoration: line-through;
        }

        .tm-whiteboard-pool-item.tm-whiteboard-pool-item--done .tm-whiteboard-pool-item-title {
            color: var(--tm-task-done-color);
        }

        .tm-whiteboard-pool-item.tm-whiteboard-pool-item--parent .tm-whiteboard-pool-item-title {
            font-weight: 700;
        }
        .tm-whiteboard-pool-item.tm-whiteboard-pool-item--top .tm-whiteboard-pool-item-title {
            font-weight: 700;
        }

        .tm-whiteboard-pool-item.tm-whiteboard-pool-item--locked {
            color: var(--tm-task-done-color);
            cursor: not-allowed;
            background: color-mix(in srgb, var(--tm-section-bg) 86%, var(--tm-bg-color));
        }

        .tm-whiteboard-pool-item.tm-whiteboard-pool-item--locked .tm-whiteboard-pool-item-title {
            color: var(--tm-task-done-color);
        }
        .tm-whiteboard-pool-item.tm-whiteboard-pool-item--selected {
            border-color: #2f6fed;
            box-shadow: 0 0 0 2px rgba(47,111,237,0.18);
            background: color-mix(in srgb, var(--tm-bg-color) 86%, #2f6fed 14%);
        }

        .tm-whiteboard-pool-toggle {
            flex: 0 0 auto;
            width: 14px;
            height: 14px;
            line-height: 12px;
            font-size: 12px;
            text-align: center;
            border: 1px solid var(--tm-border-color);
            border-radius: 4px;
            background: var(--tm-bg-color);
            color: var(--tm-secondary-text);
            cursor: pointer;
            padding: 0;
        }

        .tm-whiteboard-pool-toggle:hover {
            color: var(--tm-text-color);
            border-color: var(--tm-secondary-text);
        }

        .tm-whiteboard-pool-item-prefix {
            color: var(--tm-secondary-text);
            flex: 0 0 auto;
        }

        .tm-whiteboard-pool-item-title {
            min-width: 0;
            flex: 1 1 auto;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .tm-whiteboard-pool-item:active {
            cursor: grabbing;
        }

        .tm-whiteboard-main {
            flex: 1 1 auto;
            min-width: 0;
            min-height: 0;
            position: relative;
        }

        .tm-whiteboard-sidebar-toggle {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 12;
            padding: 4px 10px;
            border-radius: 8px;
        }

        .tm-whiteboard-board {
            position: relative;
            min-width: 2800px;
            min-height: 1800px;
        }

        .tm-whiteboard-doc {
            border: 1px solid var(--tm-border-color);
            border-radius: 12px;
            background: var(--tm-section-bg);
            overflow: visible;
            min-width: 560px;
            display: inline-block;
            width: fit-content;
        }

        .tm-whiteboard-doc-frame {
            position: absolute;
            border: 1px solid var(--tm-border-color);
            border-radius: 12px;
            background: color-mix(in srgb, var(--tm-section-bg) 92%, transparent);
            z-index: 1;
            box-sizing: border-box;
            overflow: visible;
        }

        .tm-whiteboard-doc-frame-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding: 8px 10px;
            border-bottom: 1px solid var(--tm-border-color);
            background: var(--tm-table-header-bg);
            font-weight: 700;
            font-size: 13px;
        }

        .tm-whiteboard-doc-frame-body {
            position: relative;
            width: 100%;
            height: calc(100% - 38px);
        }

        .tm-whiteboard-doc-resize {
            position: absolute;
            z-index: 6;
            background: transparent;
        }

        .tm-whiteboard-doc-resize--right {
            top: 0;
            right: -4px;
            width: 8px;
            height: 100%;
            cursor: ew-resize;
        }

        .tm-whiteboard-doc-resize--left {
            top: 0;
            left: -4px;
            width: 8px;
            height: 100%;
            cursor: ew-resize;
        }

        .tm-whiteboard-doc-resize--bottom {
            left: 0;
            bottom: -4px;
            width: 100%;
            height: 8px;
            cursor: ns-resize;
        }

        .tm-whiteboard-doc-resize--top {
            left: 0;
            top: -4px;
            width: 100%;
            height: 8px;
            cursor: ns-resize;
        }

        .tm-whiteboard-doc-resize--corner {
            right: -4px;
            bottom: -4px;
            width: 14px;
            height: 14px;
            border-radius: 4px;
            border: 1px solid var(--tm-border-color);
            background: var(--tm-bg-color);
            cursor: nwse-resize;
        }

        .tm-whiteboard-doc-resize--tl {
            left: -4px;
            top: -4px;
            width: 14px;
            height: 14px;
            border-radius: 4px;
            border: 1px solid var(--tm-border-color);
            background: var(--tm-bg-color);
            cursor: nwse-resize;
        }

        .tm-whiteboard-doc-resize--tr {
            right: -4px;
            top: -4px;
            width: 14px;
            height: 14px;
            border-radius: 4px;
            border: 1px solid var(--tm-border-color);
            background: var(--tm-bg-color);
            cursor: nesw-resize;
        }

        .tm-whiteboard-doc-resize--bl {
            left: -4px;
            bottom: -4px;
            width: 14px;
            height: 14px;
            border-radius: 4px;
            border: 1px solid var(--tm-border-color);
            background: var(--tm-bg-color);
            cursor: nesw-resize;
        }

        .tm-whiteboard-doc-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding: 10px 12px;
            border-bottom: 1px solid var(--tm-border-color);
            background: var(--tm-table-header-bg);
            font-weight: 700;
        }

        .tm-whiteboard-doc-body {
            position: relative;
            padding: 0;
            min-height: 220px;
            min-width: 520px;
            overflow: visible;
            background: transparent;
        }

        .tm-whiteboard-edges {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 2;
            overflow: visible;
        }

        .tm-whiteboard-edge {
            fill: none;
            stroke: #8aa0c6;
            stroke-width: 1.8;
            opacity: 0.9;
            pointer-events: none;
        }

        .tm-whiteboard-edge.tm-whiteboard-edge--auto {
            stroke-dasharray: 4 3;
            opacity: 0.65;
        }

        .tm-whiteboard-edge.tm-whiteboard-edge--manual {
            stroke: #2f6fed;
            pointer-events: stroke;
            cursor: pointer;
        }

        .tm-whiteboard-edge.tm-whiteboard-edge--selected {
            stroke-width: 2.6;
            opacity: 1;
        }

        .tm-whiteboard-edge.tm-whiteboard-multi-selected {
            stroke-width: 2.8;
            opacity: 1;
            filter: drop-shadow(0 0 1px rgba(47,111,237,.45));
        }

        .tm-whiteboard-edge.tm-whiteboard-edge--preview {
            stroke: #2f6fed;
            stroke-dasharray: 6 4;
            opacity: 0.9;
        }

        .tm-whiteboard-h2-section {
            position: relative;
            z-index: 3;
            border: 1px solid var(--tm-border-color);
            border-radius: 10px;
            background: var(--tm-bg-color);
            padding: 8px;
            margin-bottom: 10px;
        }

        .tm-whiteboard-h2-guides {
            position: absolute;
            inset: 0;
            z-index: 1;
            pointer-events: none;
        }

        .tm-whiteboard-h2-guide {
            position: absolute;
            left: 20px;
            right: 20px;
            border: 1px dashed var(--tm-border-color);
            border-radius: 12px;
            background: rgba(0,0,0,0.015);
        }

        .tm-whiteboard-h2-guide-title {
            position: absolute;
            left: 12px;
            top: -10px;
            padding: 0 6px;
            font-size: 12px;
            color: var(--tm-secondary-text);
            background: var(--tm-bg-color);
            border: 1px solid var(--tm-border-color);
            border-radius: 8px;
        }

        .tm-whiteboard-h2-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
            color: var(--tm-secondary-text);
            margin-bottom: 8px;
        }

        .tm-whiteboard-h2-lane {
            min-height: 74px;
            border-radius: 8px;
            border: 1px dashed var(--tm-border-color);
            padding: 8px;
        }

        .tm-whiteboard-cards {
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
            gap: 8px;
        }

        .tm-whiteboard-card {
            position: absolute;
            width: 300px;
            min-height: 62px;
            background: var(--tm-bg-color);
            border: 1px solid var(--tm-border-color);
            border-radius: 10px;
            box-shadow: 0 1px 0 rgba(0,0,0,0.03);
            padding: 8px;
            z-index: 3;
            cursor: move;
            user-select: none;
            box-sizing: border-box;
        }

        .tm-whiteboard-card.tm-whiteboard-card--selected {
            border-color: #2f6fed;
            box-shadow: 0 0 0 2px rgba(47,111,237,0.18);
        }

        .tm-whiteboard-subcard.tm-whiteboard-card--selected {
            border-color: #2f6fed;
            box-shadow: 0 0 0 2px rgba(47,111,237,0.18);
        }

        .tm-whiteboard-card.tm-whiteboard-multi-selected,
        .tm-whiteboard-subcard.tm-whiteboard-multi-selected,
        .tm-whiteboard-node.tm-whiteboard-multi-selected,
        .tm-whiteboard-note.tm-whiteboard-multi-selected {
            border-color: #2f6fed !important;
            box-shadow: 0 0 0 2px rgba(47,111,237,0.26) !important;
            outline: 1px solid rgba(47,111,237,0.55);
            outline-offset: 0;
        }

        .tm-whiteboard-card-tools {
            position: absolute;
            left: 0;
            top: -34px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            border: 1px solid var(--tm-border-color);
            border-radius: 8px;
            background: color-mix(in srgb, var(--tm-bg-color) 92%, transparent);
            box-shadow: 0 4px 10px rgba(0,0,0,0.12);
            z-index: 8;
        }

        .tm-whiteboard-card.tm-whiteboard-card--sub {
            background: var(--tm-section-bg);
        }

        .tm-whiteboard-node--root {
            position: absolute;
            z-index: 5;
        }

        .tm-whiteboard-node--root.tm-whiteboard-card--selected {
            z-index: 8;
        }

        .tm-whiteboard-node--root.tm-whiteboard-node--parent {
            z-index: 9;
        }

        .tm-whiteboard-node--root.tm-whiteboard-node--parent.tm-whiteboard-card--selected {
            z-index: 10;
        }

        .tm-whiteboard-card.tm-whiteboard-node--root:not(.tm-whiteboard-card--selected) {
            border-color: color-mix(in srgb, var(--tm-border-color) 82%, var(--tm-text-color) 18%);
            box-shadow: 0 4px 12px rgba(0,0,0,0.08), 0 1px 0 rgba(0,0,0,0.03);
        }

        .tm-whiteboard-node.tm-whiteboard-card--selected {
            border-color: #2f6fed !important;
            box-shadow: 0 0 0 2px rgba(47,111,237,0.18) !important;
        }

        .tm-whiteboard-node--sub {
            position: relative;
        }

        .tm-whiteboard-subcard {
            position: relative;
            border: 1px solid var(--tm-border-color);
            border-radius: 9px;
            background: var(--tm-section-bg);
            padding: 8px;
            box-sizing: border-box;
            cursor: move;
        }

        .tm-whiteboard-card-head {
            display: flex;
            align-items: flex-start;
            gap: 6px;
            margin-bottom: 4px;
            position: relative;
            padding-left: 0;
            padding-right: 0;
        }

        .tm-whiteboard-card-title {
            flex: 1 1 auto;
            min-width: 0;
            font-size: 13px;
            line-height: 1.25;
            word-break: break-word;
        }

        .tm-whiteboard-node--parent .tm-whiteboard-card-title {
            font-weight: 700;
        }
        .tm-whiteboard-node--root .tm-whiteboard-card-title {
            font-weight: 700;
        }

        .tm-whiteboard-card-title .tm-task-content-clickable {
            cursor: pointer;
        }

        .tm-whiteboard-subtasks {
            margin-top: 6px;
            padding-left: 10px;
            border-left: 2px solid var(--tm-border-color);
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .tm-whiteboard-note {
            border: 1px solid var(--tm-border-color);
            border-radius: 8px;
            background: var(--tm-header-bg);
            color: var(--tm-text-color);
            font-size: 12px;
            padding: 6px 8px;
            max-width: none;
            margin-bottom: 8px;
            white-space: pre;
            word-break: normal;
            cursor: move;
            user-select: none;
            box-sizing: border-box;
        }

        .tm-whiteboard-note.tm-whiteboard-note--selected {
            border-color: #2f6fed;
            box-shadow: 0 0 0 2px rgba(47,111,237,0.18);
        }

        .tm-whiteboard-note-tools {
            position: absolute;
            left: 0;
            top: 0;
            transform: translateY(calc(-100% - 6px));
            display: inline-flex;
            align-items: center;
            flex-wrap: nowrap;
            white-space: nowrap;
            gap: 6px;
            padding: 4px 6px;
            border: 1px solid var(--tm-border-color);
            border-radius: 8px;
            background: color-mix(in srgb, var(--tm-bg-color) 92%, transparent);
            box-shadow: 0 4px 10px rgba(0,0,0,0.12);
            z-index: 8;
        }
        .tm-whiteboard-note-tools .tm-btn {
            white-space: nowrap;
            flex: 0 0 auto;
            min-width: 28px;
            line-height: 1.1;
        }
        .tm-whiteboard-note-resize {
            position: absolute;
            right: -6px;
            bottom: -6px;
            width: 12px;
            height: 12px;
            border-radius: 3px;
            border: 1px solid #2f6fed;
            background: color-mix(in srgb, #2f6fed 72%, #ffffff);
            cursor: nwse-resize;
            z-index: 9;
            box-shadow: 0 1px 2px rgba(0,0,0,0.18);
        }
        .tm-whiteboard-note-width-resize {
            position: absolute;
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
            width: 10px;
            height: 18px;
            border-radius: 3px;
            border: 1px solid #2f6fed;
            background: color-mix(in srgb, #2f6fed 60%, #ffffff);
            cursor: ew-resize;
            z-index: 9;
            box-shadow: 0 1px 2px rgba(0,0,0,0.18);
        }

        .tm-whiteboard-note-editor {
            position: absolute;
            min-width: 160px;
            max-width: 360px;
            min-height: 72px;
            padding: 6px 8px;
            border: 1px solid var(--tm-primary-color);
            border-radius: 8px;
            background: var(--tm-bg-color);
            color: var(--tm-text-color);
            font-size: 12px;
            line-height: 1.35;
            resize: both;
            z-index: 9;
            box-shadow: 0 4px 12px rgba(0,0,0,0.14);
            outline: none;
        }

        .tm-whiteboard-link-tools {
            position: absolute;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 4px 6px;
            border: 1px solid var(--tm-border-color);
            border-radius: 8px;
            background: color-mix(in srgb, var(--tm-bg-color) 92%, transparent);
            box-shadow: 0 4px 10px rgba(0,0,0,0.12);
            width: auto;
            height: auto;
            box-sizing: border-box;
            z-index: 12;
            pointer-events: auto;
        }

        .tm-whiteboard-marquee {
            position: absolute;
            border: 1px dashed #2f6fed;
            background: rgba(47,111,237,0.12);
            pointer-events: none;
            z-index: 11;
        }

        .tm-whiteboard-multi-tools {
            position: absolute;
            transform: translate(-50%, -100%);
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            border: 1px solid var(--tm-border-color);
            border-radius: 8px;
            background: color-mix(in srgb, var(--tm-bg-color) 92%, transparent);
            box-shadow: 0 4px 10px rgba(0,0,0,0.12);
            z-index: 12;
        }

        .tm-whiteboard-toolbar {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        .tm-task-link-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 1px solid var(--tm-border-color);
            background: var(--tm-bg-color);
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            display: inline-flex;
            cursor: crosshair;
            user-select: none;
            z-index: 5;
            opacity: 0;
            pointer-events: none;
            transition: opacity .16s ease;
        }

        .tm-whiteboard-node > .tm-task-link-dot {
            top: 50%;
        }

        .tm-whiteboard-node:hover > .tm-task-link-dot,
        .tm-whiteboard-node.tm-whiteboard-node--has-links > .tm-task-link-dot,
        .tm-whiteboard-node.tm-whiteboard-node--link-hover > .tm-task-link-dot,
        .tm-whiteboard-node > .tm-task-link-dot.tm-task-link-dot--active {
            opacity: 1;
            pointer-events: auto;
        }

        .tm-whiteboard-node > .tm-task-link-dot--in {
            left: -1px;
        }

        .tm-whiteboard-node > .tm-task-link-dot--out {
            left: calc(100% + 1px);
        }

        .tm-whiteboard-collapse-proxy-dot {
            top: auto !important;
            left: 50% !important;
            bottom: -6px;
            transform: translateX(-50%);
            border-color: #2f6fed;
            background: color-mix(in srgb, var(--tm-bg-color) 86%, #2f6fed 14%);
            z-index: 6;
        }

        .tm-task-link-dot--timeline {
            width: 8px;
            height: 8px;
            top: 50%;
            z-index: 6;
            opacity: 0;
            pointer-events: none;
            transition: opacity .16s ease;
            border-color: #2f6fed;
            background: var(--tm-bg-color) !important;
        }

        .tm-task-link-dot--in {
            left: 0;
        }

        .tm-task-link-dot--out {
            left: 100%;
        }

        .tm-task-link-dot.tm-task-link-dot--out {
            background: #2f6fed;
            border-color: #2f6fed;
        }

        .tm-task-link-dot.tm-task-link-dot--in {
            background: #ffffff;
            border-color: #2f6fed;
        }

        .tm-task-link-dot.tm-task-link-dot--active {
            box-shadow: 0 0 0 2px rgba(47,111,237,0.24);
        }

        .tm-gantt-row:hover .tm-task-link-dot--timeline,
        .tm-gantt-row.tm-gantt-row--dot-open .tm-task-link-dot--timeline,
        .tm-gantt-row.tm-gantt-row--link-hover .tm-task-link-dot--timeline,
        .tm-task-link-dot--timeline.tm-task-link-dot--active {
            opacity: 1;
            pointer-events: auto;
        }

        .tm-gantt-body--dragging-x .tm-task-link-dot--timeline {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        .tm-link-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 18px;
            height: 16px;
            padding: 0 4px;
            border-radius: 8px;
            background: var(--tm-doc-count-bg);
            color: var(--tm-secondary-text);
            font-size: 11px;
            line-height: 1;
        }

        .tm-whiteboard-bottom-toolbar {
            position: absolute;
            left: 50%;
            bottom: 12px;
            transform: translateX(-50%);
            z-index: 9;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            padding: 8px 10px;
            border: 1px solid var(--tm-border-color);
            border-radius: 10px;
            background: color-mix(in srgb, var(--tm-bg-color) 90%, transparent);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
            backdrop-filter: blur(4px);
        }

        .tm-kanban {
            display: flex;
            gap: 10px;
            align-items: stretch;
            width: max-content;
            min-height: 100%;
            height: 100%;
        }

        .tm-kanban-col {
            width: 320px;
            min-width: 280px;
            max-width: 360px;
            background: var(--tm-table-header-bg);
            border: 1px solid var(--tm-border-color);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            height: 100%;
            max-height: 100%;
        }

        .tm-kanban-col.tm-kanban-col--dragover {
            border-color: var(--tm-primary-color);
            box-shadow: 0 0 0 2px rgba(0,0,0,0.04);
        }

        .tm-kanban-col-header {
            padding: 10px 10px 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            font-weight: 700;
            color: var(--tm-text-color);
            border-bottom: 1px solid var(--tm-border-color);
            position: sticky;
            top: 0;
            background: var(--tm-table-header-bg);
            z-index: 6;
            border-top-left-radius: 10px;
            border-top-right-radius: 10px;
        }

        .tm-kanban-col-title {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1 1 auto;
            min-width: 0;
        }

        .tm-kanban-col-title.tm-kanban-col-title--pill {
            padding: 4px 10px;
            border-radius: 999px;
            line-height: 1.1;
            font-weight: 800;
            font-size: 13px;
            flex: 0 1 auto;
            width: fit-content;
        }

        .tm-kanban--compact {
            gap: 8px;
        }

        .tm-kanban--compact .tm-kanban-col {
            width: 270px;
            min-width: 240px;
            max-width: 300px;
        }

        .tm-kanban--compact .tm-kanban-col-header {
            padding: 8px 8px 6px;
        }

        .tm-kanban--compact .tm-kanban-col-title.tm-kanban-col-title--pill {
            padding: 3px 8px;
            font-size: 12px;
        }

        .tm-kanban--compact .tm-kanban-col-body {
            padding: 8px;
            gap: 6px;
        }

        .tm-kanban--compact .tm-kanban-card {
            padding: 8px;
            border-radius: 9px;
        }

        .tm-kanban--compact .tm-kanban-card-top {
            margin-bottom: 4px;
        }

        .tm-kanban--compact .tm-kanban-card-meta {
            gap: 4px;
            margin-bottom: 4px;
            font-size: 11px;
        }

        .tm-kanban--compact .tm-kanban-card-title-inline {
            -webkit-line-clamp: 1;
        }

        .tm-kanban--compact .tm-kanban-chip {
            padding: 1px 7px;
            font-size: 11px;
        }

        .tm-kanban--compact .tm-kanban-more {
            height: 22px;
            min-width: 26px;
            padding: 0 6px;
            line-height: 20px;
        }

        .tm-kanban--compact .tm-kanban-subtasks {
            margin-top: 6px;
            padding-left: 8px;
            gap: 6px;
        }

        .tm-kanban-col-body {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow: auto;
            min-height: 120px;
            flex: 1 1 auto;
            overscroll-behavior: contain;
        }

        .tm-kanban-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .tm-kanban-group-title {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            border-radius: 6px;
            background: var(--tm-header-bg);
            border: 1px solid var(--tm-border-color);
            font-size: 12px;
            font-weight: 600;
            color: var(--tm-text-color);
            cursor: pointer;
            user-select: none;
        }

        .tm-kanban-group-items {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .tm-kanban-card {
            background: var(--tm-bg-color);
            border: 1px solid var(--tm-table-border-color);
            border-radius: 10px;
            padding: 10px;
            color: var(--tm-text-color);
            box-shadow: 0 1px 0 rgba(0,0,0,0.03);
        }

        .tm-kanban-card.tm-kanban-card--dragging {
            opacity: 0.65;
        }

        .tm-kanban-subtasks {
            margin-top: 8px;
            padding-left: 10px;
            border-left: 2px solid var(--tm-border-color);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .tm-kanban-card.tm-kanban-card--sub {
            background: var(--tm-section-bg);
        }

        .tm-kanban-card:not(.tm-kanban-card--sub):not(.tm-kanban-card--childroot) .tm-kanban-card-title-inline {
            font-weight: 700;
        }

        .tm-kanban-parent-line strong {
            font-weight: 700;
            color: var(--tm-text-color);
        }

        .tm-kanban-card-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 6px;
        }

        .tm-kanban-card-head {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            flex: 1 1 auto;
            min-width: 0;
        }

        .tm-kanban-card-head .tm-task-checkbox {
            margin-top: 1px;
        }

        .tm-kanban-card-head .tm-kanban-toggle {
            margin-top: 0px;
        }

        .tm-kanban-card-title {
            font-size: 13px;
            line-height: 1.35;
            margin-bottom: 8px;
            word-break: break-word;
        }

        .tm-kanban-card-title .tm-task-content-clickable {
            cursor: pointer;
        }

        .tm-kanban-card-title-inline {
            font-size: 13px;
            line-height: 1.25;
            word-break: break-word;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            flex: 1 1 auto;
            min-width: 0;
        }

        .tm-kanban-toggle {
            width: 20px;
            height: 20px;
            border: 1px solid var(--tm-border-color);
            background: transparent;
            color: var(--tm-secondary-text);
            border-radius: 6px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            flex: 0 0 auto;
        }

        .tm-kanban-toggle:hover {
            background: var(--tm-table-header-bg);
            color: var(--tm-text-color);
        }

        .tm-kanban-card-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
            font-size: 12px;
            color: var(--tm-secondary-text);
            margin-bottom: 6px;
        }

        .tm-kanban-chip {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 12px;
            line-height: 1.1;
            cursor: pointer;
            user-select: none;
            border: 1px solid transparent;
        }

        .tm-kanban-chip--muted {
            background: var(--tm-doc-count-bg);
            color: var(--tm-secondary-text);
        }

        .tm-kanban-more {
            border: 1px solid var(--tm-border-color);
            background: transparent;
            color: var(--tm-secondary-text);
            border-radius: 8px;
            height: 24px;
            min-width: 28px;
            padding: 0 8px;
            cursor: pointer;
            line-height: 22px;
        }

        .tm-kanban-more:hover {
            background: var(--tm-table-header-bg);
        }

        .tm-task-detail-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.4);
            z-index: 200001;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .tm-task-detail {
            width: 520px;
            max-width: 95vw;
            max-height: 90vh;
            overflow: auto;
            background: var(--tm-bg-color);
            border: 1px solid var(--tm-border-color);
            border-radius: 12px;
            box-shadow: var(--tm-shadow);
            padding: 16px;
            color: var(--tm-text-color);
        }

        .tm-task-detail-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 8px 0;
            border-bottom: 1px solid var(--tm-border-color);
        }

        .tm-task-detail-row:last-child {
            border-bottom: none;
        }

        .tm-task-detail-label {
            font-size: 12px;
            color: var(--tm-secondary-text);
            flex: 0 0 auto;
            width: 92px;
        }

        .tm-task-detail-value {
            flex: 1 1 auto;
            min-width: 0;
        }

        .tm-task-detail-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 12px;
        }

        .tm-timeline-split {
            flex: 1;
            display: flex;
            min-height: 0;
            width: 100%;
        }

        .tm-timeline-left {
            flex: 0 0 auto;
            width: 540px;
            min-width: 360px;
            max-width: 900px;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .tm-timeline-splitter {
            flex: 0 0 auto;
            width: 6px;
            cursor: col-resize;
            background: transparent;
            position: relative;
        }

        .tm-timeline-splitter::before {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            left: 2px;
            width: 2px;
            background: var(--tm-border-color);
            opacity: 0.9;
        }

        .tm-timeline-splitter:hover::before {
            background: var(--tm-primary-color);
            opacity: 1;
        }

        .tm-timeline-left-body {
            flex: 1;
            min-height: 0;
            overflow: auto;
            position: relative;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .tm-timeline-left-body::-webkit-scrollbar {
            width: 0;
            height: 0;
        }

        .tm-timeline-right {
            flex: 1 1 auto;
            min-width: 0;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .tm-timeline-right-header {
            flex: 0 0 auto;
            overflow: hidden;
            background: var(--tm-table-header-bg);
            height: var(--tm-header-height);
            box-shadow: inset 0 -1px 0 var(--tm-border-color);
        }

        .tm-timeline-right-body {
            flex: 1;
            min-height: 0;
            overflow: auto;
            position: relative;
            background: var(--tm-bg-color);
        }

        .tm-timeline-table-left {
            min-width: 0;
            width: max-content;
            table-layout: fixed;
        }

        .tm-body--timeline .tm-timeline-table-left {
            border-collapse: collapse;
        }

        .tm-body--timeline .tm-timeline-table-left thead th {
            height: var(--tm-header-height);
            padding: 0 4px;
            line-height: var(--tm-header-height);
            vertical-align: middle;
        }

        .tm-body--timeline .tm-timeline-left-body thead th {
            position: sticky;
            top: 0;
            z-index: 6;
            background: var(--tm-table-header-bg);
            box-shadow: inset 0 -1px 0 var(--tm-border-color);
        }

        .tm-timeline-row td {
            height: var(--tm-row-height);
            max-height: var(--tm-row-height);
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            padding: 0 6px;
            box-sizing: border-box;
            box-shadow: inset 0 -1px 0 var(--tm-table-border-color);
        }

        .tm-body--timeline #tmTimelineLeftTable tbody tr {
            height: var(--tm-row-height);
        }

        .tm-body--timeline #tmTimelineLeftTable tbody td {
            box-sizing: border-box;
        }

        .tm-body--timeline .tm-cell-editable {
            white-space: nowrap;
            word-break: keep-all;
        }

        .tm-body--timeline .tm-task-cell {
            height: var(--tm-row-height);
            max-height: var(--tm-row-height);
            overflow: hidden;
            align-items: center;
            padding-top: 0;
            padding-bottom: 0;
        }

        .tm-body--timeline .tm-task-text,
        .tm-body--timeline .tm-task-content-clickable {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .tm-body--timeline .tm-group-row td {
            height: var(--tm-row-height);
            max-height: var(--tm-row-height);
            padding: 0;
            line-height: var(--tm-row-height);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .tm-gantt-header-inner {
            display: flex;
            flex-direction: column;
            user-select: none;
        }

        .tm-gantt-month-row,
        .tm-gantt-day-row {
            display: flex;
            flex-direction: row;
        }

        .tm-gantt-month {
            height: 20px;
            line-height: 20px;
            font-size: 12px;
            padding-left: 6px;
            box-sizing: border-box;
            border-right: 1px solid var(--tm-border-color);
            color: var(--tm-text-color);
            opacity: 0.9;
        }

        .tm-gantt-day {
            height: 24px;
            line-height: 24px;
            font-size: 12px;
            text-align: center;
            box-sizing: border-box;
            border-right: 1px solid var(--tm-border-color);
            color: var(--tm-text-color);
            opacity: 0.9;
        }

        .tm-gantt-day--weekend {
            background: var(--tm-gantt-weekend-bg);
        }

        .tm-gantt-day--month-start {
            border-left: 2px solid var(--tm-border-color);
        }

        .tm-gantt-body-inner {
            position: relative;
        }

        .tm-gantt-deps {
            position: absolute;
            inset: 0;
            z-index: 3;
            pointer-events: none;
        }

        .tm-gantt-dep {
            fill: none;
            stroke: #6d88b6;
            stroke-width: 1.4;
            opacity: 0.86;
            vector-effect: non-scaling-stroke;
        }

        .tm-gantt-dep.tm-gantt-dep--auto {
            stroke-dasharray: 4 3;
            opacity: 0.58;
        }

        .tm-gantt-dep.tm-gantt-dep--manual {
            stroke: #2f6fed;
        }

        .tm-gantt-row {
            position: relative;
            height: var(--tm-row-height);
            box-sizing: border-box;
            border-bottom: none;
            box-shadow: inset 0 -1px 0 var(--tm-border-color);
        }

        .tm-gantt-row.tm-gantt-row--multi-selected {
            background: color-mix(in srgb, var(--tm-primary-color) 16%, transparent);
        }

        .tm-gantt-row.tm-gantt-row--multi-selected .tm-gantt-bar {
            outline: 2px solid var(--tm-primary-color);
            outline-offset: 1px;
        }

        .tm-gantt-row--group {
            background: var(--tm-header-bg);
        }

        .tm-gantt-today {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(255, 82, 82, 0.55);
            pointer-events: none;
            z-index: 7;
        }

        .tm-gantt-bar {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            height: var(--tm-gantt-bar-height);
            background: var(--tm-primary-color);
            border-radius: calc(var(--tm-gantt-bar-height) / 2);
            box-shadow: 0 1px 2px rgba(0,0,0,0.18);
            cursor: grab;
            z-index: 4;
        }

        .tm-gantt-bar:active {
            cursor: grabbing;
        }

        .tm-gantt-milestone {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            color: #e53935;
            font-size: 18px;
            line-height: 1;
            cursor: pointer;
            z-index: 8;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            user-select: none;
        }

        .tm-gantt-bar-handle {
            position: absolute;
            top: 0;
            width: 10px;
            height: 100%;
            background: rgba(255,255,255,0.35);
            cursor: ew-resize;
        }

        .tm-gantt-bar-handle--start {
            left: 0;
            border-top-left-radius: 9px;
            border-bottom-left-radius: 9px;
        }

        .tm-gantt-bar-handle--end {
            right: 0;
            border-top-right-radius: 9px;
            border-bottom-right-radius: 9px;
        }

        .tm-gantt-drag-tip {
            position: fixed;
            z-index: 1000002;
            padding: 6px 10px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.78);
            color: #fff;
            font-size: 12px;
            line-height: 1;
            pointer-events: none;
            transform: translate(10px, -18px);
            white-space: nowrap;
            font-variant-numeric: tabular-nums;
        }

        .tm-table {
            width: max-content;
            border-collapse: collapse;
            font-size: var(--tm-font-size);
            /* 最小宽度，确保在窄屏下可以横向滚动 */
            min-width: 800px;
            /* 固定表格布局，确保表头和单元格宽度一致 */
            table-layout: fixed;
        }

        .tm-table th {
            background: var(--tm-table-header-bg);
            padding: 4px 4px;
            text-align: left;
            font-weight: 600;
            color: var(--tm-text-color);
            /* 使用 box-shadow 替代 border-bottom，确保滚动时边框始终可见 */
            border-bottom: none;
            box-shadow: inset 0 -1px 0 var(--tm-table-border-color);
            /* 添加右侧列分隔线 */
            border-right: 1px solid var(--tm-table-border-color);
            /* 表头固定 */
            position: -webkit-sticky; /* Safari 浏览器 */
            position: sticky;
            top: 0;
            z-index: 10;
            /* 确保背景不透明，防止滚动时透视 */
            background-clip: padding-box;
            /* 表头文本截断样式：缩窄列时直接截断文本 */
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: clip !important;
        }

        .tm-table thead th {
            /* 使用 box-shadow 确保边框在滚动时始终可见 */
            box-shadow: inset 0 -1px 0 var(--tm-table-border-color);
            position: sticky;
            top: 0;
            z-index: 20;
            /* 最后一列不显示右侧边框 */
            border-right: 1px solid var(--tm-table-border-color);
        }

        .tm-body:not(.tm-body--timeline) .tm-table thead th {
            height: var(--tm-table-header-height);
            line-height: var(--tm-table-header-height);
            padding: 0 4px;
        }
        
        /* 最后一列不显示右侧边框 */
        .tm-table th:last-child,
        .tm-table td:last-child {
            border-right: none;
        }

        /* 悬停时用浏览器原生提示条显示完整文本，不改变布局 */
        .tm-table th:hover {
            /* 保持截断样式不变，仅依赖title属性显示完整文本 */
        }

        /* 确保表头不受 .tm-cell-editable 影响 */
        .tm-table th.tm-cell-editable {
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: clip !important;
            word-break: normal !important;
        }

        .tm-table td {
            padding: 0 6px;
            border-bottom: none;
            box-shadow: inset 0 -1px 0 var(--tm-table-border-color);
            border-right: 1px solid var(--tm-table-border-color);
            vertical-align: middle;
            color: var(--tm-text-color);
            height: var(--tm-row-height);
            max-height: var(--tm-row-height);
            box-sizing: border-box;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }
        
        .tm-table tr.tm-group-row td {
            overflow: visible;
        }

        .tm-body:not(.tm-body--timeline) #tmTaskTable tbody tr {
            height: var(--tm-row-height);
        }

        .tm-table td.tm-cell-empty {
            background: var(--tm-empty-cell-bg);
            color: var(--tm-secondary-text);
        }

        .tm-table tr:hover {
            background: var(--tm-hover-bg);
        }

        .tm-table tr.tm-timer-dim {
            opacity: 0.28;
        }

        .tm-table tr.tm-timer-focus {
            opacity: 1;
            background: rgba(66, 133, 244, 0.12);
            box-shadow: inset 0 0 0 2px var(--tm-primary-color);
        }

        .tm-table tr.tm-timer-focus:hover {
            background: rgba(66, 133, 244, 0.16);
        }

        /* 列宽调整手柄 */
        .tm-col-resize {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 6px;
            cursor: col-resize;
            background: transparent;
            transition: background 0.2s;
        }

        .tm-col-resize:hover,
        .tm-col-resize:active {
            background: #3498db;
        }

        th[data-col] {
            position: relative;
            user-select: none;
        }

        .tm-task-done {
            text-decoration: line-through;
            color: var(--tm-task-done-color);
        }

        .tm-block-highlight {
            outline: 2px solid var(--tm-primary-color);
            background: rgba(66, 133, 244, 0.12);
        }

        .tm-task-cell {
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: 0;
            padding-top: 2px;
            padding-bottom: 2px;
        }

        .tm-body:not(.tm-body--timeline) .tm-task-cell {
            height: var(--tm-row-height);
            max-height: var(--tm-row-height);
            overflow: hidden;
            padding-top: 0;
            padding-bottom: 0;
        }

        .tm-task-text {
            flex: 1 1 auto;
            min-width: 0;
            display: block;
            overflow: hidden;
            white-space: normal;
            word-break: break-all;
            line-height: 1.5;
        }

        .tm-body:not(.tm-body--timeline) .tm-task-text {
            white-space: nowrap;
            word-break: keep-all;
            text-overflow: ellipsis;
        }

        .tm-task-text:not(.tm-task-done) {
            color: var(--tm-task-content-color);
        }

        /* 顶层任务字体加粗 */
        .tm-task-text[data-level="0"] {
            font-weight: 600;
        }

        .tm-task-content-clickable {
            cursor: pointer;
            transition: color 0.2s;
        }
        
        .tm-task-content-clickable:hover {
            color: var(--tm-primary-color);
            text-decoration: underline;
        }

        .tm-tree-toggle {
            width: 14px;
            height: 14px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            color: var(--tm-secondary-text);
            flex-shrink: 0;
            vertical-align: middle;
            margin-top: -3px;
        }

        .tm-tree-spacer {
            width: 14px;
            height: 14px;
            display: inline-flex;
            flex-shrink: 0;
            margin-top: calc((1.5em - 14px) / 2);
        }

        .tm-task-checkbox {
            width: 14px;
            height: 14px;
            margin: 0;
            flex-shrink: 0;
        }

        .tm-priority-high {
            color: var(--tm-danger-color) !important;
            font-weight: 600;
        }

        .tm-priority-medium {
            color: #f9ab00 !important;
            font-weight: 600;
        }

        .tm-priority-low {
            color: var(--tm-primary-color) !important;
            font-weight: 600;
        }

        .tm-priority-none {
            color: var(--tm-task-done-color) !important;
        }

        .tm-hint {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            z-index: 100003;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @keyframes tmBodyFadeSlide {
            from { opacity: 1; transform: translateY(6px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .tm-body.tm-body-anim {
            animation: tmBodyFadeSlide 180ms ease-out;
        }

        @keyframes tmBodyInFromRight {
            from { opacity: 1; transform: translateX(26px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes tmBodyInFromLeft {
            from { opacity: 1; transform: translateX(-18px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .tm-body.tm-body-anim--from-right {
            animation: tmBodyInFromRight 220ms cubic-bezier(0.2, 0, 0, 1);
        }

        .tm-body.tm-body-anim--from-left {
            animation: tmBodyInFromLeft 220ms cubic-bezier(0.2, 0, 0, 1);
        }

        /* 提示框样式 */
        .tm-prompt-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--tm-modal-overlay);
            z-index: 100003;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tm-prompt-box {
            background: var(--tm-bg-color);
            padding: 24px;
            border-radius: 12px;
            box-shadow: var(--tm-shadow);
            min-width: 350px;
            color: var(--tm-text-color);
        }

        .tm-prompt-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--tm-text-color);
            margin-bottom: 16px;
        }

        .tm-prompt-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--tm-input-border);
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 16px;
            box-sizing: border-box;
            background: var(--tm-input-bg);
            color: var(--tm-text-color);
        }

        .tm-prompt-input:focus {
            border-color: var(--tm-primary-color);
            outline: none;
        }

        .tm-prompt-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .tm-prompt-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
        }

        .tm-prompt-btn-primary {
            background: var(--tm-primary-color);
            color: white;
        }

        .tm-prompt-btn-secondary {
            background: #757575;
            color: white;
        }

        /* 设置弹窗样式 */
        .tm-settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--tm-modal-overlay);
            z-index: 100002;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tm-settings-box {
            background: var(--tm-bg-color);
            width: 600px;
            max-width: 90vw;
            max-height: 80vh;
            border-radius: 12px;
            box-shadow: var(--tm-shadow);
            padding: 24px;
            display: flex;
            flex-direction: column;
            color: var(--tm-text-color);
        }

        .tm-settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .tm-settings-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--tm-text-color);
        }

        .tm-doc-list {
            flex: 1;
            overflow-y: auto;
            border: 1px solid var(--tm-border-color);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 16px;
            min-height: 100px;
        }

        .tm-doc-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 8px;
            background: var(--tm-doc-item-bg);
            transition: all 0.2s;
        }

        .tm-doc-item:hover {
            background: var(--tm-doc-item-hover);
        }

        .tm-doc-item:last-child {
            margin-bottom: 0;
        }

        .tm-doc-checkbox {
            margin-right: 12px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .tm-doc-info {
            flex: 1;
        }

        .tm-doc-name {
            font-weight: 500;
            color: var(--tm-text-color);
            margin-bottom: 2px;
        }

        .tm-doc-path {
            font-size: 12px;
            color: var(--tm-secondary-text);
        }

        .tm-doc-count {
            font-size: 12px;
            color: var(--tm-doc-count-color);
            background: var(--tm-doc-count-bg);
            padding: 2px 8px;
            border-radius: 10px;
        }

        .tm-settings-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding-top: 16px;
            border-top: 1px solid var(--tm-border-color);
            margin-top: auto;
            flex-shrink: 0;
        }
    `;
    document.head.appendChild(__tmStyleEl);

    // 本地存储（用于快速读取和云端同步失败时的备用）
    // 主存储使用云端文件（/data/storage/ 目录）
    const Storage = {
        get(key, defaultValue) {
            try {
                const value = localStorage.getItem(key);
                return value !== null ? JSON.parse(value) : defaultValue;
            } catch (e) {
                return defaultValue;
            }
        },
        set(key, value) {
            try {
                localStorage.setItem(key, JSON.stringify(value));
            } catch (e) {
            }
        },
        remove(key) {
            try {
                localStorage.removeItem(key);
            } catch (e) {}
        },
        clear() {
            try {
                localStorage.clear();
            } catch (e) {}
        }
    };

    const PLUGIN_STORAGE_DIR = '/data/storage/petal/siyuan-plugin-task-horizon';
    const META_FILE_PATH = `${PLUGIN_STORAGE_DIR}/task-meta.json`;
    const SETTINGS_FILE_PATH = `${PLUGIN_STORAGE_DIR}/task-settings.json`;
    const WHITEBOARD_DATA_FILE_PATH = `${PLUGIN_STORAGE_DIR}/whiteboard-data.json`;
    const WHITEBOARD_DATA_CACHE_KEY = 'tm_whiteboard_data_cache';

    const MetaStore = {
        data: Storage.get('tm_meta_cache', {}) || {},
        loaded: false,
        saving: false,
        saveTimer: null,

        async load() {
            if (this.loaded) return;

            // 从云端加载元数据（优先）
            try {
                const res = await fetch('/api/file/getFile', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: META_FILE_PATH }),
                });

                if (res.ok) {
                    const text = await res.text();
                    // 如果文件内容有效
                    if (text && text.trim() !== '') {
                        try {
                            const json = JSON.parse(text);
                            if (json && typeof json === 'object' && Object.keys(json).length > 0) {
                                this.data = json;
                                Storage.set('tm_meta_cache', this.data);
                                this.loaded = true;
                                return;
                            }
                        } catch (parseError) {
                        }
                    }
                }
            } catch (e) {
            }

            // 云端没有数据，使用本地缓存（已在初始化时加载）
            this.loaded = true;
        },

        get(id) {
            if (!id) return null;
            const v = this.data?.[id];
            return v && typeof v === 'object' ? v : null;
        },

        applyToTask(task) {
            const v = this.get(task?.id);
            if (!v) return;
            // 优先使用 MetaStore 的值（非空字符串、非 'null'、非 undefined）
            // 排除 'null' 字符串（SQL 查询返回的 null 会被转成字符串 'null'）
            const isValidValue = (val) => val !== undefined && val !== null && val !== '' && val !== 'null';

            if ('priority' in v && isValidValue(v.priority)) task.priority = v.priority;
            if ('pinned' in v && isValidValue(v.pinned)) task.pinned = v.pinned;
            if ('milestone' in v && isValidValue(v.milestone)) task.milestone = v.milestone;
            if ('duration' in v && isValidValue(v.duration)) task.duration = v.duration;
            if ('remark' in v && isValidValue(v.remark)) task.remark = v.remark;
            if ('completionTime' in v && isValidValue(v.completionTime)) task.completionTime = v.completionTime;
            if ('customTime' in v && isValidValue(v.customTime)) task.customTime = v.customTime;
            if ('customStatus' in v && isValidValue(v.customStatus)) task.customStatus = v.customStatus;
        },

        mergeFromTaskIfMissing(task) {
            if (!task?.id) return;
            const existing = this.get(task.id);
            if (existing) return;
            const candidate = {};
            if (task.priority) candidate.priority = task.priority;
            if (task.pinned !== undefined) candidate.pinned = task.pinned;
            if (task.milestone !== undefined) candidate.milestone = task.milestone;
            if (task.duration) candidate.duration = task.duration;
            if (task.remark) candidate.remark = task.remark;
            if (task.completionTime) candidate.completionTime = task.completionTime;
            if (task.customTime) candidate.customTime = task.customTime;
            if (task.customStatus) candidate.customStatus = task.customStatus;
            if (Object.keys(candidate).length === 0) return;
            this.data[task.id] = candidate;
            this.scheduleSave();
        },

        set(id, patch) {
            if (!id) return;
            if (!this.data || typeof this.data !== 'object') this.data = {};
            const prev = (this.data[id] && typeof this.data[id] === 'object') ? this.data[id] : {};
            this.data[id] = { ...prev, ...(patch || {}) };
            this.scheduleSave();
        },

        remapId(oldId, newId) {
            if (!oldId || !newId || oldId === newId) return;
            if (!this.data || typeof this.data !== 'object') this.data = {};
            if (this.data[oldId] && !this.data[newId]) {
                this.data[newId] = this.data[oldId];
            }
            if (this.data[oldId]) delete this.data[oldId];
            this.scheduleSave();
        },

        scheduleSave() {
            try {
                if (this.saveTimer) clearTimeout(this.saveTimer);
            } catch (e) {}
            this.saveTimer = setTimeout(() => {
                this.saveTimer = null;
                this.saveNow();
            }, 500);
        },

        async saveNow() {
            if (this.saving) return;
            this.saving = true;
            try {
                Storage.set('tm_meta_cache', this.data || {});
                const formDir = new FormData();
                formDir.append('path', PLUGIN_STORAGE_DIR);
                formDir.append('isDir', 'true');
                await fetch('/api/file/putFile', { method: 'POST', body: formDir }).catch(() => null);

                const form = new FormData();
                form.append('path', META_FILE_PATH);
                form.append('isDir', 'false');
                form.append('file', new Blob([JSON.stringify(this.data || {}, null, 2)], { type: 'application/json' }));
                await fetch('/api/file/putFile', { method: 'POST', body: form });
            } catch (e) {} finally {
                this.saving = false;
            }
        }
    };

    // 设置存储（使用云端同步存储，支持跨设备同步）
    const SettingsStore = {
        data: {
            selectedDocIds: [],
            queryLimit: 500,
            groupByDocName: true,
            groupByTime: false,
            defaultViewMode: 'list',
            kanbanCompactMode: false,
            kanbanColumnWidth: 320,
            kanbanShowDoneColumn: false,
            kanbanDragSyncSubtasks: false,
            docH2SubgroupEnabled: true,
            groupByTaskName: false,
            groupMode: 'doc',
            collapsedTaskIds: [],
            kanbanCollapsedTaskIds: [],
            currentRule: null,
            filterRules: [],
            fontSize: 14,
            fontSizeMobile: 14,
            rowHeightMode: 'normal',
            rowHeightPx: 0,
            enableQuickbar: true,
            pinNewTasksByDefault: false,
            newTaskDocId: '',
            enableTomatoIntegration: true,
            tomatoSpentAttrMode: 'minutes',
            tomatoSpentAttrKeyMinutes: 'custom-tomato-minutes',
            tomatoSpentAttrKeyHours: 'custom-tomato-time',
            calendarEnabled: true,
            calendarLinkDockTomato: true,
            calendarInitialView: 'timeGridWeek',
            calendarFirstDay: 1,
            calendarMonthAggregate: true,
            calendarShowSchedule: true,
            calendarShowFocus: true,
            calendarShowBreak: true,
            calendarShowStopwatch: true,
            calendarShowIdle: false,
            calendarColorFocus: '#1a73e8',
            calendarColorBreak: '#34a853',
            calendarColorStopwatch: '#f9ab00',
            calendarColorIdle: '#9aa0a6',
            calendarCalendarsConfig: {},
            calendarDefaultCalendarId: 'default',
            calendarLastViewType: '',
            calendarLastDate: '',
            calendarSidebarWidth: 280,
            calendarColumnWidths: { content: 140, duration: 60, spent: 60 },
            calendarSidebarCollapseCalendars: false,
            calendarSidebarCollapseDocGroups: false,
            calendarSidebarCollapseTomato: false,
            calendarSidebarCollapseTasks: false,
            calendarShowTomatoMaster: true,
            calendarShowTaskDates: true,
            calendarTaskDateColorMode: 'group',
            calendarScheduleColor: '',
            calendarTaskDatesColor: '#6b7280',
            calendarShowCnHoliday: true,
            calendarCnHolidayColor: '#ff3333',
            calendarShowLunar: false,
            calendarSideDockEnabled: false,
            calendarSideDockWidth: 340,
            defaultDocId: '',
            defaultDocIdByGroup: {},
            // 默认状态选项
            customStatusOptions: [
                { id: 'todo', name: '待办', color: '#757575' },
                { id: 'in_progress', name: '进行中', color: '#2196F3' },
                { id: 'done', name: '已完成', color: '#4CAF50' },
                { id: 'blocked', name: '阻塞', color: '#F44336' },
                { id: 'review', name: '待审核', color: '#FF9800' }
            ],
            // 文档分组配置
            // 结构: [{ id: 'uuid', name: '分组名', docs: [{ id: 'docId', recursive: boolean }] }]
            docGroups: [],
            // 文档页签钉住（按分组存储）
            // 结构: { [groupId]: ['docId1', 'docId2'] }
            docPinnedByGroup: {},
            // 当前选中的分组ID (UI显示用)
            currentGroupId: 'all', 
            // 任务标题级别 (h1-h6)
            taskHeadingLevel: 'h2',
            // 时长显示格式: 'hours' 或 'minutes'
            durationFormat: 'hours',
            // 不查找已完成任务（提升性能）
            excludeCompletedTasks: true,
            // 开始日期（新增列）
            startDate: 90,
            // 时间轴模式左侧宽度
            timelineLeftWidth: 540,
            // 时间轴模式任务内容列宽度（不影响表格视图）
            timelineContentWidth: 360,
            timelineForceSortByCompletionNearToday: false,
            // 白板视图
            whiteboardLinks: [],
            whiteboardAutoConnectByCreated: false,
            whiteboardDetachedChildren: {},
            whiteboardNotes: [],
            whiteboardTool: 'pan',
            whiteboardSidebarCollapsed: false,
            whiteboardSidebarWidth: 300,
            whiteboardShowDone: false,
            whiteboardView: { x: 64, y: 40, zoom: 1 },
            whiteboardNodePos: {},
            whiteboardAutoLayout: false,
            whiteboardPlacedTaskIds: {},
            whiteboardDocFrameSize: {},
            whiteboardSequenceMode: false,
            docColorMap: {},
            docColorSeed: 1,
            // 外观配色（支持亮/暗）
            topbarGradientLightStart: '#667eea',
            topbarGradientLightEnd: '#764ba2',
            topbarGradientDarkStart: '#3b49b7',
            topbarGradientDarkEnd: '#5b2d7a',
            topbarTextColorLight: '#ffffff',
            topbarTextColorDark: '#ffffff',
            taskContentColorLight: '#333333',
            taskContentColorDark: '#e0e0e0',
            groupDocLabelColorLight: '#333333',
            groupDocLabelColorDark: '#e0e0e0',
            timeGroupBaseColorLight: '#1a73e8',
            timeGroupBaseColorDark: '#6ba5ff',
            timeGroupOverdueColorLight: '#d93025',
            timeGroupOverdueColorDark: '#ff6b6b',
            progressBarColorLight: '#4caf50',
            progressBarColorDark: '#81c784',
            tableBorderColorLight: '#e9ecef',
            tableBorderColorDark: '#333333',
            enableGroupTaskBgByGroupColor: true,
            priorityScoreConfig: {
                base: 100,
                weights: { importance: 1, status: 1, due: 1, duration: 1, doc: 1 },
                importanceDelta: { high: 20, medium: 10, low: -5, none: 0 },
                statusDelta: { todo: 0, in_progress: 15, done: -80, blocked: -10, review: 5 },
                dueRanges: [
                    { days: 0, delta: 20 },
                    { days: 1, delta: 15 },
                    { days: 3, delta: 10 },
                    { days: 7, delta: 5 },
                    { days: 30, delta: 0 }
                ],
                durationBuckets: [
                    { maxMinutes: 15, delta: 10 },
                    { maxMinutes: 60, delta: 0 },
                    { maxMinutes: 240, delta: -5 },
                    { maxMinutes: 999999, delta: -10 }
                ],
                docDeltas: {}
            },
            // 四象限分组配置
            quadrantConfig: {
                enabled: false,
                rules: [
                    {
                        id: 'urgent-important',
                        name: '重要紧急',
                        color: 'red',
                        importance: ['high', 'medium'],
                        timeRanges: ['overdue', 'within7days']
                    },
                    {
                        id: 'not-urgent-important',
                        name: '重要不紧急',
                        color: 'yellow',
                        importance: ['high', 'medium'],
                        timeRanges: ['beyond7days', 'nodate']
                    },
                    {
                        id: 'urgent-not-important',
                        name: '不重要紧急',
                        color: 'blue',
                        importance: ['low', 'none'],
                        timeRanges: ['overdue', 'within7days']
                    },
                    {
                        id: 'not-urgent-not-important',
                        name: '不重要不紧急',
                        color: 'green',
                        importance: ['low', 'none'],
                        timeRanges: ['beyond7days', 'nodate']
                    }
                ]
            },
            // 列宽度设置（像素）
            columnWidths: {
                pinned: 48,             // 置顶
                content: 360,           // 任务内容
                status: 96,             // 状态
                score: 96,              // 优先级
                doc: 180,               // 文档
                h2: 180,                // 二级标题
                priority: 96,           // 重要性
                completionTime: 170,    // 完成日期
                startDate: 90,           // 开始日期
                duration: 96,           // 时长
                spent: 96,              // 耗时
                remark: 240             // 备注
            },
            // 列顺序设置（注意：startDate 在 completionTime 前面）
            columnOrder: ['pinned', 'content', 'status', 'score', 'doc', 'h2', 'priority', 'startDate', 'completionTime', 'duration', 'spent', 'remark']
        },
        loaded: false,
        saving: false,
        saveTimer: null,
        saveDirty: false,
        savePromise: null,
        savePromiseResolve: null,

        async load() {
            if (this.loaded) return;

            // 先从本地缓存加载一份作为兜底（避免云端旧版本配置缺字段导致覆盖丢失）
            // 云端数据存在时，再用云端字段覆盖本地字段
            try { this.loadFromLocal(); } catch (e) {}

            // 从云端加载设置（优先）
            try {
                const res = await fetch('/api/file/getFile', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: SETTINGS_FILE_PATH }),
                });

                if (res.ok) {
                    const text = await res.text();
                    // 如果文件内容有效且有数据
                    if (text && text.trim() !== '') {
                        try {
                            const cloudData = JSON.parse(text);
                            if (cloudData && typeof cloudData === 'object' && Object.keys(cloudData).length > 0) {
                                // 应用云端数据
                                if (Array.isArray(cloudData.selectedDocIds)) this.data.selectedDocIds = cloudData.selectedDocIds;
                                if (typeof cloudData.queryLimit === 'number') this.data.queryLimit = cloudData.queryLimit;
                                if (typeof cloudData.groupByDocName === 'boolean') this.data.groupByDocName = cloudData.groupByDocName;
                                if (typeof cloudData.groupByTime === 'boolean') this.data.groupByTime = cloudData.groupByTime;
                                if (typeof cloudData.defaultViewMode === 'string') this.data.defaultViewMode = cloudData.defaultViewMode;
                                if (typeof cloudData.kanbanCompactMode === 'boolean') this.data.kanbanCompactMode = cloudData.kanbanCompactMode;
                                if (typeof cloudData.kanbanColumnWidth === 'number') this.data.kanbanColumnWidth = cloudData.kanbanColumnWidth;
                                if (typeof cloudData.kanbanShowDoneColumn === 'boolean') this.data.kanbanShowDoneColumn = cloudData.kanbanShowDoneColumn;
                                if (typeof cloudData.kanbanDragSyncSubtasks === 'boolean') this.data.kanbanDragSyncSubtasks = cloudData.kanbanDragSyncSubtasks;
                                if (typeof cloudData.docH2SubgroupEnabled === 'boolean') this.data.docH2SubgroupEnabled = cloudData.docH2SubgroupEnabled;
                                if (typeof cloudData.groupByTaskName === 'boolean') this.data.groupByTaskName = cloudData.groupByTaskName;
                                if (typeof cloudData.groupMode === 'string') this.data.groupMode = cloudData.groupMode;
                                if (Array.isArray(cloudData.collapsedTaskIds)) this.data.collapsedTaskIds = cloudData.collapsedTaskIds;
                                if (Array.isArray(cloudData.kanbanCollapsedTaskIds)) this.data.kanbanCollapsedTaskIds = cloudData.kanbanCollapsedTaskIds;
                                if (Array.isArray(cloudData.collapsedGroups)) this.data.collapsedGroups = cloudData.collapsedGroups;
                                if (cloudData.currentRule !== undefined) this.data.currentRule = cloudData.currentRule;
                                if (Array.isArray(cloudData.filterRules)) this.data.filterRules = cloudData.filterRules;
                                if (typeof cloudData.fontSize === 'number') this.data.fontSize = cloudData.fontSize;
                                if (typeof cloudData.fontSizeMobile === 'number') this.data.fontSizeMobile = cloudData.fontSizeMobile;
                                if (typeof cloudData.rowHeightMode === 'string') this.data.rowHeightMode = cloudData.rowHeightMode;
                                if (typeof cloudData.rowHeightPx === 'number') this.data.rowHeightPx = cloudData.rowHeightPx;
                                if (typeof cloudData.enableQuickbar === 'boolean') this.data.enableQuickbar = cloudData.enableQuickbar;
                                if (typeof cloudData.pinNewTasksByDefault === 'boolean') this.data.pinNewTasksByDefault = cloudData.pinNewTasksByDefault;
                                if (typeof cloudData.newTaskDocId === 'string') this.data.newTaskDocId = cloudData.newTaskDocId;
                                if (typeof cloudData.enableTomatoIntegration === 'boolean') this.data.enableTomatoIntegration = cloudData.enableTomatoIntegration;
                                if (typeof cloudData.tomatoSpentAttrMode === 'string') this.data.tomatoSpentAttrMode = cloudData.tomatoSpentAttrMode;
                                if (typeof cloudData.tomatoSpentAttrKeyMinutes === 'string') this.data.tomatoSpentAttrKeyMinutes = cloudData.tomatoSpentAttrKeyMinutes;
                                if (typeof cloudData.tomatoSpentAttrKeyHours === 'string') this.data.tomatoSpentAttrKeyHours = cloudData.tomatoSpentAttrKeyHours;
                                if (typeof cloudData.calendarEnabled === 'boolean') this.data.calendarEnabled = cloudData.calendarEnabled;
                                if (typeof cloudData.calendarLinkDockTomato === 'boolean') this.data.calendarLinkDockTomato = cloudData.calendarLinkDockTomato;
                                if (typeof cloudData.calendarInitialView === 'string') this.data.calendarInitialView = cloudData.calendarInitialView;
                                if (typeof cloudData.calendarFirstDay === 'number') this.data.calendarFirstDay = cloudData.calendarFirstDay;
                                if (typeof cloudData.calendarMonthAggregate === 'boolean') this.data.calendarMonthAggregate = cloudData.calendarMonthAggregate;
                                if (typeof cloudData.calendarShowSchedule === 'boolean') this.data.calendarShowSchedule = cloudData.calendarShowSchedule;
                                if (typeof cloudData.calendarShowTomatoMaster === 'boolean') this.data.calendarShowTomatoMaster = cloudData.calendarShowTomatoMaster;
                                if (typeof cloudData.calendarShowFocus === 'boolean') this.data.calendarShowFocus = cloudData.calendarShowFocus;
                                if (typeof cloudData.calendarShowBreak === 'boolean') this.data.calendarShowBreak = cloudData.calendarShowBreak;
                                if (typeof cloudData.calendarShowStopwatch === 'boolean') this.data.calendarShowStopwatch = cloudData.calendarShowStopwatch;
                                if (typeof cloudData.calendarShowIdle === 'boolean') this.data.calendarShowIdle = cloudData.calendarShowIdle;
                                if (typeof cloudData.calendarColorFocus === 'string') this.data.calendarColorFocus = cloudData.calendarColorFocus;
                                if (typeof cloudData.calendarColorBreak === 'string') this.data.calendarColorBreak = cloudData.calendarColorBreak;
                                if (typeof cloudData.calendarColorStopwatch === 'string') this.data.calendarColorStopwatch = cloudData.calendarColorStopwatch;
                                if (typeof cloudData.calendarColorIdle === 'string') this.data.calendarColorIdle = cloudData.calendarColorIdle;
                                if (typeof cloudData.calendarSidebarWidth === 'number') this.data.calendarSidebarWidth = cloudData.calendarSidebarWidth;
                                if (cloudData.calendarColumnWidths && typeof cloudData.calendarColumnWidths === 'object') this.data.calendarColumnWidths = cloudData.calendarColumnWidths;
                                if (typeof cloudData.calendarLastViewType === 'string') this.data.calendarLastViewType = cloudData.calendarLastViewType;
                                if (typeof cloudData.calendarLastDate === 'string') this.data.calendarLastDate = cloudData.calendarLastDate;
                                if (cloudData.calendarCalendarsConfig && typeof cloudData.calendarCalendarsConfig === 'object') this.data.calendarCalendarsConfig = cloudData.calendarCalendarsConfig;
                                if (typeof cloudData.calendarDefaultCalendarId === 'string') this.data.calendarDefaultCalendarId = cloudData.calendarDefaultCalendarId;
                                if (typeof cloudData.calendarSidebarCollapseCalendars === 'boolean') this.data.calendarSidebarCollapseCalendars = cloudData.calendarSidebarCollapseCalendars;
                                if (typeof cloudData.calendarSidebarCollapseDocGroups === 'boolean') this.data.calendarSidebarCollapseDocGroups = cloudData.calendarSidebarCollapseDocGroups;
                                if (typeof cloudData.calendarSidebarCollapseTomato === 'boolean') this.data.calendarSidebarCollapseTomato = cloudData.calendarSidebarCollapseTomato;
                                if (typeof cloudData.calendarSidebarCollapseTasks === 'boolean') this.data.calendarSidebarCollapseTasks = cloudData.calendarSidebarCollapseTasks;
                                if (typeof cloudData.calendarShowTaskDates === 'boolean') this.data.calendarShowTaskDates = cloudData.calendarShowTaskDates;
                                if (typeof cloudData.calendarTaskDateColorMode === 'string') this.data.calendarTaskDateColorMode = cloudData.calendarTaskDateColorMode;
                                if (typeof cloudData.calendarScheduleColor === 'string') this.data.calendarScheduleColor = cloudData.calendarScheduleColor;
                                if (typeof cloudData.calendarTaskDatesColor === 'string') this.data.calendarTaskDatesColor = cloudData.calendarTaskDatesColor;
                                if (typeof cloudData.calendarShowCnHoliday === 'boolean') this.data.calendarShowCnHoliday = cloudData.calendarShowCnHoliday;
                                if (typeof cloudData.calendarCnHolidayColor === 'string') this.data.calendarCnHolidayColor = cloudData.calendarCnHolidayColor;
                                if (typeof cloudData.calendarShowLunar === 'boolean') this.data.calendarShowLunar = cloudData.calendarShowLunar;
                                if (typeof cloudData.calendarSideDockEnabled === 'boolean') this.data.calendarSideDockEnabled = cloudData.calendarSideDockEnabled;
                                if (typeof cloudData.calendarSideDockWidth === 'number') this.data.calendarSideDockWidth = cloudData.calendarSideDockWidth;
                                if (typeof cloudData.defaultDocId === 'string') this.data.defaultDocId = cloudData.defaultDocId;
                                if (cloudData.defaultDocIdByGroup && typeof cloudData.defaultDocIdByGroup === 'object') this.data.defaultDocIdByGroup = cloudData.defaultDocIdByGroup;
                                if (cloudData.priorityScoreConfig && typeof cloudData.priorityScoreConfig === 'object') this.data.priorityScoreConfig = cloudData.priorityScoreConfig;
                                if (cloudData.quadrantConfig && typeof cloudData.quadrantConfig === 'object') this.data.quadrantConfig = cloudData.quadrantConfig;
                                if (Array.isArray(cloudData.docGroups)) this.data.docGroups = cloudData.docGroups;
                                if (cloudData.docPinnedByGroup && typeof cloudData.docPinnedByGroup === 'object') this.data.docPinnedByGroup = cloudData.docPinnedByGroup;
                                if (cloudData.currentGroupId) this.data.currentGroupId = cloudData.currentGroupId;
                                if (cloudData.taskHeadingLevel) this.data.taskHeadingLevel = cloudData.taskHeadingLevel;
                                if (typeof cloudData.topbarGradientLightStart === 'string') this.data.topbarGradientLightStart = cloudData.topbarGradientLightStart;
                                if (typeof cloudData.topbarGradientLightEnd === 'string') this.data.topbarGradientLightEnd = cloudData.topbarGradientLightEnd;
                                if (typeof cloudData.topbarGradientDarkStart === 'string') this.data.topbarGradientDarkStart = cloudData.topbarGradientDarkStart;
                                if (typeof cloudData.topbarGradientDarkEnd === 'string') this.data.topbarGradientDarkEnd = cloudData.topbarGradientDarkEnd;
                                if (typeof cloudData.topbarTextColorLight === 'string') this.data.topbarTextColorLight = cloudData.topbarTextColorLight;
                                if (typeof cloudData.topbarTextColorDark === 'string') this.data.topbarTextColorDark = cloudData.topbarTextColorDark;
                                if (typeof cloudData.taskContentColorLight === 'string') this.data.taskContentColorLight = cloudData.taskContentColorLight;
                                if (typeof cloudData.taskContentColorDark === 'string') this.data.taskContentColorDark = cloudData.taskContentColorDark;
                                if (typeof cloudData.groupDocLabelColorLight === 'string') this.data.groupDocLabelColorLight = cloudData.groupDocLabelColorLight;
                                if (typeof cloudData.groupDocLabelColorDark === 'string') this.data.groupDocLabelColorDark = cloudData.groupDocLabelColorDark;
                                if (typeof cloudData.timeGroupBaseColorLight === 'string') this.data.timeGroupBaseColorLight = cloudData.timeGroupBaseColorLight;
                                if (typeof cloudData.timeGroupBaseColorDark === 'string') this.data.timeGroupBaseColorDark = cloudData.timeGroupBaseColorDark;
                                if (typeof cloudData.timeGroupOverdueColorLight === 'string') this.data.timeGroupOverdueColorLight = cloudData.timeGroupOverdueColorLight;
                                if (typeof cloudData.timeGroupOverdueColorDark === 'string') this.data.timeGroupOverdueColorDark = cloudData.timeGroupOverdueColorDark;
                                if (typeof cloudData.progressBarColorLight === 'string') this.data.progressBarColorLight = cloudData.progressBarColorLight;
                                if (typeof cloudData.progressBarColorDark === 'string') this.data.progressBarColorDark = cloudData.progressBarColorDark;
                                if (typeof cloudData.tableBorderColorLight === 'string') this.data.tableBorderColorLight = cloudData.tableBorderColorLight;
                                if (typeof cloudData.tableBorderColorDark === 'string') this.data.tableBorderColorDark = cloudData.tableBorderColorDark;
                                if (Array.isArray(cloudData.customStatusOptions)) this.data.customStatusOptions = cloudData.customStatusOptions;
                                if (cloudData.columnWidths && typeof cloudData.columnWidths === 'object') {
                                    // 旧版本兼容：如果有 customTime 配置，迁移到 completionTime
                                    if (cloudData.columnWidths.customTime && !cloudData.columnWidths.completionTime) {
                                        cloudData.columnWidths.completionTime = cloudData.columnWidths.customTime;
                                    }
                                    this.data.columnWidths = { ...this.data.columnWidths, ...cloudData.columnWidths };
                                }
                                if (Array.isArray(cloudData.columnOrder)) this.data.columnOrder = cloudData.columnOrder;
                                
                                // 新增字段处理
                                if (typeof cloudData.durationFormat === 'string') this.data.durationFormat = cloudData.durationFormat;
                                if (typeof cloudData.excludeCompletedTasks === 'boolean') this.data.excludeCompletedTasks = cloudData.excludeCompletedTasks;
                                if (typeof cloudData.startDate === 'number') this.data.startDate = cloudData.startDate;
                                if (typeof cloudData.timelineLeftWidth === 'number') this.data.timelineLeftWidth = cloudData.timelineLeftWidth;
                                if (typeof cloudData.timelineContentWidth === 'number') this.data.timelineContentWidth = cloudData.timelineContentWidth;
                                if (typeof cloudData.timelineForceSortByCompletionNearToday === 'boolean') this.data.timelineForceSortByCompletionNearToday = cloudData.timelineForceSortByCompletionNearToday;
                                if (Array.isArray(cloudData.whiteboardLinks)) this.data.whiteboardLinks = cloudData.whiteboardLinks;
                                if (typeof cloudData.whiteboardAutoConnectByCreated === 'boolean') this.data.whiteboardAutoConnectByCreated = cloudData.whiteboardAutoConnectByCreated;
                                if (cloudData.whiteboardDetachedChildren && typeof cloudData.whiteboardDetachedChildren === 'object') this.data.whiteboardDetachedChildren = cloudData.whiteboardDetachedChildren;
                                if (Array.isArray(cloudData.whiteboardNotes)) this.data.whiteboardNotes = cloudData.whiteboardNotes;
                                if (typeof cloudData.whiteboardTool === 'string') this.data.whiteboardTool = cloudData.whiteboardTool;
                                if (typeof cloudData.whiteboardSidebarCollapsed === 'boolean') this.data.whiteboardSidebarCollapsed = cloudData.whiteboardSidebarCollapsed;
                                if (typeof cloudData.whiteboardSidebarWidth === 'number') this.data.whiteboardSidebarWidth = cloudData.whiteboardSidebarWidth;
                                if (typeof cloudData.whiteboardShowDone === 'boolean') this.data.whiteboardShowDone = cloudData.whiteboardShowDone;
                                if (cloudData.whiteboardView && typeof cloudData.whiteboardView === 'object') this.data.whiteboardView = cloudData.whiteboardView;
                                if (cloudData.whiteboardNodePos && typeof cloudData.whiteboardNodePos === 'object') this.data.whiteboardNodePos = cloudData.whiteboardNodePos;
                                if (typeof cloudData.whiteboardAutoLayout === 'boolean') this.data.whiteboardAutoLayout = cloudData.whiteboardAutoLayout;
                                if (cloudData.whiteboardPlacedTaskIds && typeof cloudData.whiteboardPlacedTaskIds === 'object') this.data.whiteboardPlacedTaskIds = cloudData.whiteboardPlacedTaskIds;
                                if (cloudData.whiteboardDocFrameSize && typeof cloudData.whiteboardDocFrameSize === 'object') this.data.whiteboardDocFrameSize = cloudData.whiteboardDocFrameSize;
                                if (typeof cloudData.whiteboardSequenceMode === 'boolean') this.data.whiteboardSequenceMode = cloudData.whiteboardSequenceMode;
                                if (cloudData.docColorMap && typeof cloudData.docColorMap === 'object') this.data.docColorMap = cloudData.docColorMap;
                                if (typeof cloudData.docColorSeed === 'number') this.data.docColorSeed = cloudData.docColorSeed;

                                const validModes = new Set(['none', 'doc', 'time', 'quadrant', 'task']);
                                if (!validModes.has(String(this.data.groupMode || ''))) {
                                    // groupMode 无效时，根据标志位推导模式
                                    const q = !!(this.data.quadrantConfig && this.data.quadrantConfig.enabled);
                                    this.data.groupMode = q ? 'quadrant' : (this.data.groupByTime ? 'time' : (this.data.groupByDocName ? 'doc' : (this.data.groupByTaskName ? 'task' : 'none')));
                                }
                                // 根据 groupMode 设置标志位，但 groupByTaskName 只在 groupMode === 'task' 时才设置为 true
                                // 这样切换到其他模式后，groupByTaskName 的值会被保留，设置开关就不会被关闭
                                // 但需要在 groupMode === 'none' 时额外检查 groupByTaskName 是否为 true，如果是则设置为 'task'
                                if (this.data.groupMode === 'doc') {
                                    this.data.groupByDocName = true;
                                    this.data.groupByTime = false;
                                    this.data.quadrantConfig = this.data.quadrantConfig || {};
                                    this.data.quadrantConfig.enabled = false;
                                } else if (this.data.groupMode === 'time') {
                                    this.data.groupByDocName = false;
                                    this.data.groupByTime = true;
                                    this.data.quadrantConfig = this.data.quadrantConfig || {};
                                    this.data.quadrantConfig.enabled = false;
                                } else if (this.data.groupMode === 'task') {
                                    this.data.groupByDocName = false;
                                    this.data.groupByTaskName = true;
                                    this.data.groupByTime = false;
                                    this.data.quadrantConfig = this.data.quadrantConfig || {};
                                    this.data.quadrantConfig.enabled = false;
                                } else if (this.data.groupMode === 'quadrant') {
                                    this.data.groupByDocName = false;
                                    this.data.groupByTime = false;
                                    this.data.quadrantConfig = this.data.quadrantConfig || {};
                                    this.data.quadrantConfig.enabled = true;
                                } else {
                                    this.data.groupByDocName = false;
                                    this.data.groupByTime = false;
                                    this.data.quadrantConfig = this.data.quadrantConfig || {};
                                    this.data.quadrantConfig.enabled = false;
                                    // 当 groupMode 为 'none' 时，保持 groupMode 不变
                                    // 这样可以保留用户上次选择的分组模式（即使设置开关开启）
                                    // 只有当 groupMode 无效时才设置为 'none'
                                    if (!this.data.groupMode || this.data.groupMode === 'none') {
                                        this.data.groupMode = 'none';
                                    }
                                    // 注意：这里不再强制将 groupMode 设置为 'task'
                                    // 因为用户可能选择了"不分组"或其他分组模式
                                }

                                // 同步到本地缓存
                                this.normalizeColumns();
                                this.syncToLocal();
                                this.loaded = true;
                                return;
                            }
                        } catch (parseError) {
                        }
                    }
                }
            } catch (e) {
            }
            this.loaded = true;
        },

        // 从本地缓存加载
        loadFromLocal() {
            this.data.selectedDocIds = Storage.get('tm_selected_doc_ids', []) || [];
            this.data.queryLimit = Storage.get('tm_query_limit', 500);
            this.data.groupByDocName = Storage.get('tm_group_by_docname', true);
            this.data.groupByTime = Storage.get('tm_group_by_time', false);
            this.data.defaultViewMode = Storage.get('tm_default_view_mode', this.data.defaultViewMode);
            this.data.kanbanCompactMode = !!Storage.get('tm_kanban_compact_mode', this.data.kanbanCompactMode);
            this.data.kanbanColumnWidth = Storage.get('tm_kanban_column_width', this.data.kanbanColumnWidth);
            this.data.kanbanShowDoneColumn = !!Storage.get('tm_kanban_show_done_column', this.data.kanbanShowDoneColumn);
            this.data.kanbanDragSyncSubtasks = !!Storage.get('tm_kanban_drag_sync_subtasks', this.data.kanbanDragSyncSubtasks);
            this.data.docH2SubgroupEnabled = !!Storage.get('tm_doc_h2_subgroup_enabled', this.data.docH2SubgroupEnabled);
            this.data.groupByTaskName = !!Storage.get('tm_group_by_taskname', this.data.groupByTaskName);
            this.data.groupMode = Storage.get('tm_group_mode', this.data.groupMode);
            this.data.collapsedTaskIds = Storage.get('tm_collapsed_task_ids', []) || [];
            this.data.kanbanCollapsedTaskIds = Storage.get('tm_kanban_collapsed_task_ids', []) || [];
            this.data.collapsedGroups = Storage.get('tm_collapsed_groups', []) || [];
            this.data.currentRule = Storage.get('tm_current_rule', null);
            this.data.filterRules = Storage.get('tm_filter_rules', []);
            this.data.fontSize = Storage.get('tm_font_size', 14);
            this.data.fontSizeMobile = Storage.get('tm_font_size_mobile', this.data.fontSize);
            this.data.rowHeightMode = Storage.get('tm_row_height_mode', this.data.rowHeightMode);
            this.data.rowHeightPx = Storage.get('tm_row_height_px', this.data.rowHeightPx);
            this.data.topbarGradientLightStart = Storage.get('tm_topbar_gradient_light_start', this.data.topbarGradientLightStart);
            this.data.topbarGradientLightEnd = Storage.get('tm_topbar_gradient_light_end', this.data.topbarGradientLightEnd);
            this.data.topbarGradientDarkStart = Storage.get('tm_topbar_gradient_dark_start', this.data.topbarGradientDarkStart);
            this.data.topbarGradientDarkEnd = Storage.get('tm_topbar_gradient_dark_end', this.data.topbarGradientDarkEnd);
            this.data.topbarTextColorLight = Storage.get('tm_topbar_text_color_light', this.data.topbarTextColorLight);
            this.data.topbarTextColorDark = Storage.get('tm_topbar_text_color_dark', this.data.topbarTextColorDark);
            this.data.taskContentColorLight = Storage.get('tm_task_content_color_light', this.data.taskContentColorLight);
            this.data.taskContentColorDark = Storage.get('tm_task_content_color_dark', this.data.taskContentColorDark);
            this.data.groupDocLabelColorLight = Storage.get('tm_group_doc_label_color_light', this.data.groupDocLabelColorLight);
            this.data.groupDocLabelColorDark = Storage.get('tm_group_doc_label_color_dark', this.data.groupDocLabelColorDark);
            this.data.timeGroupBaseColorLight = Storage.get('tm_time_group_base_color_light', this.data.timeGroupBaseColorLight);
            this.data.timeGroupBaseColorDark = Storage.get('tm_time_group_base_color_dark', this.data.timeGroupBaseColorDark);
            this.data.timeGroupOverdueColorLight = Storage.get('tm_time_group_overdue_color_light', this.data.timeGroupOverdueColorLight);
            this.data.timeGroupOverdueColorDark = Storage.get('tm_time_group_overdue_color_dark', this.data.timeGroupOverdueColorDark);
            this.data.progressBarColorLight = Storage.get('tm_progress_bar_color_light', this.data.progressBarColorLight);
            this.data.progressBarColorDark = Storage.get('tm_progress_bar_color_dark', this.data.progressBarColorDark);
            this.data.tableBorderColorLight = Storage.get('tm_table_border_color_light', this.data.tableBorderColorLight);
            this.data.tableBorderColorDark = Storage.get('tm_table_border_color_dark', this.data.tableBorderColorDark);
            this.data.enableQuickbar = Storage.get('tm_enable_quickbar', true);
            this.data.pinNewTasksByDefault = Storage.get('tm_pin_new_tasks_by_default', false);
            this.data.newTaskDocId = Storage.get('tm_new_task_doc_id', '');
            this.data.enableTomatoIntegration = Storage.get('tm_enable_tomato_integration', true);
            this.data.tomatoSpentAttrMode = Storage.get('tm_tomato_spent_attr_mode', 'minutes');
            this.data.tomatoSpentAttrKeyMinutes = Storage.get('tm_tomato_spent_attr_key_minutes', this.data.tomatoSpentAttrKeyMinutes);
            this.data.tomatoSpentAttrKeyHours = Storage.get('tm_tomato_spent_attr_key_hours', this.data.tomatoSpentAttrKeyHours);
            this.data.calendarEnabled = Storage.get('tm_calendar_enabled', this.data.calendarEnabled);
            this.data.calendarLinkDockTomato = Storage.get('tm_calendar_link_docktomato', this.data.calendarLinkDockTomato);
            this.data.calendarInitialView = Storage.get('tm_calendar_initial_view', this.data.calendarInitialView);
            this.data.calendarFirstDay = Number(Storage.get('tm_calendar_first_day', this.data.calendarFirstDay));
            this.data.calendarMonthAggregate = Storage.get('tm_calendar_month_aggregate', this.data.calendarMonthAggregate);
            this.data.calendarShowSchedule = Storage.get('tm_calendar_show_schedule', this.data.calendarShowSchedule);
            this.data.calendarShowTomatoMaster = Storage.get('tm_calendar_show_tomato_master', this.data.calendarShowTomatoMaster);
            this.data.calendarShowFocus = Storage.get('tm_calendar_show_focus', this.data.calendarShowFocus);
            this.data.calendarShowBreak = Storage.get('tm_calendar_show_break', this.data.calendarShowBreak);
            this.data.calendarShowStopwatch = Storage.get('tm_calendar_show_stopwatch', this.data.calendarShowStopwatch);
            this.data.calendarShowIdle = Storage.get('tm_calendar_show_idle', this.data.calendarShowIdle);
            this.data.calendarShowTaskDates = Storage.get('tm_calendar_show_task_dates', this.data.calendarShowTaskDates);
            this.data.calendarTaskDateColorMode = Storage.get('tm_calendar_task_date_color_mode', this.data.calendarTaskDateColorMode);
            this.data.calendarScheduleColor = Storage.get('tm_calendar_schedule_color', this.data.calendarScheduleColor);
            this.data.calendarTaskDatesColor = Storage.get('tm_calendar_task_dates_color', this.data.calendarTaskDatesColor);
            this.data.calendarShowCnHoliday = Storage.get('tm_calendar_show_cn_holiday', this.data.calendarShowCnHoliday);
            this.data.calendarCnHolidayColor = Storage.get('tm_calendar_cn_holiday_color', this.data.calendarCnHolidayColor);
            this.data.calendarShowLunar = Storage.get('tm_calendar_show_lunar', this.data.calendarShowLunar);
            this.data.calendarSideDockEnabled = Storage.get('tm_calendar_side_dock_enabled', this.data.calendarSideDockEnabled);
            this.data.calendarSideDockWidth = Storage.get('tm_calendar_side_dock_width', this.data.calendarSideDockWidth);
            this.data.calendarColorFocus = Storage.get('tm_calendar_color_focus', this.data.calendarColorFocus);
            this.data.calendarColorBreak = Storage.get('tm_calendar_color_break', this.data.calendarColorBreak);
            this.data.calendarColorStopwatch = Storage.get('tm_calendar_color_stopwatch', this.data.calendarColorStopwatch);
            this.data.calendarColorIdle = Storage.get('tm_calendar_color_idle', this.data.calendarColorIdle);
            this.data.calendarSidebarWidth = Storage.get('tm_calendar_sidebar_width', this.data.calendarSidebarWidth);
            this.data.calendarColumnWidths = Storage.get('tm_calendar_column_widths', this.data.calendarColumnWidths) || this.data.calendarColumnWidths;
            this.data.calendarLastViewType = Storage.get('tm_calendar_last_view_type', this.data.calendarLastViewType);
            this.data.calendarLastDate = Storage.get('tm_calendar_last_date', this.data.calendarLastDate);
            this.data.calendarCalendarsConfig = Storage.get('tm_calendar_calendars_config', this.data.calendarCalendarsConfig) || this.data.calendarCalendarsConfig;
            this.data.calendarDefaultCalendarId = Storage.get('tm_calendar_default_calendar_id', this.data.calendarDefaultCalendarId);
            this.data.calendarSidebarCollapseCalendars = Storage.get('tm_calendar_sidebar_collapse_calendars', this.data.calendarSidebarCollapseCalendars);
            this.data.calendarSidebarCollapseDocGroups = Storage.get('tm_calendar_sidebar_collapse_doc_groups', this.data.calendarSidebarCollapseDocGroups);
            this.data.calendarSidebarCollapseTomato = Storage.get('tm_calendar_sidebar_collapse_tomato', this.data.calendarSidebarCollapseTomato);
            this.data.calendarSidebarCollapseTasks = Storage.get('tm_calendar_sidebar_collapse_tasks', this.data.calendarSidebarCollapseTasks);
            this.data.defaultDocId = Storage.get('tm_default_doc_id', '');
            this.data.defaultDocIdByGroup = Storage.get('tm_default_doc_id_by_group', {}) || {};
            this.data.priorityScoreConfig = Storage.get('tm_priority_score_config', this.data.priorityScoreConfig) || this.data.priorityScoreConfig;
            this.data.quadrantConfig = Storage.get('tm_quadrant_config', this.data.quadrantConfig);
            this.data.docGroups = Storage.get('tm_doc_groups', []);
            this.data.docPinnedByGroup = Storage.get('tm_doc_pinned_by_group', this.data.docPinnedByGroup) || {};
            this.data.currentGroupId = Storage.get('tm_current_group_id', 'all');
            this.data.customStatusOptions = Storage.get('tm_custom_status_options', this.data.customStatusOptions);
            this.data.columnOrder = Storage.get('tm_column_order', this.data.columnOrder);
            this.data.durationFormat = Storage.get('tm_duration_format', this.data.durationFormat);
            this.data.excludeCompletedTasks = Storage.get('tm_exclude_completed_tasks', this.data.excludeCompletedTasks);
            this.data.startDate = Storage.get('tm_start_date', this.data.startDate);
            this.data.timelineLeftWidth = Storage.get('tm_timeline_left_width', this.data.timelineLeftWidth);
            this.data.timelineContentWidth = Storage.get('tm_timeline_content_width', this.data.timelineContentWidth);
            this.data.timelineForceSortByCompletionNearToday = Storage.get('tm_timeline_force_sort_completion_near_today', this.data.timelineForceSortByCompletionNearToday);
            this.data.whiteboardLinks = Storage.get('tm_whiteboard_links', this.data.whiteboardLinks) || [];
            this.data.whiteboardAutoConnectByCreated = Storage.get('tm_whiteboard_auto_connect_by_created', this.data.whiteboardAutoConnectByCreated);
            this.data.whiteboardDetachedChildren = Storage.get('tm_whiteboard_detached_children', this.data.whiteboardDetachedChildren) || {};
            this.data.whiteboardNotes = Storage.get('tm_whiteboard_notes', this.data.whiteboardNotes) || [];
            this.data.whiteboardTool = Storage.get('tm_whiteboard_tool', this.data.whiteboardTool);
            this.data.whiteboardSidebarCollapsed = Storage.get('tm_whiteboard_sidebar_collapsed', this.data.whiteboardSidebarCollapsed);
            this.data.whiteboardSidebarWidth = Storage.get('tm_whiteboard_sidebar_width', this.data.whiteboardSidebarWidth);
            this.data.whiteboardShowDone = Storage.get('tm_whiteboard_show_done', this.data.whiteboardShowDone);
            this.data.whiteboardView = Storage.get('tm_whiteboard_view', this.data.whiteboardView) || this.data.whiteboardView;
            this.data.whiteboardNodePos = Storage.get('tm_whiteboard_node_pos', this.data.whiteboardNodePos) || {};
            this.data.whiteboardAutoLayout = Storage.get('tm_whiteboard_auto_layout', this.data.whiteboardAutoLayout);
            this.data.whiteboardPlacedTaskIds = Storage.get('tm_whiteboard_placed_task_ids', this.data.whiteboardPlacedTaskIds) || {};
            this.data.whiteboardDocFrameSize = Storage.get('tm_whiteboard_doc_frame_size', this.data.whiteboardDocFrameSize) || {};
            this.data.whiteboardSequenceMode = Storage.get('tm_whiteboard_sequence_mode', this.data.whiteboardSequenceMode);
            this.data.docColorMap = Storage.get('tm_doc_color_map', this.data.docColorMap) || {};
            this.data.docColorSeed = Storage.get('tm_doc_color_seed', this.data.docColorSeed);
            const savedWidths = Storage.get('tm_column_widths', null);
            if (savedWidths && typeof savedWidths === 'object') {
                if (savedWidths.customTime && !savedWidths.completionTime) {
                    savedWidths.completionTime = savedWidths.customTime;
                }
                this.data.columnWidths = { ...this.data.columnWidths, ...savedWidths };
            }
            const validModes = new Set(['none', 'doc', 'time', 'quadrant', 'task']);
            if (!validModes.has(String(this.data.groupMode || ''))) {
                // groupMode 无效时，根据标志位推导模式
                const q = !!(this.data.quadrantConfig && this.data.quadrantConfig.enabled);
                this.data.groupMode = q ? 'quadrant' : (this.data.groupByTime ? 'time' : (this.data.groupByDocName ? 'doc' : (this.data.groupByTaskName ? 'task' : 'none')));
            }
            // 根据 groupMode 设置标志位，但 groupByTaskName 只在 groupMode === 'task' 时才设置为 true
            // 这样切换到其他模式后，groupByTaskName 的值会被保留，设置开关就不会被关闭
            // 但需要在 groupMode === 'none' 时额外检查 groupByTaskName 是否为 true，如果是则设置为 'task'
            if (this.data.groupMode === 'doc') {
                this.data.groupByDocName = true;
                this.data.groupByTime = false;
                this.data.quadrantConfig = this.data.quadrantConfig || {};
                this.data.quadrantConfig.enabled = false;
            } else if (this.data.groupMode === 'time') {
                this.data.groupByDocName = false;
                this.data.groupByTime = true;
                this.data.quadrantConfig = this.data.quadrantConfig || {};
                this.data.quadrantConfig.enabled = false;
            } else if (this.data.groupMode === 'task') {
                this.data.groupByDocName = false;
                this.data.groupByTaskName = true;
                this.data.groupByTime = false;
                this.data.quadrantConfig = this.data.quadrantConfig || {};
                this.data.quadrantConfig.enabled = false;
            } else if (this.data.groupMode === 'quadrant') {
                this.data.groupByDocName = false;
                this.data.groupByTime = false;
                this.data.quadrantConfig = this.data.quadrantConfig || {};
                this.data.quadrantConfig.enabled = true;
            } else {
                this.data.groupByDocName = false;
                this.data.groupByTime = false;
                this.data.quadrantConfig = this.data.quadrantConfig || {};
                this.data.quadrantConfig.enabled = false;
                // 当 groupMode 为 'none' 时，保持 groupMode 不变
                // 这样可以保留用户上次选择的分组模式（即使设置开关开启）
                // 只有当 groupMode 无效时才设置为 'none'
                if (!this.data.groupMode || this.data.groupMode === 'none') {
                    this.data.groupMode = 'none';
                }
                // 注意：这里不再强制将 groupMode 设置为 'task'
                // 因为用户可能选择了"不分组"或其他分组模式
            }
            this.normalizeColumns();
        },

        // 同步到本地缓存
        syncToLocal() {
            Storage.set('tm_selected_doc_ids', this.data.selectedDocIds);
            Storage.set('tm_query_limit', this.data.queryLimit);
            Storage.set('tm_group_by_docname', this.data.groupByDocName);
            Storage.set('tm_group_by_taskname', this.data.groupByTaskName);
            Storage.set('tm_group_by_time', this.data.groupByTime);
            Storage.set('tm_default_view_mode', String(this.data.defaultViewMode || 'list').trim() || 'list');
            Storage.set('tm_kanban_compact_mode', !!this.data.kanbanCompactMode);
            Storage.set('tm_kanban_column_width', Number(this.data.kanbanColumnWidth) || 320);
            Storage.set('tm_kanban_show_done_column', !!this.data.kanbanShowDoneColumn);
            Storage.set('tm_kanban_drag_sync_subtasks', !!this.data.kanbanDragSyncSubtasks);
            Storage.set('tm_doc_h2_subgroup_enabled', !!this.data.docH2SubgroupEnabled);
            Storage.set('tm_group_by_taskname', !!this.data.groupByTaskName);
            Storage.set('tm_group_mode', String(this.data.groupMode || '').trim() || 'none');
            Storage.set('tm_collapsed_task_ids', this.data.collapsedTaskIds);
            Storage.set('tm_kanban_collapsed_task_ids', this.data.kanbanCollapsedTaskIds || []);
            Storage.set('tm_collapsed_groups', this.data.collapsedGroups || []);
            Storage.set('tm_current_rule', this.data.currentRule);
            Storage.set('tm_filter_rules', this.data.filterRules);
            Storage.set('tm_font_size', this.data.fontSize);
            Storage.set('tm_font_size_mobile', this.data.fontSizeMobile);
            Storage.set('tm_row_height_mode', String(this.data.rowHeightMode || 'auto').trim() || 'auto');
            Storage.set('tm_row_height_px', Number(this.data.rowHeightPx) || 0);
            Storage.set('tm_topbar_gradient_light_start', String(this.data.topbarGradientLightStart || '').trim());
            Storage.set('tm_topbar_gradient_light_end', String(this.data.topbarGradientLightEnd || '').trim());
            Storage.set('tm_topbar_gradient_dark_start', String(this.data.topbarGradientDarkStart || '').trim());
            Storage.set('tm_topbar_gradient_dark_end', String(this.data.topbarGradientDarkEnd || '').trim());
            Storage.set('tm_topbar_text_color_light', String(this.data.topbarTextColorLight || '').trim());
            Storage.set('tm_topbar_text_color_dark', String(this.data.topbarTextColorDark || '').trim());
            Storage.set('tm_task_content_color_light', String(this.data.taskContentColorLight || '').trim());
            Storage.set('tm_task_content_color_dark', String(this.data.taskContentColorDark || '').trim());
            Storage.set('tm_group_doc_label_color_light', String(this.data.groupDocLabelColorLight || '').trim());
            Storage.set('tm_group_doc_label_color_dark', String(this.data.groupDocLabelColorDark || '').trim());
            Storage.set('tm_time_group_base_color_light', String(this.data.timeGroupBaseColorLight || '').trim());
            Storage.set('tm_time_group_base_color_dark', String(this.data.timeGroupBaseColorDark || '').trim());
            Storage.set('tm_time_group_overdue_color_light', String(this.data.timeGroupOverdueColorLight || '').trim());
            Storage.set('tm_time_group_overdue_color_dark', String(this.data.timeGroupOverdueColorDark || '').trim());
            Storage.set('tm_progress_bar_color_light', String(this.data.progressBarColorLight || '').trim());
            Storage.set('tm_progress_bar_color_dark', String(this.data.progressBarColorDark || '').trim());
            Storage.set('tm_table_border_color_light', String(this.data.tableBorderColorLight || '').trim());
            Storage.set('tm_table_border_color_dark', String(this.data.tableBorderColorDark || '').trim());
            Storage.set('tm_enable_quickbar', !!this.data.enableQuickbar);
            Storage.set('tm_pin_new_tasks_by_default', !!this.data.pinNewTasksByDefault);
            Storage.set('tm_new_task_doc_id', String(this.data.newTaskDocId || '').trim());
            Storage.set('tm_enable_tomato_integration', !!this.data.enableTomatoIntegration);
            Storage.set('tm_tomato_spent_attr_mode', String(this.data.tomatoSpentAttrMode || 'minutes'));
            Storage.set('tm_tomato_spent_attr_key_minutes', String(this.data.tomatoSpentAttrKeyMinutes || '').trim());
            Storage.set('tm_tomato_spent_attr_key_hours', String(this.data.tomatoSpentAttrKeyHours || '').trim());
            Storage.set('tm_calendar_enabled', !!this.data.calendarEnabled);
            Storage.set('tm_calendar_link_docktomato', !!this.data.calendarLinkDockTomato);
            Storage.set('tm_calendar_initial_view', String(this.data.calendarInitialView || 'timeGridWeek').trim() || 'timeGridWeek');
            Storage.set('tm_calendar_first_day', Number(this.data.calendarFirstDay) === 0 ? 0 : 1);
            Storage.set('tm_calendar_month_aggregate', !!this.data.calendarMonthAggregate);
            Storage.set('tm_calendar_show_schedule', !!this.data.calendarShowSchedule);
            Storage.set('tm_calendar_show_tomato_master', !!this.data.calendarShowTomatoMaster);
            Storage.set('tm_calendar_show_focus', !!this.data.calendarShowFocus);
            Storage.set('tm_calendar_show_break', !!this.data.calendarShowBreak);
            Storage.set('tm_calendar_show_stopwatch', !!this.data.calendarShowStopwatch);
            Storage.set('tm_calendar_show_idle', !!this.data.calendarShowIdle);
            Storage.set('tm_calendar_show_task_dates', !!this.data.calendarShowTaskDates);
            Storage.set('tm_calendar_task_date_color_mode', String(this.data.calendarTaskDateColorMode || 'group').trim() || 'group');
            Storage.set('tm_calendar_schedule_color', String(this.data.calendarScheduleColor || '').trim());
            Storage.set('tm_calendar_task_dates_color', String(this.data.calendarTaskDatesColor || '').trim());
            Storage.set('tm_calendar_show_cn_holiday', !!this.data.calendarShowCnHoliday);
            Storage.set('tm_calendar_cn_holiday_color', String(this.data.calendarCnHolidayColor || '').trim());
            Storage.set('tm_calendar_show_lunar', !!this.data.calendarShowLunar);
            Storage.set('tm_calendar_side_dock_enabled', !!this.data.calendarSideDockEnabled);
            Storage.set('tm_calendar_side_dock_width', Number(this.data.calendarSideDockWidth) || 340);
            Storage.set('tm_calendar_color_focus', String(this.data.calendarColorFocus || '').trim());
            Storage.set('tm_calendar_color_break', String(this.data.calendarColorBreak || '').trim());
            Storage.set('tm_calendar_color_stopwatch', String(this.data.calendarColorStopwatch || '').trim());
            Storage.set('tm_calendar_color_idle', String(this.data.calendarColorIdle || '').trim());
            Storage.set('tm_calendar_sidebar_width', Number(this.data.calendarSidebarWidth) || 280);
            Storage.set('tm_calendar_column_widths', this.data.calendarColumnWidths || {});
            Storage.set('tm_calendar_last_view_type', String(this.data.calendarLastViewType || '').trim());
            Storage.set('tm_calendar_last_date', String(this.data.calendarLastDate || '').trim());
            Storage.set('tm_calendar_calendars_config', this.data.calendarCalendarsConfig || {});
            Storage.set('tm_calendar_default_calendar_id', String(this.data.calendarDefaultCalendarId || 'default').trim() || 'default');
            Storage.set('tm_calendar_sidebar_collapse_calendars', !!this.data.calendarSidebarCollapseCalendars);
            Storage.set('tm_calendar_sidebar_collapse_doc_groups', !!this.data.calendarSidebarCollapseDocGroups);
            Storage.set('tm_calendar_sidebar_collapse_tomato', !!this.data.calendarSidebarCollapseTomato);
            Storage.set('tm_calendar_sidebar_collapse_tasks', !!this.data.calendarSidebarCollapseTasks);
            Storage.set('tm_default_doc_id', this.data.defaultDocId);
            Storage.set('tm_default_doc_id_by_group', this.data.defaultDocIdByGroup || {});
            Storage.set('tm_priority_score_config', this.data.priorityScoreConfig || {});
            Storage.set('tm_quadrant_config', this.data.quadrantConfig);
            Storage.set('tm_doc_groups', this.data.docGroups);
            Storage.set('tm_doc_pinned_by_group', this.data.docPinnedByGroup || {});
            Storage.set('tm_current_group_id', this.data.currentGroupId);
            Storage.set('tm_custom_status_options', this.data.customStatusOptions);
            Storage.set('tm_column_widths', this.data.columnWidths);
            Storage.set('tm_column_order', this.data.columnOrder);
            Storage.set('tm_timeline_left_width', this.data.timelineLeftWidth);
            Storage.set('tm_timeline_content_width', this.data.timelineContentWidth);
            Storage.set('tm_timeline_force_sort_completion_near_today', !!this.data.timelineForceSortByCompletionNearToday);
            Storage.set('tm_whiteboard_links', this.data.whiteboardLinks || []);
            Storage.set('tm_whiteboard_auto_connect_by_created', !!this.data.whiteboardAutoConnectByCreated);
            Storage.set('tm_whiteboard_detached_children', this.data.whiteboardDetachedChildren || {});
            Storage.set('tm_whiteboard_notes', this.data.whiteboardNotes || []);
            Storage.set('tm_whiteboard_tool', String(this.data.whiteboardTool || 'pan').trim() || 'pan');
            Storage.set('tm_whiteboard_sidebar_collapsed', !!this.data.whiteboardSidebarCollapsed);
            Storage.set('tm_whiteboard_sidebar_width', Number(this.data.whiteboardSidebarWidth) || 300);
            Storage.set('tm_whiteboard_show_done', !!this.data.whiteboardShowDone);
            Storage.set('tm_whiteboard_view', this.data.whiteboardView || { x: 64, y: 40, zoom: 1 });
            Storage.set('tm_whiteboard_node_pos', this.data.whiteboardNodePos || {});
            Storage.set('tm_whiteboard_auto_layout', this.data.whiteboardAutoLayout !== false);
            Storage.set('tm_whiteboard_placed_task_ids', this.data.whiteboardPlacedTaskIds || {});
            Storage.set('tm_whiteboard_doc_frame_size', this.data.whiteboardDocFrameSize || {});
            Storage.set('tm_whiteboard_sequence_mode', !!this.data.whiteboardSequenceMode);
            Storage.set('tm_doc_color_map', this.data.docColorMap || {});
            Storage.set('tm_doc_color_seed', Number(this.data.docColorSeed) || 1);
        },

        normalizeColumns() {
            const defaultOrder = ['pinned', 'content', 'status', 'score', 'doc', 'h2', 'priority', 'startDate', 'completionTime', 'duration', 'spent', 'remark'];
            const known = new Set(defaultOrder);
            if (!Array.isArray(this.data.columnOrder)) this.data.columnOrder = [...defaultOrder];
            this.data.columnOrder = this.data.columnOrder.filter(k => known.has(k));
            if (this.data.columnOrder.length === 0) this.data.columnOrder = [...defaultOrder];

            const percentFallback = { pinned: 5, content: 35, status: 8, score: 8, doc: 12, h2: 12, priority: 8, startDate: 7, completionTime: 18, duration: 8, spent: 8, remark: 19 };
            const pxDefault = { pinned: 48, content: 360, status: 96, score: 96, doc: 180, h2: 180, priority: 96, startDate: 90, completionTime: 170, duration: 96, spent: 96, remark: 240 };

            const widths = (this.data.columnWidths && typeof this.data.columnWidths === 'object') ? { ...this.data.columnWidths } : {};
            const vals = Object.values(widths).filter(v => typeof v === 'number' && Number.isFinite(v));
            const sum = vals.reduce((a, b) => a + b, 0);
            const max = vals.reduce((m, v) => Math.max(m, v), 0);
            const looksPercent = vals.length > 0 && sum <= 160 && max <= 60;
            if (looksPercent) {
                const basePx = 1200;
                defaultOrder.forEach(k => {
                    const pct = Number(widths[k] ?? percentFallback[k] ?? 10);
                    const safePct = Number.isFinite(pct) ? pct : 10;
                    widths[k] = Math.round(basePx * safePct / 100);
                });
            }
            defaultOrder.forEach(k => {
                const raw = Number(widths[k]);
                const d = pxDefault[k] || 120;
                const normalized = Number.isFinite(raw) ? Math.round(raw) : d;
                widths[k] = Math.max(10, Math.min(800, normalized));
            });
            this.data.columnWidths = widths;
            const map = this.data.docColorMap;
            this.data.docColorMap = (map && typeof map === 'object' && !Array.isArray(map)) ? map : {};
            const pinMap0 = this.data.docPinnedByGroup;
            const pinMap = (pinMap0 && typeof pinMap0 === 'object' && !Array.isArray(pinMap0)) ? pinMap0 : {};
            const normalizedPinMap = {};
            Object.keys(pinMap).forEach((k) => {
                const key = String(k || '').trim() || 'all';
                const arr = Array.isArray(pinMap[k]) ? pinMap[k] : [];
                const seen = new Set();
                const list = [];
                arr.forEach((id) => {
                    const s = String(id || '').trim();
                    if (!s || seen.has(s)) return;
                    seen.add(s);
                    list.push(s);
                });
                normalizedPinMap[key] = list;
            });
            this.data.docPinnedByGroup = normalizedPinMap;
            const seed = Number(this.data.docColorSeed);
            this.data.docColorSeed = (Number.isFinite(seed) && seed > 0) ? Math.floor(seed) : 1;
            const kw = Number(this.data.kanbanColumnWidth);
            this.data.kanbanColumnWidth = Number.isFinite(kw) ? Math.max(220, Math.min(520, Math.round(kw))) : 320;
            this.data.docH2SubgroupEnabled = this.data.docH2SubgroupEnabled !== false;
            this.data.timelineForceSortByCompletionNearToday = !!this.data.timelineForceSortByCompletionNearToday;
            this.data.whiteboardLinks = Array.isArray(this.data.whiteboardLinks) ? this.data.whiteboardLinks : [];
            this.data.whiteboardAutoConnectByCreated = false;
            this.data.whiteboardDetachedChildren = (this.data.whiteboardDetachedChildren && typeof this.data.whiteboardDetachedChildren === 'object' && !Array.isArray(this.data.whiteboardDetachedChildren))
                ? this.data.whiteboardDetachedChildren
                : {};
            this.data.whiteboardNotes = Array.isArray(this.data.whiteboardNotes) ? this.data.whiteboardNotes : [];
            const wbTool = String(this.data.whiteboardTool || 'pan').trim();
            this.data.whiteboardTool = (wbTool === 'select' || wbTool === 'text' || wbTool === 'pan') ? wbTool : 'pan';
            this.data.whiteboardSidebarCollapsed = !!this.data.whiteboardSidebarCollapsed;
            const wbSidebarWidth = Number(this.data.whiteboardSidebarWidth);
            this.data.whiteboardSidebarWidth = Number.isFinite(wbSidebarWidth) ? Math.max(220, Math.min(520, Math.round(wbSidebarWidth))) : 300;
            this.data.whiteboardShowDone = !!this.data.whiteboardShowDone;
            const wv0 = (this.data.whiteboardView && typeof this.data.whiteboardView === 'object') ? this.data.whiteboardView : {};
            const x0 = Number(wv0.x);
            const y0 = Number(wv0.y);
            const z0 = Number(wv0.zoom);
            this.data.whiteboardView = {
                x: Number.isFinite(x0) ? x0 : 64,
                y: Number.isFinite(y0) ? y0 : 40,
                zoom: Number.isFinite(z0) ? Math.max(0.35, Math.min(2.5, z0)) : 1,
            };
            this.data.whiteboardNodePos = (this.data.whiteboardNodePos && typeof this.data.whiteboardNodePos === 'object' && !Array.isArray(this.data.whiteboardNodePos))
                ? this.data.whiteboardNodePos
                : {};
            this.data.whiteboardAutoLayout = false;
            this.data.whiteboardSequenceMode = !!this.data.whiteboardSequenceMode;
            const wbPlaced0 = (this.data.whiteboardPlacedTaskIds && typeof this.data.whiteboardPlacedTaskIds === 'object' && !Array.isArray(this.data.whiteboardPlacedTaskIds))
                ? this.data.whiteboardPlacedTaskIds
                : {};
            const wbPlaced = {};
            Object.keys(wbPlaced0).forEach((k) => {
                const id = String(k || '').trim();
                if (!id) return;
                if (wbPlaced0[k]) wbPlaced[id] = true;
            });
            this.data.whiteboardPlacedTaskIds = wbPlaced;
            const wbFrame0 = (this.data.whiteboardDocFrameSize && typeof this.data.whiteboardDocFrameSize === 'object' && !Array.isArray(this.data.whiteboardDocFrameSize))
                ? this.data.whiteboardDocFrameSize
                : {};
            const wbFrame = {};
            Object.keys(wbFrame0).forEach((k) => {
                const id = String(k || '').trim();
                if (!id) return;
                const w = Number(wbFrame0[k]?.w);
                const h = Number(wbFrame0[k]?.h);
                if (!Number.isFinite(w) || !Number.isFinite(h)) return;
                wbFrame[id] = { w: Math.max(520, Math.round(w)), h: Math.max(220, Math.round(h)) };
            });
            this.data.whiteboardDocFrameSize = wbFrame;
        },

        async save() {
            this.saveDirty = true;
            try { if (this.saveTimer) clearTimeout(this.saveTimer); } catch (e) {}
            if (!this.savePromise) {
                this.savePromise = new Promise((resolve) => {
                    this.savePromiseResolve = resolve;
                });
            }
            this.saveTimer = setTimeout(() => {
                this.saveTimer = null;
                this.flushSave();
            }, 350);
            return this.savePromise;
        },

        async flushSave() {
            if (this.saving) return;
            if (!this.saveDirty) return;
            this.saving = true;
            this.saveDirty = false;
            try {
                // 本地缓存延后到 flush，避免每次 save() 都全量写 localStorage
                this.syncToLocal();
                const formData = new FormData();
                formData.append('path', SETTINGS_FILE_PATH);
                formData.append('isDir', 'false');
                formData.append('file', new Blob([JSON.stringify(this.data, null, 2)], { type: 'application/json' }));

                await fetch('/api/file/putFile', { method: 'POST', body: formData }).catch(() => null);
            } catch (e) {
            } finally {
                this.saving = false;
                if (this.saveDirty) {
                    try { if (this.saveTimer) clearTimeout(this.saveTimer); } catch (e) {}
                    this.saveTimer = setTimeout(() => {
                        this.saveTimer = null;
                        this.flushSave();
                    }, 50);
                    return;
                }
                try { this.savePromiseResolve?.(); } catch (e) {}
                this.savePromise = null;
                this.savePromiseResolve = null;
            }
        },

        // 便捷方法：更新列宽度
        async updateColumnWidth(column, width) {
            if (typeof width === 'number' && width >= 10 && width <= 800) {
                this.data.columnWidths[column] = width;
                await this.save();
            }
        },

        // 便捷方法：更新文档ID列表
        async updateDocIds(docIds) {
            this.data.selectedDocIds = docIds;
            await this.save();
        },

        // 便捷方法：添加文档
        async addDocId(docId) {
            if (!this.data.selectedDocIds.includes(docId)) {
                this.data.selectedDocIds.push(docId);
                await this.save();
            }
        },

        // 便捷方法：移除文档
        async removeDocId(index) {
            if (index >= 0 && index < this.data.selectedDocIds.length) {
                this.data.selectedDocIds.splice(index, 1);
                await this.save();
            }
        },

        // 便捷方法：清空文档
        async clearDocIds() {
            this.data.selectedDocIds = [];
            await this.save();
        },

        // 便捷方法：保存规则
        async saveRules(rules) {
            this.data.filterRules = rules;
            await this.save();
        },

        // 便捷方法：更新文档分组
        async updateDocGroups(groups) {
            this.data.docGroups = groups;
            await this.save();
        },

        // 便捷方法：更新当前分组ID
        async updateCurrentGroupId(groupId) {
            this.data.currentGroupId = groupId;
            await this.save();
        },

        // 便捷方法：更新字体大小
        async updateFontSize(size) {
            this.data.fontSize = size;
            await this.save();
        },
        // 便捷方法：更新移动端字体大小
        async updateFontSizeMobile(size) {
            this.data.fontSizeMobile = size;
            await this.save();
        }
    };

    const WhiteboardStore = {
        data: Storage.get(WHITEBOARD_DATA_CACHE_KEY, { cards: {}, links: [] }) || { cards: {}, links: [] },
        loaded: false,
        saving: false,
        saveTimer: null,
        saveDirty: false,

        normalize() {
            const raw = (this.data && typeof this.data === 'object') ? this.data : {};
            const cards0 = (raw.cards && typeof raw.cards === 'object' && !Array.isArray(raw.cards)) ? raw.cards : {};
            const cards = {};
            Object.keys(cards0).forEach((k) => {
                const id = String(k || '').trim();
                if (!id) return;
                const v = cards0[k];
                if (!v || typeof v !== 'object') return;
                const docId = String(v.docId || '').trim();
                const content = String(v.content || '').trim();
                if (!docId || !content) return;
                cards[id] = {
                    id,
                    docId,
                    content,
                    parentTaskId: String(v.parentTaskId || '').trim(),
                    h2: String(v.h2 || '').trim(),
                    h2Id: String(v.h2Id || '').trim(),
                    h2Path: String(v.h2Path || '').trim(),
                    h2Sort: Number(v.h2Sort),
                    h2Created: String(v.h2Created || '').trim(),
                    h2Rank: Number(v.h2Rank),
                    headingLevel: String(v.headingLevel || '').trim(),
                    startDate: String(v.startDate || '').trim(),
                    completionTime: String(v.completionTime || '').trim(),
                    done: !!v.done,
                    updatedAt: String(v.updatedAt || Date.now()),
                };
            });
            const links0 = Array.isArray(raw.links) ? raw.links : [];
            const links = links0
                .map((x) => {
                    const item = (x && typeof x === 'object') ? x : {};
                    const from = String(item.from || '').trim();
                    const to = String(item.to || '').trim();
                    const docId = String(item.docId || '').trim();
                    if (!from || !to || !docId || from === to) return null;
                    return {
                        id: String(item.id || '').trim() || `link_${docId}_${from}_${to}`,
                        from,
                        to,
                        docId,
                        createdAt: String(item.createdAt || Date.now()),
                    };
                })
                .filter(Boolean);
            this.data = { cards, links };
        },

        async load() {
            if (this.loaded) return;
            try { this.normalize(); } catch (e) {}
            try {
                const res = await fetch('/api/file/getFile', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: WHITEBOARD_DATA_FILE_PATH }),
                });
                if (res.ok) {
                    const text = await res.text();
                    if (text && text.trim()) {
                        const json = JSON.parse(text);
                        if (json && typeof json === 'object') this.data = json;
                    }
                }
            } catch (e) {}
            try { this.normalize(); } catch (e) {}
            try { Storage.set(WHITEBOARD_DATA_CACHE_KEY, this.data || { cards: {}, links: [] }); } catch (e) {}
            this.loaded = true;
        },

        scheduleSave() {
            this.saveDirty = true;
            try { if (this.saveTimer) clearTimeout(this.saveTimer); } catch (e) {}
            this.saveTimer = setTimeout(() => {
                this.saveTimer = null;
                this.saveNow();
            }, 420);
        },

        async saveNow() {
            if (this.saving) return;
            if (!this.saveDirty) return;
            this.saving = true;
            this.saveDirty = false;
            try {
                this.normalize();
                try { Storage.set(WHITEBOARD_DATA_CACHE_KEY, this.data || { cards: {}, links: [] }); } catch (e) {}
                const formDir = new FormData();
                formDir.append('path', PLUGIN_STORAGE_DIR);
                formDir.append('isDir', 'true');
                await fetch('/api/file/putFile', { method: 'POST', body: formDir }).catch(() => null);

                const formData = new FormData();
                formData.append('path', WHITEBOARD_DATA_FILE_PATH);
                formData.append('isDir', 'false');
                formData.append('file', new Blob([JSON.stringify(this.data || { cards: {}, links: [] }, null, 2)], { type: 'application/json' }));
                await fetch('/api/file/putFile', { method: 'POST', body: formData }).catch(() => null);
            } catch (e) {
            } finally {
                this.saving = false;
                if (this.saveDirty) this.scheduleSave();
            }
        },

        getTask(taskId) {
            const id = String(taskId || '').trim();
            if (!id) return null;
            const cards = (this.data && this.data.cards && typeof this.data.cards === 'object') ? this.data.cards : {};
            const item = cards[id];
            return (item && typeof item === 'object') ? item : null;
        },

        upsertTask(task, opts = {}) {
            const t = (task && typeof task === 'object') ? task : {};
            const id = String(t.id || '').trim();
            const docId = String(t.root_id || t.docId || '').trim();
            const content = String(t.content || '').trim();
            if (!id || !docId || !content) return false;
            const cards = (this.data.cards && typeof this.data.cards === 'object' && !Array.isArray(this.data.cards))
                ? this.data.cards
                : {};
            const prev = cards[id] || {};
            const next = {
                id,
                docId,
                content,
                parentTaskId: String(t.parentTaskId || '').trim(),
                h2: String(t.h2 || '').trim(),
                h2Id: String(t.h2Id || '').trim(),
                h2Path: String(t.h2Path || '').trim(),
                h2Sort: Number(t.h2Sort),
                h2Created: String(t.h2Created || '').trim(),
                h2Rank: Number(t.h2Rank),
                headingLevel: String(SettingsStore.data.taskHeadingLevel || 'h2').trim() || 'h2',
                startDate: String(t.startDate || '').trim(),
                completionTime: String(t.completionTime || '').trim(),
                done: !!t.done,
                updatedAt: String(Date.now()),
            };
            const changed = JSON.stringify({
                docId: prev.docId || '',
                content: prev.content || '',
                parentTaskId: prev.parentTaskId || '',
                h2: prev.h2 || '',
                h2Id: prev.h2Id || '',
                h2Path: prev.h2Path || '',
                h2Sort: Number(prev.h2Sort),
                h2Created: prev.h2Created || '',
                h2Rank: Number(prev.h2Rank),
                headingLevel: prev.headingLevel || '',
                startDate: prev.startDate || '',
                completionTime: prev.completionTime || '',
                done: !!prev.done,
            }) !== JSON.stringify({
                docId: next.docId,
                content: next.content,
                parentTaskId: next.parentTaskId,
                h2: next.h2,
                h2Id: next.h2Id,
                h2Path: next.h2Path,
                h2Sort: Number(next.h2Sort),
                h2Created: next.h2Created,
                h2Rank: Number(next.h2Rank),
                headingLevel: next.headingLevel,
                startDate: next.startDate,
                completionTime: next.completionTime,
                done: next.done,
            });
            if (!changed) return false;
            cards[id] = next;
            this.data.cards = cards;
            if (opts && opts.persist === false) return true;
            this.scheduleSave();
            return true;
        },

        upsertTasks(tasks, opts = {}) {
            const list = Array.isArray(tasks) ? tasks : [];
            if (!list.length) return false;
            let changed = false;
            list.forEach((t) => {
                if (this.upsertTask(t, { persist: false })) changed = true;
            });
            if (!changed) return false;
            if (opts && opts.persist === false) return true;
            this.scheduleSave();
            return true;
        },
    };

    // 规则管理器
    const RuleManager = {
        // 获取所有规则（优先从 SettingsStore 获取）
        getRules() {
            // 优先从 SettingsStore 获取
            if (SettingsStore.loaded && Array.isArray(SettingsStore.data.filterRules) && SettingsStore.data.filterRules.length > 0) {
                return SettingsStore.data.filterRules;
            }
            // 回退到本地存储
            return Storage.get('tm_filter_rules', []);
        },

        // 保存规则（使用 SettingsStore 保存到云端和本地）
        async saveRules(rules) {
            SettingsStore.data.filterRules = rules;
            await SettingsStore.save();
        },

        // 获取默认规则
        getDefaultRules() {
            return [
                {
                    id: 'default_all',
                    name: '所有任务',
                    enabled: true,
                    conditions: [],
                    sort: [
                        { field: 'priority', order: 'desc' },
                        { field: 'created', order: 'asc' }
                    ]
                },
                {
                    id: 'default_todo',
                    name: '待办任务',
                    enabled: true,
                    conditions: [
                        { field: 'done', operator: '=', value: false }
                    ],
                    sort: [
                        { field: 'priority', order: 'desc' },
                        { field: 'updated', order: 'desc' }
                    ]
                },
                {
                    id: 'default_today',
                    name: '今日任务',
                    enabled: true,
                    conditions: [
                        { field: 'done', operator: '=', value: false },
                        { 
                            field: 'completionTime', 
                            operator: 'range_today',
                            value: { from: '', to: '' }
                        }
                    ],
                    sort: [
                        { field: 'priority', order: 'desc' },
                        { field: 'completionTime', order: 'asc' }
                    ]
                },
                {
                    id: 'high_priority',
                    name: '高优先级',
                    enabled: true,
                    conditions: [
                        { field: 'done', operator: '=', value: false },
                        { field: 'priority', operator: '=', value: 'high' }
                    ],
                    sort: [
                        { field: 'created', order: 'asc' },
                        { field: 'completionTime', order: 'asc' }
                    ]
                }
            ];
        },

        // 初始化规则
        async initRules() {
            const rules = this.getRules();
            if (rules.length === 0) {
                const defaultRules = this.getDefaultRules();
                await this.saveRules(defaultRules);
                return defaultRules;
            }
            return rules;
        },

        // 创建新规则
        createRule(name) {
            return {
                id: 'rule_' + Date.now(),
                name: name || '新规则',
                enabled: true,
                conditions: [],
                sort: [
                    { field: 'priorityScore', order: 'desc' },
                    { field: 'priority', order: 'desc' }
                ]
            };
        },
        
        // 获取可用字段
        getAvailableFields() {
            return [
                { value: 'content', label: '任务内容', type: 'text' },
                { value: 'done', label: '完成状态', type: 'boolean' },
                { value: 'priority', label: '优先级', type: 'select', options: ['high', 'medium', 'low', 'none'] },
                { value: 'priorityScore', label: '优先级数值', type: 'number' },
                { value: 'customStatus', label: '状态', type: 'select' },
                { value: 'completionTime', label: '完成日期', type: 'datetime' },
                { value: 'created', label: '创建时间', type: 'datetime' },
                { value: 'updated', label: '更新时间', type: 'datetime' },
                { value: 'duration', label: '任务时长', type: 'text' },
                { value: 'remark', label: '备注', type: 'text' },
                { value: 'docName', label: '文档名称', type: 'text' },
                { value: 'level', label: '任务层级', type: 'number' }
            ];
        },
        
        // 获取可用操作符
        getOperators(fieldType) {
            const baseOperators = [
                { value: '=', label: '等于' },
                { value: '!=', label: '不等于' },
                { value: 'in', label: '在列表中' },        // 多值匹配
                { value: 'not_in', label: '不在列表中' },  // 多值排除
                { value: 'contains', label: '包含' },
                { value: 'not_contains', label: '不包含' }
            ];
            
            const numberOperators = [
                { value: '>', label: '大于' },
                { value: '<', label: '小于' },
                { value: '>=', label: '大于等于' },
                { value: '<=', label: '小于等于' },
                { value: 'between', label: '介于' }
            ];
            
            const datetimeOperators = [
                { value: 'range_today', label: '今天' },
                { value: 'range_week', label: '本周' },
                { value: 'range_month', label: '本月' },
                { value: 'range_year', label: '今年' },
                { value: 'before', label: '之前' },
                { value: 'after', label: '之后' },
                { value: 'between', label: '介于' }
            ];
            
            switch(fieldType) {
                case 'number':
                    return [...baseOperators, ...numberOperators];
                case 'datetime':
                    return [...baseOperators, ...datetimeOperators];
                case 'boolean':
                    return [
                        { value: '=', label: '是' },
                        { value: '!=', label: '不是' }
                    ];
                default:
                    return baseOperators;
            }
        },
        
        // 获取排序字段
        getSortFields() {
            return [
                { value: 'priorityScore', label: '优先级数值' },
                { value: 'priority', label: '优先级' },
                { value: 'customStatus', label: '状态' },
                { value: 'startDate', label: '开始日期' },
                { value: 'completionTime', label: '完成日期' },
                { value: 'created', label: '创建时间' },
                { value: 'updated', label: '更新时间' },
                { value: 'content', label: '任务内容' },
                { value: 'docName', label: '文档名称' },
                { value: 'h2', label: (() => {
                    const level = SettingsStore.data.taskHeadingLevel || 'h2';
                    const labels = { h1: '一级标题', h2: '二级标题', h3: '三级标题', h4: '四级标题', h5: '五级标题', h6: '六级标题' };
                    return labels[level] || '标题';
                })() },
                { value: 'duration', label: '任务时长' }
            ];
        },
        
        // 应用规则筛选
        applyRuleFilter(tasks, rule) {
            if (!rule || !rule.conditions || rule.conditions.length === 0) {
                return tasks;
            }
            
            return tasks.filter(task => {
                return rule.conditions.every(condition => {
                    return this.evaluateCondition(task, condition);
                });
            });
        },
        
        // 评估单个条件
        evaluateCondition(task, condition) {
            const { field, operator, value } = condition;
            let taskValue = task[field];
            if (field === 'customStatus') {
                const raw = String(taskValue || '').trim();
                if (raw) {
                    taskValue = raw;
                } else {
                    const opts = Array.isArray(SettingsStore.data.customStatusOptions) ? SettingsStore.data.customStatusOptions : [];
                    const fallback = String((opts[0] && opts[0].id) || 'todo').trim() || 'todo';
                    taskValue = fallback;
                }
            }

            // 处理布尔值
            if (field === 'done') {
                if (String(value) === '__all__') return true;
                const targetValue = (value === '' || value === null || typeof value === 'undefined')
                    ? true
                    : (value === true || value === 'true');
                if (operator === '=') return task.done === targetValue;
                if (operator === '!=') return task.done !== targetValue;
            }

            // 处理多值匹配（in / not_in）
            if (operator === 'in' || operator === 'not_in') {
                // value 应该是数组格式 ['high', 'medium', 'low']
                let values = [];
                if (Array.isArray(value)) {
                    values = value;
                } else if (typeof value === 'string' && value.includes(',')) {
                    values = value.split(',').map(v => v.trim());
                } else {
                    values = [value];
                }

                // 空值（无）也作为一个选项
                const hasEmpty = values.includes('') || values.includes('无');
                const nonEmptyValues = values.filter(v => v !== '' && v !== '无');

                const taskValueStr = String(taskValue || '').trim();
                const taskMatch = nonEmptyValues.includes(taskValueStr);
                const hasEmptyMatch = (!taskValueStr || taskValueStr === '') && hasEmpty;

                if (operator === 'in') {
                    return taskMatch || hasEmptyMatch;
                } else { // not_in
                    return !taskMatch && !hasEmptyMatch;
                }
            }

            // 处理文本字段
            if (typeof taskValue === 'string') {
                const taskStr = taskValue.toLowerCase();
                const valueStr = String(value).toLowerCase();

                switch(operator) {
                    case '=': return taskStr === valueStr;
                    case '!=': return taskStr !== valueStr;
                    case 'contains': return taskStr.includes(valueStr);
                    case 'not_contains': return !taskStr.includes(valueStr);
                }
            }

            // 处理时间字段
            if (field.includes('Time') || field === 'created' || field === 'updated') {
                return this.evaluateTimeCondition(taskValue, operator, value);
            }

            // 默认比较
            if (operator === '=') return taskValue === value;
            if (operator === '!=') return taskValue !== value;

            return true;
        },
        
        // 评估时间条件
        evaluateTimeCondition(taskTime, operator, value) {
            const taskTs = __tmParseTimeToTs(taskTime);
            if (!taskTs) return operator === '!='; // 空时间处理

            const taskDate = new Date(taskTs);
            const now = new Date();
            
            switch(operator) {
                case 'range_today': {
                    const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);
                    return taskDate >= todayStart && taskDate < todayEnd;
                }
                case 'range_week': {
                    const weekStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - now.getDay());
                    const weekEnd = new Date(weekStart.getTime() + 7 * 24 * 60 * 60 * 1000);
                    return taskDate >= weekStart && taskDate < weekEnd;
                }
                case 'range_month': {
                    const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
                    const monthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 1);
                    return taskDate >= monthStart && taskDate < monthEnd;
                }
                case 'range_year': {
                    const yearStart = new Date(now.getFullYear(), 0, 1);
                    const yearEnd = new Date(now.getFullYear() + 1, 0, 1);
                    return taskDate >= yearStart && taskDate < yearEnd;
                }
                case 'before': {
                    const targetDate = new Date(__tmParseTimeToTs(value) || value);
                    return taskDate < targetDate;
                }
                case 'after': {
                    const targetDate = new Date(__tmParseTimeToTs(value) || value);
                    return taskDate > targetDate;
                }
                case 'between': {
                    let from = '';
                    let to = '';
                    if (value && typeof value === 'object') {
                        from = value.from || '';
                        to = value.to || '';
                    } else {
                        const parts = String(value || '').split(',');
                        from = parts[0] || '';
                        to = parts[1] || '';
                    }
                    const fromDate = new Date(__tmParseTimeToTs(from) || from);
                    const toDate = new Date(__tmParseTimeToTs(to) || to);
                    return taskDate >= fromDate && taskDate <= toDate;
                }
                case '=': return taskTime === value;
                case '!=': return taskTime !== value;
            }
            
            return true;
        },
        
        // 应用规则排序
        applyRuleSort(tasks, rule) {
            // 置顶任务始终排在最前
            const pinnedSort = (a, b) => {
                if (a.pinned && !b.pinned) return -1;
                if (!a.pinned && b.pinned) return 1;
                return 0;
            };

            if (!__tmRuleHasExplicitSort(rule)) {
                return [...tasks].sort(pinnedSort);
            }
            
            return [...tasks].sort((a, b) => {
                const pinnedRes = pinnedSort(a, b);
                if (pinnedRes !== 0) return pinnedRes;

                for (const sortRule of rule.sort) {
                    const { field, order } = sortRule;
                    let result = this.compareValues(a[field], b[field], field);
                    
                    if (result !== 0) {
                        return order === 'desc' ? -result : result;
                    }
                }
                return 0;
            });
        },
        
        // 比较值
        compareValues(a, b, field) {
            // 处理优先级特殊比较
            if (field === 'priority') {
                const priorityOrder = { high: 3, medium: 2, low: 1 };
                const na = ({ '高': 'high', '中': 'medium', '低': 'low' }[String(a ?? '').trim()] || String(a ?? '').trim());
                const nb = ({ '高': 'high', '中': 'medium', '低': 'low' }[String(b ?? '').trim()] || String(b ?? '').trim());
                return (priorityOrder[na] || 0) - (priorityOrder[nb] || 0);
            }
            if (field === 'priorityScore') {
                const na = Number(a);
                const nb = Number(b);
                const va = Number.isFinite(na) ? na : 0;
                const vb = Number.isFinite(nb) ? nb : 0;
                return va - vb;
            }

            // 处理状态排序
            if (field === 'customStatus') {
                const options = SettingsStore.data.customStatusOptions || [];
                const indexA = options.findIndex(o => o.id === a);
                const indexB = options.findIndex(o => o.id === b);
                const valA = indexA === -1 ? 9999 : indexA;
                const valB = indexB === -1 ? 9999 : indexB;
                return valA - valB;
            }
            
            // 处理时间比较
            if (field === 'startDate' || field.includes('Time') || field === 'created' || field === 'updated') {
                const timeA = a ? __tmParseTimeToTs(a) : 0;
                const timeB = b ? __tmParseTimeToTs(b) : 0;
                return timeA - timeB;
            }
            
            // 默认比较
            if (a === b) return 0;
            return a < b ? -1 : 1;
        }
    };

    const API = {
        // ... 原有的API方法保持不变 ...
        async call(url, body) {
            try {
                const res = await fetch(url, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify(body) 
                });
                return await res.json();
            } catch (err) { 
                return { code: -1, msg: err.message }; 
            }
        },

        async lsNotebooks() {
            const res = await this.call('/api/notebook/lsNotebooks', {});
            const notebooks = res?.data?.notebooks;
            return Array.isArray(notebooks) ? notebooks : [];
        },

        async createDocWithMd(notebook, path, markdown) {
            const res = await this.call('/api/filetree/createDocWithMd', { notebook, path, markdown });
            if (res.code !== 0) throw new Error(res.msg || '创建文档失败');
            return res.data;
        },

        async createDailyNote(notebook) {
            const box = String(notebook || '').trim();
            if (!box) throw new Error('未指定笔记本');
            const res = await this.call('/api/filetree/createDailyNote', { notebook: box });
            if (res.code !== 0) throw new Error(res.msg || '创建日记失败');
            const data = res.data;
            if (typeof data === 'string') return data;
            if (data && typeof data === 'object') {
                const id = data.id || data.ID || data.docId || data.docID || data.docid;
                if (id) return id;
            }
            throw new Error('创建日记失败');
        },

        async getDocNotebook(docId) {
            const id = String(docId || '').trim();
            if (!id) return '';
            const sql = `SELECT box FROM blocks WHERE id = '${id}' AND type = 'd'`;
            const res = await this.call('/api/query/sql', { stmt: sql });
            if (res.code === 0 && Array.isArray(res.data) && res.data.length > 0) {
                return String(res.data[0]?.box || '').trim();
            }
            return '';
        },

        async getSubDocIds(docId) {
            try {
                // 先获取根文档的 path
                const pathSql = `SELECT hpath FROM blocks WHERE id = '${docId}' AND type = 'd'`;
                const pathRes = await this.call('/api/query/sql', { stmt: pathSql });
                if (pathRes.code !== 0 || !pathRes.data || pathRes.data.length === 0) return [];
                
                const hpath = pathRes.data[0].hpath;
                
                // 查询子文档
                const sql = `SELECT id FROM blocks WHERE hpath LIKE '${hpath}/%' AND type = 'd'`;
                const res = await this.call('/api/query/sql', { stmt: sql });
                if (res.code === 0 && res.data) {
                    return res.data.map(d => d.id);
                }
            } catch (e) {
            }
            return [];
        },

        async getBlockKramdown(id) {
            const res = await this.call('/api/block/getBlockKramdown', { id });
            if (res.code !== 0) throw new Error(res.msg || '获取块内容失败');
            const data = res.data;
            if (typeof data === 'string') return data;
            return data?.kramdown || data?.content || '';
        },

        async fetchHeadingOrderByDocs(docIds, headingLevel = 'h2') {
            const ids = Array.from(new Set((docIds || []).map(x => String(x || '').trim()).filter(Boolean)));
            const out = new Map();
            if (ids.length === 0) return out;
            const lvRaw = String(headingLevel || 'h2').trim().toLowerCase();
            const lvNum0 = Number((lvRaw.match(/^h([1-6])$/) || [])[1]);
            const lvNum = Number.isFinite(lvNum0) ? lvNum0 : 2;
            const parseId = (line) => {
                const s = String(line || '');
                const m = s.match(/\{\:\s*[^}]*\bid="([^"]+)"/);
                return m ? String(m[1] || '').trim() : '';
            };
            for (const docId of ids) {
                let km = '';
                try { km = await this.getBlockKramdown(docId); } catch (e) { km = ''; }
                if (!km) continue;
                const lines = String(km).split(/\r?\n/);
                let rank = 0;
                const seen = new Set();
                for (let i = 0; i < lines.length; i++) {
                    const line = String(lines[i] || '');
                    const hm = line.match(/^(#{1,6})\s+/);
                    if (!hm || hm[1].length !== lvNum) continue;
                    let hid = parseId(line);
                    if (!hid) {
                        for (let j = i + 1; j <= Math.min(i + 4, lines.length - 1); j++) {
                            hid = parseId(lines[j]);
                            if (hid) break;
                        }
                    }
                    if (!hid || seen.has(hid)) continue;
                    seen.add(hid);
                    out.set(`${docId}::${hid}`, rank++);
                }
            }
            return out;
        },

        async getDocId() {
            try {
                const m = location.hash.match(/id=([0-9a-z-]+)/);
                if (m) return m[1];
            } catch(e) {
            }
            return null;
        },

        parseTaskStatus(markdown) {
            if (!markdown) return { done: false, firstLine: '', content: '' };

            const lines = markdown.split('\n');
            const firstLine = lines[0].trim();

            const done = /^\s*[\*\-]\s*\[[xX]\]/.test(firstLine);

            let content = firstLine.replace(/^[\s\*\-]*\[[xX ]\]\s*/, '').trim();
            content = content.replace(/<span[^>]*>[\s\S]*?<\/span>/gi, '');
            content = content.replace(/\{\:\s*[^}]*\}/g, '');
            content = content.replace(/<[^>]+>/g, '');
            content = content.replace(/\s{2,}/g, ' ').trim();

            return { done, firstLine, content };
        },

        async getAllDocuments() {
            try {
                const sql = `
                    SELECT 
                        d.id, 
                        d.content as name,
                        d.hpath as path,
                        d.box as notebook,
                        d.created,
                        COALESCE(tc.task_count, 0) as task_count
                    FROM blocks d
                    LEFT JOIN (
                        SELECT root_id, COUNT(*) as task_count
                        FROM blocks
                        WHERE type = 'i' AND subtype = 't'
                        GROUP BY root_id
                    ) tc ON tc.root_id = d.id
                    WHERE d.type = 'd' 
                    ORDER BY d.content
                `;
                
                const res = await this.call('/api/query/sql', { stmt: sql });
                if (res.code === 0 && res.data) {
                    return res.data.map(doc => ({
                        id: doc.id,
                        name: doc.name || '未命名文档',
                        path: doc.path || '',
                        notebook: doc.notebook || '',
                        taskCount: parseInt(doc.task_count) || 0,
                        created: doc.created
                    }));
                }
                return [];
            } catch (e) {
                console.error('[文档] 获取文档列表失败:', e);
                return [];
            }
        },

        async getTasksByDocument(docId, limit = 500, options = null) {
            const tomatoEnabled = !!SettingsStore.data.enableTomatoIntegration;
            const tomatoMinutesKey = __tmSafeAttrName(SettingsStore.data.tomatoSpentAttrKeyMinutes, 'custom-tomato-minutes');
            const tomatoHoursKey = __tmSafeAttrName(SettingsStore.data.tomatoSpentAttrKeyHours, 'custom-tomato-time');
            const extraNames = tomatoEnabled ? [tomatoMinutesKey, tomatoHoursKey].filter((v, i, a) => v && a.indexOf(v) === i) : [];
            const attrNamesSql = [
                'custom-priority',
                'custom-duration',
                'custom-remark',
                'custom-start-date',
                'custom-completion-time',
                'custom-milestone-event',
                'custom-time',
                'custom-status',
                'custom-pinned',
                ...extraNames
            ].map(n => `'${n}'`).join(',\n                            ');

            // 不查找已完成任务的过滤条件
            // 不查找已完成任务的过滤条件（数据库层面暂不过滤，全部在JavaScript中过滤）
            const excludeCompletedCondition = '';
            const doneOnlyCondition = (options && options.doneOnly === true)
                ? ` AND (task.markdown LIKE '%[x]%' OR task.markdown LIKE '%[X]%')`
                : '';

            const sql = `
                SELECT 
                    task.id,
                    task.markdown,
                    task.content as raw_content,
                    task.parent_id,
                    parent_task.id as parent_task_id,
                    task.root_id,
                    task.path as block_path,
                    task.sort as block_sort,
                    task.created,
                    task.updated,
                    
                    -- 文档信息
                    doc.content as doc_name,
                    doc.hpath as doc_path,
                    
                    -- 自定义属性
                    attr.priority,
                    attr.duration,
                    attr.remark,
                    attr.start_date,
                    attr.completion_time,
                    attr.milestone,
                    attr.time as custom_time,
                    attr.custom_status,
                    attr.pinned,
                    attr.tomato_minutes,
                    attr.tomato_hours
                    
                FROM blocks AS task
                
                -- 连接文档信息
                INNER JOIN blocks AS doc ON task.root_id = doc.id

                LEFT JOIN blocks AS parent_list ON parent_list.id = task.parent_id
                LEFT JOIN blocks AS parent_task ON parent_task.id = parent_list.parent_id AND parent_task.type = 'i' AND parent_task.subtype = 't'
                
                -- 左连接自定义属性（限制在当前文档的任务上，避免全表聚合）
                LEFT JOIN (
                    SELECT 
                        a.block_id,
                        MAX(CASE WHEN a.name = 'custom-priority' THEN a.value ELSE NULL END) as priority,
                        MAX(CASE WHEN a.name = 'custom-duration' THEN a.value ELSE NULL END) as duration,
                        MAX(CASE WHEN a.name = 'custom-remark' THEN a.value ELSE NULL END) as remark,
                        MAX(CASE WHEN a.name = 'custom-start-date' THEN a.value ELSE NULL END) as start_date,
                        MAX(CASE WHEN a.name = 'custom-completion-time' THEN a.value ELSE NULL END) as completion_time,
                        MAX(CASE WHEN a.name = 'custom-milestone-event' THEN a.value ELSE NULL END) as milestone,
                        MAX(CASE WHEN a.name = 'custom-time' THEN a.value ELSE NULL END) as time,
                        MAX(CASE WHEN a.name = 'custom-status' THEN a.value ELSE NULL END) as custom_status,
                        MAX(CASE WHEN a.name = 'custom-pinned' THEN a.value ELSE NULL END) as pinned,
                        ${tomatoEnabled ? `MAX(CASE WHEN a.name = '${tomatoMinutesKey}' THEN a.value ELSE NULL END) as tomato_minutes` : `NULL as tomato_minutes`},
                        ${tomatoEnabled ? `MAX(CASE WHEN a.name = '${tomatoHoursKey}' THEN a.value ELSE NULL END) as tomato_hours` : `NULL as tomato_hours`}
                    FROM attributes a
                    INNER JOIN blocks t ON t.id = a.block_id
                    WHERE 
                        t.type = 'i'
                        AND t.subtype = 't'
                        AND t.root_id = '${docId}'
                        AND a.name IN (
                            ${attrNamesSql}
                        )
                    GROUP BY a.block_id
                ) AS attr ON attr.block_id = task.id
                
                WHERE 
                    task.type = 'i' 
                    AND task.subtype = 't'
                    AND task.root_id = '${docId}'
                    AND task.markdown IS NOT NULL
                    AND task.markdown != ''${excludeCompletedCondition}${doneOnlyCondition}
                
                ORDER BY task.path, task.sort, task.created
                LIMIT ${limit}
            `;
            
            const startTime = Date.now();
            const res = await this.call('/api/query/sql', { stmt: sql });
            const queryTime = Date.now() - startTime;
            
            if (res.code !== 0) {
                console.error(`[查询] 文档 ${docId.slice(0, 8)} 查询失败:`, res.msg);
                return { tasks: [], queryTime };
            }
            return { tasks: res.data || [], queryTime };
        },

        async getTasksByDocuments(docIds, limitPerDoc = 500, options = null) {
            const safeDocIds = Array.isArray(docIds) ? docIds.filter(id => /^[0-9]+-[a-zA-Z0-9]+$/.test(String(id || ''))) : [];
            if (safeDocIds.length === 0) return { tasks: [], queryTime: 0 };
            const idList = safeDocIds.map(id => `'${id}'`).join(',');
            const perDocLimit = Number.isFinite(limitPerDoc) ? Math.max(1, Math.min(5000, limitPerDoc)) : 500;

            const tomatoEnabled = !!SettingsStore.data.enableTomatoIntegration;
            const tomatoMinutesKey = __tmSafeAttrName(SettingsStore.data.tomatoSpentAttrKeyMinutes, 'custom-tomato-minutes');
            const tomatoHoursKey = __tmSafeAttrName(SettingsStore.data.tomatoSpentAttrKeyHours, 'custom-tomato-time');
            const extraNames = tomatoEnabled ? [tomatoMinutesKey, tomatoHoursKey].filter((v, i, a) => v && a.indexOf(v) === i) : [];
            const attrNamesSql = [
                'custom-priority',
                'custom-duration',
                'custom-remark',
                'custom-start-date',
                'custom-completion-time',
                'custom-milestone-event',
                'custom-time',
                'custom-status',
                'custom-pinned',
                ...extraNames
            ].map(n => `'${n}'`).join(',\n                        ');

            // 不查找已完成任务的过滤条件
            // 不查找已完成任务的过滤条件（数据库层面暂不过滤，全部在JavaScript中过滤）
            const excludeCompletedCondition = '';
            const doneOnlyCondition = (options && options.doneOnly === true)
                ? ` AND (task.markdown LIKE '%[x]%' OR task.markdown LIKE '%[X]%')`
                : '';

            const sql = `
                WITH tasks0 AS (
                    SELECT
                        task.id,
                        task.markdown,
                        task.content AS raw_content,
                        task.parent_id,
                        task.root_id,
                        task.path AS block_path,
                        task.sort AS block_sort,
                        task.created,
                        task.updated,
                        doc.content AS doc_name,
                        doc.hpath AS doc_path,
                        ROW_NUMBER() OVER (PARTITION BY task.root_id ORDER BY task.path, task.sort, task.created) AS rn
                    FROM blocks AS task
                    INNER JOIN blocks AS doc ON task.root_id = doc.id
                    LEFT JOIN blocks parent_list ON parent_list.id = task.parent_id
                    LEFT JOIN blocks parent_task ON parent_task.id = parent_list.parent_id AND parent_task.type = 'i' AND parent_task.subtype = 't'
                    WHERE
                        task.type = 'i'
                        AND task.subtype = 't'
                        AND task.root_id IN (${idList})
                        AND task.markdown IS NOT NULL
                        AND task.markdown != ''${excludeCompletedCondition}${doneOnlyCondition}
                ),
                tasks AS (
                    SELECT * FROM tasks0 WHERE rn <= ${perDocLimit}
                ),
                attr AS (
                    SELECT
                        a.block_id,
                        MAX(CASE WHEN a.name = 'custom-priority' THEN a.value ELSE NULL END) AS priority,
                        MAX(CASE WHEN a.name = 'custom-duration' THEN a.value ELSE NULL END) AS duration,
                        MAX(CASE WHEN a.name = 'custom-remark' THEN a.value ELSE NULL END) AS remark,
                        MAX(CASE WHEN a.name = 'custom-start-date' THEN a.value ELSE NULL END) AS start_date,
                        MAX(CASE WHEN a.name = 'custom-completion-time' THEN a.value ELSE NULL END) AS completion_time,
                        MAX(CASE WHEN a.name = 'custom-milestone-event' THEN a.value ELSE NULL END) AS milestone,
                        MAX(CASE WHEN a.name = 'custom-time' THEN a.value ELSE NULL END) AS time,
                        MAX(CASE WHEN a.name = 'custom-status' THEN a.value ELSE NULL END) AS custom_status,
                        MAX(CASE WHEN a.name = 'custom-pinned' THEN a.value ELSE NULL END) AS pinned,
                        ${tomatoEnabled ? `MAX(CASE WHEN a.name = '${tomatoMinutesKey}' THEN a.value ELSE NULL END) AS tomato_minutes` : `NULL AS tomato_minutes`},
                        ${tomatoEnabled ? `MAX(CASE WHEN a.name = '${tomatoHoursKey}' THEN a.value ELSE NULL END) AS tomato_hours` : `NULL AS tomato_hours`}
                    FROM attributes a
                    INNER JOIN tasks t ON t.id = a.block_id
                    WHERE a.name IN (
                        ${attrNamesSql}
                    )
                    GROUP BY a.block_id
                )
                SELECT
                    t.id,
                    t.markdown,
                    t.raw_content,
                    t.parent_id,
                    parent_task.id AS parent_task_id,
                    t.root_id,
                    t.block_path,
                    t.block_sort,
                    t.rn AS doc_seq,
                    t.created,
                    t.updated,
                    t.doc_name,
                    t.doc_path,
                    attr.priority,
                    attr.duration,
                    attr.remark,
                    attr.start_date,
                    attr.completion_time,
                    attr.milestone,
                    attr.time AS custom_time,
                    attr.custom_status,
                    attr.pinned,
                    attr.tomato_minutes,
                    attr.tomato_hours
                FROM tasks t
                LEFT JOIN blocks parent_list ON parent_list.id = t.parent_id
                LEFT JOIN blocks parent_task ON parent_task.id = parent_list.parent_id AND parent_task.type = 'i' AND parent_task.subtype = 't'
                LEFT JOIN attr ON attr.block_id = t.id
                ORDER BY t.root_id, t.block_path, t.block_sort, t.created
            `;

            const startTime = Date.now();
            const res = await this.call('/api/query/sql', { stmt: sql });
            const queryTime = Date.now() - startTime;
            if (res.code !== 0) {
                console.error(`[查询] 批量查询失败:`, res.msg);
                try {
                    const fallbackStart = Date.now();
                    const results = await Promise.all(safeDocIds.map(id => this.getTasksByDocument(id, perDocLimit, options)));
                    const tasks = [];
                    results.forEach(r => tasks.push(...(r?.tasks || [])));
                    const fallbackTime = Date.now() - fallbackStart;
                    return { tasks, queryTime: queryTime + fallbackTime };
                } catch (e) {
                    return { tasks: [], queryTime };
                }
            }
            return { tasks: res.data || [], queryTime };
        },

        async getTaskById(id) {
            if (!id) return null;
            const sql = `
                SELECT 
                    task.id,
                    task.markdown,
                    task.content as raw_content,
                    task.parent_id,
                    parent_task.id as parent_task_id,
                    task.root_id,
                    task.created,
                    task.updated,
                    doc.content as doc_name,
                    doc.hpath as doc_path,
                    attr.priority,
                    attr.duration,
                    attr.remark,
                    attr.start_date,
                    attr.completion_time,
                    attr.milestone,
                    attr.time as custom_time,
                    attr.custom_status,
                    attr.pinned
                FROM blocks AS task
                INNER JOIN blocks AS doc ON task.root_id = doc.id
                LEFT JOIN blocks AS parent_list ON parent_list.id = task.parent_id
                LEFT JOIN blocks AS parent_task ON parent_task.id = parent_list.parent_id AND parent_task.type = 'i' AND parent_task.subtype = 't'
                LEFT JOIN (
                    SELECT 
                        block_id,
                        MAX(CASE WHEN name = 'custom-priority' THEN value ELSE NULL END) as priority,
                        MAX(CASE WHEN name = 'custom-duration' THEN value ELSE NULL END) as duration,
                        MAX(CASE WHEN name = 'custom-remark' THEN value ELSE NULL END) as remark,
                        MAX(CASE WHEN name = 'custom-start-date' THEN value ELSE NULL END) as start_date,
                        MAX(CASE WHEN name = 'custom-completion-time' THEN value ELSE NULL END) as completion_time,
                        MAX(CASE WHEN name = 'custom-milestone-event' THEN value ELSE NULL END) as milestone,
                        MAX(CASE WHEN name = 'custom-time' THEN value ELSE NULL END) as time,
                        MAX(CASE WHEN name = 'custom-status' THEN value ELSE NULL END) as custom_status,
                        MAX(CASE WHEN name = 'custom-pinned' THEN value ELSE NULL END) as pinned
                    FROM attributes
                    WHERE block_id = '${id}'
                    GROUP BY block_id
                ) AS attr ON attr.block_id = task.id
                WHERE task.id = '${id}'
                LIMIT 1
            `;
            const res = await this.call('/api/query/sql', { stmt: sql });
            if (res.code === 0 && res.data && res.data.length > 0) {
                return res.data[0];
            }
            return null;
        },

        async getTasksHierarchy(taskIds) {
            if (!taskIds || taskIds.length === 0) return {};
            
            const idList = taskIds.map(id => `'${id}'`).join(',');
            const sql = `
                WITH RECURSIVE task_tree AS (
                    -- 起始：所有指定任务
                    SELECT 
                        id,
                        parent_id,
                        0 as level,
                        id as original_id
                    FROM blocks 
                    WHERE id IN (${idList})
                    
                    UNION ALL
                    
                    -- 递归：向上查找父列表
                    SELECT 
                        b.id,
                        b.parent_id,
                        tt.level + 1,
                        tt.original_id
                    FROM blocks b
                    INNER JOIN task_tree tt ON b.id = tt.parent_id
                    WHERE b.type = 'l' AND tt.level < 5
                )
                SELECT 
                    original_id as task_id,
                    MAX(level) as depth
                FROM task_tree
                GROUP BY original_id
            `;
            
            const res = await this.call('/api/query/sql', { stmt: sql });
            if (res.code === 0 && res.data) {
                const hierarchy = {};
                res.data.forEach(row => {
                    hierarchy[row.task_id] = {
                        level: row.depth || 0
                    };
                });
                return hierarchy;
            }
            return {};
        },

        async fetchH2Contexts(taskIds) {
            if (!taskIds || taskIds.length === 0) return new Map();
            const batchSize = 100;
            const contextMap = new Map();
            for (let i = 0; i < taskIds.length; i += batchSize) {
                const batch = taskIds.slice(i, i + batchSize);
                const idList = batch.map(id => `'${id}'`).join(',');
                const taskRootMap = new Map();
                try {
                    const rootsSql = `SELECT id AS task_id, root_id FROM blocks WHERE id IN (${idList})`;
                    const rootsRes = await this.call('/api/query/sql', { stmt: rootsSql });
                    if (rootsRes.code === 0 && Array.isArray(rootsRes.data)) {
                        rootsRes.data.forEach((r) => {
                            const tid = String(r?.task_id || '').trim();
                            const rid = String(r?.root_id || '').trim();
                            if (tid && rid) taskRootMap.set(tid, rid);
                        });
                    }
                } catch (e) {}
                const sql = `
                    WITH RECURSIVE task_roots AS (
                        SELECT id AS task_id, root_id
                        FROM blocks
                        WHERE id IN (${idList})
                    ),
                    doc_roots AS (
                        SELECT DISTINCT root_id
                        FROM task_roots
                    ),
                    doc_tree AS (
                        SELECT
                            d.id,
                            d.id AS root_id,
                            0 AS depth,
                            '' AS order_key
                        FROM blocks d
                        WHERE d.id IN (SELECT root_id FROM doc_roots)

                        UNION ALL

                        SELECT
                            b.id,
                            t.root_id,
                            t.depth + 1 AS depth,
                            (t.order_key || '/' ||
                                CASE
                                    WHEN TRIM(CAST(b.sort AS TEXT)) GLOB '[0-9]*' AND TRIM(CAST(b.sort AS TEXT)) != ''
                                        THEN ('0:' || printf('%020d', CAST(TRIM(CAST(b.sort AS TEXT)) AS INTEGER)))
                                    ELSE ('1:' || COALESCE(NULLIF(TRIM(CAST(b.sort AS TEXT)), ''), ''))
                                END
                                || ':' || b.id) AS order_key
                        FROM blocks b
                        INNER JOIN doc_tree t ON b.parent_id = t.id
                        WHERE t.depth < 128
                    ),
                    headings AS (
                        SELECT
                            b.id,
                            b.root_id,
                            b.path,
                            b.sort,
                            b.created,
                            COALESCE(dt.order_key, '') AS heading_order_key,
                            ROW_NUMBER() OVER (
                                PARTITION BY b.root_id
                                ORDER BY COALESCE(dt.order_key, ''), b.created, b.id
                            ) AS heading_rank
                        FROM blocks b
                        LEFT JOIN doc_tree dt ON dt.id = b.id
                        WHERE b.type = 'h'
                          AND b.subtype = '${SettingsStore.data.taskHeadingLevel || 'h2'}'
                          AND b.root_id IN (SELECT DISTINCT root_id FROM task_roots)
                    ),
                    task_orders AS (
                        SELECT
                            tr.task_id,
                            tr.root_id,
                            COALESCE(dt.order_key, '') AS task_order_key
                        FROM task_roots tr
                        LEFT JOIN doc_tree dt ON dt.id = tr.task_id
                    ),
                    matched AS (
                        SELECT
                            t.task_id,
                            t.root_id,
                            h.id AS heading_id,
                            h.path AS heading_path,
                            h.sort AS heading_sort,
                            h.created AS heading_created,
                            h.heading_rank,
                            ROW_NUMBER() OVER (
                                PARTITION BY t.task_id
                                ORDER BY h.heading_order_key DESC, h.heading_rank DESC
                            ) AS rn
                        FROM task_orders t
                        LEFT JOIN headings h
                            ON h.root_id = t.root_id
                           AND h.heading_order_key <= t.task_order_key
                    )
                    SELECT
                        m.task_id,
                        m.root_id,
                        m.heading_id,
                        hb.content,
                        m.heading_path,
                        m.heading_sort,
                        m.heading_created,
                        m.heading_rank
                    FROM matched m
                    LEFT JOIN blocks hb ON hb.id = m.heading_id
                    WHERE m.rn = 1
                `;
                try {
                    const res = await this.call('/api/query/sql', { stmt: sql });
                    if (res.code === 0 && res.data) {
                        const rows = Array.isArray(res.data) ? res.data : [];
                        let headingOrderMap = new Map();
                        try {
                            const rootIds = Array.from(new Set(rows.map(r => String(r?.root_id || '').trim()).filter(Boolean)));
                            headingOrderMap = await this.fetchHeadingOrderByDocs(rootIds, SettingsStore.data.taskHeadingLevel || 'h2');
                        } catch (e) {
                            headingOrderMap = new Map();
                        }
                        rows.forEach(row => {
                            if (!contextMap.has(row.task_id)) {
                                const hid = String(row?.heading_id || '').trim();
                                if (!hid) return;
                                const did = String(row?.root_id || '').trim();
                                const rankByDocText = headingOrderMap.get(`${did}::${hid}`);
                                const rank = Number.isFinite(Number(rankByDocText)) ? Number(rankByDocText) : Number(row?.heading_rank);
                                contextMap.set(row.task_id, {
                                    id: hid,
                                    content: String(row?.content || '').trim(),
                                    path: String(row?.heading_path || '').trim(),
                                    sort: Number(row?.heading_sort),
                                    created: String(row?.heading_created || '').trim(),
                                    rank,
                                });
                            }
                        });
                    }
                } catch (e) {}

                // 强制对齐文档真实文本顺序：按 Kramdown 文本流映射“任务 -> 前置最近标题”
                try {
                    const lvRaw = String(SettingsStore.data.taskHeadingLevel || 'h2').trim().toLowerCase();
                    const lvNum0 = Number((lvRaw.match(/^h([1-6])$/) || [])[1]);
                    const lvNum = Number.isFinite(lvNum0) ? lvNum0 : 2;
                    const tasksByDoc = new Map();
                    batch.forEach((tid0) => {
                        const tid = String(tid0 || '').trim();
                        const rid = String(taskRootMap.get(tid) || '').trim();
                        if (!tid || !rid) return;
                        if (!tasksByDoc.has(rid)) tasksByDoc.set(rid, new Set());
                        tasksByDoc.get(rid).add(tid);
                    });
                    const parseIds = (line) => {
                        const out = [];
                        const s = String(line || '');
                        const re = /\bid="([^"]+)"/g;
                        let m;
                        while ((m = re.exec(s)) !== null) {
                            const id = String(m[1] || '').trim();
                            if (id) out.push(id);
                        }
                        return out;
                    };
                    const stripHeadingText = (line) => {
                        let s = String(line || '').replace(/^#{1,6}\s+/, '').trim();
                        s = s.replace(/\s*\{\:\s*[^}]*\}\s*$/, '').trim();
                        return s;
                    };
                    for (const [docId, tidSet] of tasksByDoc.entries()) {
                        let km = '';
                        try { km = await this.getBlockKramdown(docId); } catch (e) { km = ''; }
                        if (!km) continue;
                        const lines = String(km).split(/\r?\n/);
                        let headingRank = -1;
                        let currentHeading = null;
                        let pendingHeading = null;
                        for (let ln = 0; ln < lines.length; ln++) {
                            const line = String(lines[ln] || '');
                            const hm = line.match(/^(#{1,6})\s+(.*)$/);
                            if (hm && hm[1].length === lvNum) {
                                pendingHeading = {
                                    text: stripHeadingText(line),
                                    expires: ln + 4,
                                };
                                const idsInline = parseIds(line);
                                if (idsInline.length > 0) {
                                    headingRank += 1;
                                    currentHeading = {
                                        id: String(idsInline[0] || '').trim(),
                                        content: String(pendingHeading.text || '').trim(),
                                        rank: headingRank,
                                    };
                                    pendingHeading = null;
                                }
                            }
                            const ids = parseIds(line);
                            if (pendingHeading && ids.length > 0) {
                                headingRank += 1;
                                currentHeading = {
                                    id: String(ids[0] || '').trim(),
                                    content: String(pendingHeading.text || '').trim(),
                                    rank: headingRank,
                                };
                                pendingHeading = null;
                            }
                            if (pendingHeading && ln > Number(pendingHeading.expires || 0)) {
                                pendingHeading = null;
                            }
                            if (!ids.length || !currentHeading || !currentHeading.id) continue;
                            ids.forEach((bid) => {
                                const tid = String(bid || '').trim();
                                if (!tid || !tidSet.has(tid)) return;
                                contextMap.set(tid, {
                                    id: String(currentHeading.id || '').trim(),
                                    content: String(currentHeading.content || '').trim(),
                                    path: '',
                                    sort: Number.NaN,
                                    created: '',
                                    rank: Number(currentHeading.rank),
                                });
                            });
                        }
                    }
                } catch (e) {}
            }
            return contextMap;
        },

        async fetchTaskFlowRanks(taskIds) {
            const ids = Array.from(new Set((taskIds || []).map(x => String(x || '').trim()).filter(Boolean)));
            if (ids.length === 0) return new Map();
            const out = new Map();
            const escId = (s) => String(s || '').replace(/'/g, "''");
            const batchSize = 200;

            // 先按文档划分任务
            const tasksByDoc = new Map();
            for (let i = 0; i < ids.length; i += batchSize) {
                const batch = ids.slice(i, i + batchSize);
                const idList = batch.map(id => `'${escId(id)}'`).join(',');
                const sql = `
                    SELECT id AS task_id, root_id
                    FROM blocks
                    WHERE id IN (${idList})
                `;
                try {
                    const res = await this.call('/api/query/sql', { stmt: sql });
                    if (res.code === 0 && Array.isArray(res.data)) {
                        res.data.forEach((r) => {
                            const tid = String(r?.task_id || '').trim();
                            const docId = String(r?.root_id || '').trim();
                            if (!tid || !docId) return;
                            if (!tasksByDoc.has(docId)) tasksByDoc.set(docId, new Set());
                            tasksByDoc.get(docId).add(tid);
                        });
                    }
                } catch (e) {}
            }

            // 主路径：基于文档 kramdown 中 block id 的出现顺序，得到最稳定的文档流顺序
            for (const [docId, tidSet] of tasksByDoc.entries()) {
                let km = '';
                try { km = await this.getBlockKramdown(docId); } catch (e) { km = ''; }
                if (!km) continue;
                let rank = 0;
                const re = /\{\:\s*[^}]*\bid=(?:"([^"]+)"|'([^']+)')[^}]*\}/g;
                let m;
                while ((m = re.exec(String(km))) !== null) {
                    const bid = String(m?.[1] || m?.[2] || '').trim();
                    if (!bid || !tidSet.has(bid) || out.has(bid)) continue;
                    rank += 1;
                    out.set(bid, rank);
                }
            }

            // 回退：对于未在 kramdown 顺序中命中的任务，再用 SQL 递归顺序补齐
            const missing = ids.filter((id) => !out.has(id));
            for (let i = 0; i < missing.length; i += batchSize) {
                const batch = missing.slice(i, i + batchSize);
                if (batch.length === 0) continue;
                const idList = batch.map(id => `'${escId(id)}'`).join(',');
                const sql = `
                    WITH RECURSIVE task_roots AS (
                        SELECT id AS task_id, root_id
                        FROM blocks
                        WHERE id IN (${idList})
                    ),
                    doc_roots AS (
                        SELECT DISTINCT root_id
                        FROM task_roots
                    ),
                    doc_tree AS (
                        SELECT
                            d.id,
                            d.id AS root_id,
                            0 AS depth,
                            '' AS order_key
                        FROM blocks d
                        WHERE d.id IN (SELECT root_id FROM doc_roots)
                        UNION ALL
                        SELECT
                            b.id,
                            t.root_id,
                            t.depth + 1 AS depth,
                            (t.order_key || '/' ||
                                CASE
                                    WHEN TRIM(CAST(b.sort AS TEXT)) GLOB '[0-9]*' AND TRIM(CAST(b.sort AS TEXT)) != ''
                                        THEN ('0:' || printf('%020d', CAST(TRIM(CAST(b.sort AS TEXT)) AS INTEGER)))
                                    ELSE ('1:' || COALESCE(NULLIF(TRIM(CAST(b.sort AS TEXT)), ''), ''))
                                END
                                || ':' || b.id) AS order_key
                        FROM blocks b
                        INNER JOIN doc_tree t ON b.parent_id = t.id
                        WHERE t.depth < 128
                    ),
                    task_pos AS (
                        SELECT
                            tr.task_id,
                            tr.root_id,
                            COALESCE(dt.order_key, '') AS task_order_key
                        FROM task_roots tr
                        LEFT JOIN doc_tree dt ON dt.id = tr.task_id
                    )
                    SELECT
                        task_id,
                        ROW_NUMBER() OVER (
                            PARTITION BY root_id
                            ORDER BY task_order_key, task_id
                        ) AS task_rank
                    FROM task_pos
                `;
                try {
                    const res = await this.call('/api/query/sql', { stmt: sql });
                    if (res.code === 0 && Array.isArray(res.data)) {
                        res.data.forEach((r) => {
                            const tid = String(r?.task_id || '').trim();
                            const rank = Number(r?.task_rank);
                            if (!tid || !Number.isFinite(rank) || out.has(tid)) return;
                            out.set(tid, rank);
                        });
                    }
                } catch (e) {}
            }
            return out;
        },

        async fetchNearestCustomPriority(taskIds, maxDepth = 8) {
            const ids = Array.from(new Set((taskIds || []).map(x => String(x || '').trim()).filter(Boolean)));
            if (ids.length === 0) return new Map();
            const depth = Number.isFinite(Number(maxDepth)) ? Math.max(1, Math.min(20, Math.floor(Number(maxDepth)))) : 8;
            const escapeId = (s) => String(s).replace(/'/g, "''");
            const seeds = ids.map(id => `('${escapeId(id)}','${escapeId(id)}',0)`).join(',');
            const sql = `
                WITH RECURSIVE up(start_id, id, depth) AS (
                    VALUES ${seeds}
                    UNION ALL
                    SELECT up.start_id, b.parent_id, up.depth + 1
                    FROM blocks b
                    JOIN up ON b.id = up.id
                    WHERE up.depth < ${depth}
                      AND b.parent_id IS NOT NULL
                      AND b.parent_id != ''
                ),
                candidates AS (
                    SELECT
                        up.start_id,
                        a.value AS priority,
                        up.depth,
                        ROW_NUMBER() OVER (PARTITION BY up.start_id ORDER BY up.depth ASC) AS rn
                    FROM up
                    JOIN attributes a ON a.block_id = up.id
                    WHERE a.name = 'custom-priority'
                      AND a.value IS NOT NULL
                      AND a.value != ''
                )
                SELECT start_id, priority
                FROM candidates
                WHERE rn = 1
            `;
            const res = await this.call('/api/query/sql', { stmt: sql });
            const map = new Map();
            if (res.code === 0 && Array.isArray(res.data)) {
                res.data.forEach(row => {
                    const id = String(row?.start_id || '').trim();
                    const v = String(row?.priority || '').trim();
                    if (id && v) map.set(id, v);
                });
            }
            return map;
        },

        async setAttr(id, key, val) {
            const res = await this.call('/api/attr/setBlockAttrs', { 
                id: id, 
                attrs: { [`custom-${key}`]: String(val) } 
            });
            if (res.code !== 0) throw new Error(res.msg || '保存属性失败');
            return true;
        },

        async setAttrs(id, attrs) {
            const payload = {};
            try {
                Object.entries(attrs || {}).forEach(([k, v]) => {
                    if (!k) return;
                    payload[String(k)] = String(v ?? '');
                });
            } catch (e) {}
            const res = await this.call('/api/attr/setBlockAttrs', { id, attrs: payload });
            if (res.code !== 0) throw new Error(res.msg || '保存属性失败');
            return true;
        },

        async updateBlock(id, md, dataType = 'markdown') {
            const res = await this.call('/api/block/updateBlock', {
                id: id,
                data: md,
                dataType: dataType
            });
            if (res.code !== 0) {
                if (res.msg?.includes('not found')) {
                    throw new Error(`块 ${id.slice(-6)} 不存在`);
                }
                throw new Error(res.msg || '更新块失败');
            }
            const opId = this._getInsertedId(res);
            return { res, id: opId || id };
        },

        // 生成任务DOM（用于DOM模式更新，避免ID变化）
        generateTaskDOM(id, content, done = false) {
            // HTML转义内容，防止特殊字符导致DOM解析错误
            const escapedContent = String(content || '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
            // 使用思源正确的DOM格式
            const checkboxIcon = done
                ? '<svg><use xlink:href="#iconCheck"></use></svg>'
                : '<svg><use xlink:href="#iconUncheck"></use></svg>';
            const doneClass = done ? ' protyle-task--done' : '';
            // 正确的DOM结构：div.NodeList > div.NodeListItem > div.protyle-action + div.NodeParagraph
            return `<div data-type="NodeList" data-subtype="t">
<div data-type="NodeListItem" class="li${doneClass}" data-node-id="${id}">
  <div class="protyle-action protyle-action--task" draggable="true">${checkboxIcon}</div>
  <div data-type="NodeParagraph" class="p">
    <div contenteditable="true" spellcheck="false">${escapedContent}</div>
    <div class="protyle-attr" contenteditable="false"></div>
  </div>
  <div class="protyle-attr" contenteditable="false"></div>
</div>
</div>`;
        },

        _getInsertedId(res) {
            try {
                const ops = res?.data;
                const id = ops?.[0]?.doOperations?.[0]?.id;
                return id || null;
            } catch (e) {
                return null;
            }
        },

        async insertBlock(parentId, md, nextID) {
            const payload = { parentID: parentId, data: md, dataType: 'markdown' };
            if (nextID) payload.nextID = nextID;
            const res = await this.call('/api/block/insertBlock', payload);
            if (res.code !== 0) throw new Error(res.msg);
            const id = this._getInsertedId(res);
            if (!id) throw new Error('插入失败');
            return id;
        },

        async appendBlock(parentId, md) {
            const res = await this.call('/api/block/appendBlock', { parentID: parentId, data: md, dataType: 'markdown' });
            if (res.code !== 0) throw new Error(res.msg);
            const id = this._getInsertedId(res);
            if (!id) throw new Error('追加失败');
            return id;
        },

        async moveBlock(id, { previousID, parentID } = {}) {
            const pid = String(previousID || '');
            const par = String(parentID || '');
            if (!pid && !par) throw new Error('移动失败：缺少目标位置');
            const payload = { id };
            if (pid) payload.previousID = pid;
            if (par) payload.parentID = par;
            const res = await this.call('/api/block/moveBlock', payload);
            if (res.code !== 0) throw new Error(res.msg || '移动块失败');
            return true;
        },

        async getLastDirectChildIdOfDoc(docId) {
            const id = String(docId || '').trim();
            if (!id) return null;
            const sql = `SELECT id FROM blocks WHERE parent_id = '${id}' ORDER BY created DESC LIMIT 1`;
            const res = await this.call('/api/query/sql', { stmt: sql });
            if (res.code === 0 && res.data && res.data.length > 0) {
                const lastId = String(res.data[0]?.id || '').trim();
                if (lastId && lastId !== id) return lastId;
            }
            return null;
        },

        async getFirstDirectChildIdOfDoc(docId) {
            const id = String(docId || '').trim();
            if (!id) return null;
            const sql = `SELECT id FROM blocks WHERE parent_id = '${id}' ORDER BY created ASC LIMIT 1`;
            const res = await this.call('/api/query/sql', { stmt: sql });
            if (res.code === 0 && res.data && res.data.length > 0) {
                const firstId = String(res.data[0]?.id || '').trim();
                if (firstId && firstId !== id) return firstId;
            }
            return null;
        },

        async getFirstDirectChildListIdOfDoc(docId) {
            const id = String(docId || '').trim();
            if (!id) return null;
            const sql = `SELECT id FROM blocks WHERE parent_id = '${id}' AND type = 'l' ORDER BY created ASC LIMIT 1`;
            const res = await this.call('/api/query/sql', { stmt: sql });
            if (res.code === 0 && res.data && res.data.length > 0) {
                const listId = String(res.data[0]?.id || '').trim();
                if (listId) return listId;
            }
            return null;
        },

        async getBlockInfo(id) {
            const res = await this.call('/api/block/getBlockInfo', { id });
            if (res.code !== 0) throw new Error(res.msg);
            return res.data;
        },

        async getChildListIdOfTask(taskId) {
            const sql = `SELECT id FROM blocks WHERE parent_id = '${taskId}' AND type = 'l' LIMIT 1`;
            const res = await this.call('/api/query/sql', { stmt: sql });
            if (res.code === 0 && res.data && res.data.length > 0) return res.data[0].id || null;
            return null;
        },

        async getTaskIdsInList(listId) {
            const sql = `SELECT id FROM blocks WHERE parent_id = '${listId}' AND type = 'i' AND subtype = 't' ORDER BY created`;
            const res = await this.call('/api/query/sql', { stmt: sql });
            if (res.code === 0 && res.data) return res.data.map(r => r.id).filter(Boolean);
            return [];
        },

        async getFirstTaskIdUnderBlock(blockId) {
            const id = String(blockId || '').trim();
            if (!id) return null;
            const sql = `SELECT id FROM blocks WHERE parent_id = '${id}' AND type = 'i' AND subtype = 't' ORDER BY created ASC LIMIT 1`;
            const res = await this.call('/api/query/sql', { stmt: sql });
            if (res.code === 0 && res.data && res.data.length > 0) {
                const tid = String(res.data[0]?.id || '').trim();
                return tid || null;
            }
            return null;
        },

        async getFirstTaskDescendantId(blockId, maxDepth = 6) {
            const id = String(blockId || '').trim();
            const depth = Number.isFinite(Number(maxDepth)) ? Math.max(1, Math.min(20, Math.floor(Number(maxDepth)))) : 6;
            if (!id) return null;
            const sql = `
                WITH RECURSIVE tree(id, depth) AS (
                    SELECT '${id}' AS id, 0 AS depth
                    UNION ALL
                    SELECT b.id, t.depth + 1
                    FROM blocks b
                    JOIN tree t ON b.parent_id = t.id
                    WHERE t.depth < ${depth}
                )
                SELECT b.id
                FROM blocks b
                JOIN tree t ON t.id = b.id
                WHERE b.type = 'i' AND b.subtype = 't'
                ORDER BY t.depth ASC, b.created DESC
                LIMIT 1
            `;
            const res = await this.call('/api/query/sql', { stmt: sql });
            if (res.code === 0 && res.data && res.data.length > 0) {
                const tid = String(res.data[0]?.id || '').trim();
                return tid || null;
            }
            return null;
        },

        async getBlocksByIds(ids) {
            const list = Array.from(new Set((ids || []).map(x => String(x || '').trim()).filter(Boolean)));
            if (list.length === 0) return [];
            const quoted = list.map(id => `'${id.replace(/'/g, "''")}'`).join(',');
            const sql = `SELECT id, parent_id, type, subtype FROM blocks WHERE id IN (${quoted})`;
            const res = await this.call('/api/query/sql', { stmt: sql });
            if (res.code === 0 && Array.isArray(res.data)) return res.data;
            return [];
        },

        async deleteBlock(id) {
            const res = await this.call('/api/block/deleteBlock', { id: id });
            if (res.code !== 0) throw new Error(res.msg);
        }
    };

    const __tmMetaAttrMap = {
        priority: 'custom-priority',
        duration: 'custom-duration',
        remark: 'custom-remark',
        startDate: 'custom-start-date',
        completionTime: 'custom-completion-time',
        milestone: 'custom-milestone-event',
        customTime: 'custom-time',
        customStatus: 'custom-status',
        pinned: 'custom-pinned'
    };

    function __tmPersistMetaAndAttrs(id, patch) {
        if (!id || !patch || typeof patch !== 'object') return;
        MetaStore.set(id, patch);
        const attrs = {};
        Object.entries(patch).forEach(([key, val]) => {
            const attrKey = __tmMetaAttrMap[key];
            if (!attrKey) return;
            attrs[attrKey] = String(val ?? '');
        });
        if (Object.keys(attrs).length === 0) return;
        API.setAttrs(id, attrs).catch(e => {
        });
    }

    async function __tmPersistMetaAndAttrsAsync(id, patch) {
        if (!id || !patch || typeof patch !== 'object') return false;
        MetaStore.set(id, patch);
        const attrs = {};
        Object.entries(patch).forEach(([key, val]) => {
            const attrKey = __tmMetaAttrMap[key];
            if (!attrKey) return;
            attrs[attrKey] = String(val ?? '');
        });
        if (Object.keys(attrs).length === 0) return true;
        let lastErr = null;
        for (let i = 0; i < 3; i++) {
            try {
                await API.setAttrs(id, attrs);
                try { await API.call('/api/sqlite/flushTransaction', {}); } catch (e) {}
                try { await MetaStore.saveNow(); } catch (e) {}
                return true;
            } catch (e) {
                lastErr = e;
                await new Promise(r => setTimeout(r, 120 + i * 200));
            }
        }
        throw lastErr || new Error('保存属性失败');
    }
    let state = {
        // 数据状态
        taskTree: [],
        flatTasks: {},
        filteredTasks: [],
        doneOverrides: {},
        
        // UI状态
        modal: null,
        settingsModal: null,
        summaryModal: null,
        rulesModal: null,
        priorityModal: null,
        quickAddModal: null,
        quickAddDocPicker: null,
        quickAdd: null,
        viewMode: 'list',
        calendarDockDate: '',
        docTabsHidden: false,
        ganttView: {
            dayWidth: 24,
            paddingDays: 7,
        },

        // 筛选状态
        currentRule: null,
        filterRules: [],  // 从 SettingsStore 加载
        searchKeyword: '',

        // 操作状态
        isRefreshing: false,
        openToken: 0,

        // 设置（从 SettingsStore 读取）
        selectedDocIds: [],
        allDocuments: [],
        queryLimit: 500,
        groupByDocName: true,
        groupByTaskName: false,
        groupByTime: false,
        collapsedTaskIds: new Set(),
        timerFocusTaskId: '',
        
        // 统计信息
        stats: {
            totalTasks: 0,
            doneTasks: 0,
            todoTasks: 0,
            queryTime: 0,
            docCount: 0
        },
        
        // 规则编辑器状态
        editingRule: null,
        priorityScoreDraft: null,
        
        // 四象限分组状态
        quadrantEnabled: false,
        // 白板视图交互状态
        whiteboardLinkFromTaskId: '',
        whiteboardLinkFromDocId: '',
        whiteboardLinkPress: null,
        whiteboardLinkPreview: null,
        whiteboardLinkPointerFallback: null,
        whiteboardLinkHoverTaskId: '',
        whiteboardLinkHoverDocId: '',
        whiteboardSelectedLinkId: '',
        whiteboardSelectedLinkDocId: '',
        timelineLinkHoverTaskId: '',
        whiteboardSelectedTaskId: '',
        whiteboardSelectedNoteId: '',
        whiteboardMultiSelectedTaskIds: [],
        whiteboardMultiSelectedNoteIds: [],
        whiteboardMultiSelectedLinkKeys: [],
        whiteboardNoteEditor: null,
        whiteboardEdgeRafId: 0,
        whiteboardPanSession: null,
        whiteboardNodeDrag: null,
        whiteboardNoteDrag: null,
        whiteboardMarqueeSession: null,
        whiteboardSuppressClickUntil: 0,
        whiteboardPoolSelectedTaskIds: [],
        whiteboardPoolDragGhostEl: null,
        whiteboardDocFrameMap: {},
        whiteboardDocResize: null,
        whiteboardNoteClickTimer: 0,
        timelineDotPinnedTaskId: '',
        timelineMultiSelectedTaskIds: [],
        __tmTimelineRenderDeps: null,
    };

    let __tmMountEl = null;
    let __tmWakeReloadBound = false;
    let __tmWasHiddenAt = 0;
    let __tmWakeReloadTimer = null;
    let __tmWakeReloadInFlight = false;
    let __tmVisibilityHandler = null;
    let __tmFocusHandler = null;
    let __tmWhiteboardViewSaveTimer = null;

    function __tmSetMount(el) {
        if (el && !document.body.contains(el)) {
            // if element not attached yet, still allow mount
        }
        __tmMountEl = el || null;
    }

    function __tmFindBestTabRoot() {
        try {
            const all = Array.from(document.querySelectorAll('.tm-tab-root')).filter(el => !!el && document.body.contains(el));
            if (all.length === 0) return null;
            const isVisible = (el) => {
                try {
                    if (!el) return false;
                    const rect = el.getBoundingClientRect?.();
                    if (!rect) return false;
                    return rect.width > 0 && rect.height > 0;
                } catch (e) {
                    return false;
                }
            };
            const visible = all.filter(isVisible);
            return visible[visible.length - 1] || all[all.length - 1] || null;
        } catch (e) {
            return null;
        }
    }

    function __tmEnsureMount() {
        if (__tmMountEl && !document.body.contains(__tmMountEl)) {
            __tmMountEl = null;
        }
        try {
            if (globalThis.__taskHorizonTabElement && !document.body.contains(globalThis.__taskHorizonTabElement)) {
                globalThis.__taskHorizonTabElement = null;
            }
        } catch (e) {}
        if (!__tmMountEl && globalThis.__taskHorizonTabElement && document.body.contains(globalThis.__taskHorizonTabElement)) {
            __tmSetMount(globalThis.__taskHorizonTabElement);
        }
        if (!__tmMountEl) {
            const best = __tmFindBestTabRoot();
            if (best) {
                try { globalThis.__taskHorizonTabElement = best; } catch (e) {}
                __tmSetMount(best);
            }
        }
    }

    function __tmGetMountRoot() {
        __tmEnsureMount();
        return __tmMountEl || document.body;
    }

    // ===== 全局清理句柄 =====
    let __tmGlobalClickHandler = null;
    let __tmDomReadyHandler = null;
    let __tmBreadcrumbObserver = null;
    let __tmThemeModeObserver = null;
    let __tmTopBarTimer = null;
    let __tmMountRetryTimer = null;
    let __tmTopBarAdded = false;
    let __tmTopBarEl = null;
    let __tmTopBarClickCaptureHandler = null;
    let __tmTopBarClickInFlight = false;
    let __tmTomatoTimerHooked = false;
    let __tmTomatoOriginalTimerFns = null;
    let __tmTomatoAssociationListenerAdded = false;
    let __tmTomatoAssociationHandler = null;
    let __tmPinnedListenerAdded = false;
    let __tmQuickAddGlobalClickHandler = null;

    async function __tmSafeOpenManager(reason) {
        try {
            await openManager({ preserveViewMode: true });
        } catch (e) {
            try { console.error(`[OpenManager:${String(reason || '')}]`, e); } catch (e2) {}
            try { hint(`❌ 加载失败: ${e?.message || String(e)}`, 'error'); } catch (e3) {}
        }
    }

function __tmScheduleWakeReload(reason) {
    try { if (__tmWakeReloadTimer) clearTimeout(__tmWakeReloadTimer); } catch (e) {}
    __tmWakeReloadTimer = setTimeout(() => {
        __tmWakeReloadTimer = null;
        // 只刷新数据，不自动打开管理器
        __tmRefreshAfterWake(reason).catch(() => {});
    }, 350);
}

function __tmBuildCalendarWakeTaskSignature() {
    try {
        const flat = state && state.flatTasks && typeof state.flatTasks === 'object' ? state.flatTasks : {};
        const keys = Object.keys(flat).sort();
        const parts = [];
        for (const id of keys) {
            const t = flat[id];
            if (!t || typeof t !== 'object') continue;
            const tid = String(t.id || id || '').trim();
            if (!tid) continue;
            parts.push([
                tid,
                t.done ? '1' : '0',
                String(t.startDate || ''),
                String(t.completionTime || ''),
                String(t.updated || ''),
                String(t.content || '')
            ].join('|'));
        }
        return parts.join('||');
    } catch (e) {
        return '';
    }
}

// 新增：后台唤醒后只刷新数据，不自动跳转
async function __tmRefreshAfterWake(reason) {
    if (__tmWakeReloadInFlight) return;
    __tmWakeReloadInFlight = true;
    try {
        if (document.visibilityState === 'hidden') return;
        
        // 只有在管理器已经打开的情况下才刷新
        if (!state.modal || !document.body.contains(state.modal)) {
            return;
        }
        
        const best = __tmFindBestTabRoot();
        if (!best) return;
        
        try { globalThis.__taskHorizonTabElement = best; } catch (e) {}
        __tmSetMount(best);
        __tmEnsureMount();
        if (!__tmMountEl) return;
        const isCalendarView = String(state.viewMode || '').trim() === 'calendar';
        const prevCalendarSig = isCalendarView ? __tmBuildCalendarWakeTaskSignature() : '';
        
        // 静默刷新数据，不显示加载提示
        try { 
            await loadSelectedDocuments({ skipRender: true });
        } catch (e) {}

        try {
            await SettingsStore.load();
            const allow = new Set(['list', 'timeline', 'kanban', 'calendar', 'whiteboard']);
            const isMobileDevice = __tmIsMobileDevice();
            const current = String(state.viewMode || '').trim();
            if (!allow.has(current)) {
                const m0 = String(SettingsStore.data.defaultViewMode || 'list').trim();
                const m1 = (isMobileDevice && m0 === 'timeline') ? 'list' : m0;
                state.viewMode = allow.has(m1) ? m1 : 'list';
            }
            if (String(state.viewMode || '').trim() === 'calendar' && globalThis.__tmCalendar && typeof globalThis.__tmCalendar.refreshInPlace === 'function') {
                const nextCalendarSig = __tmBuildCalendarWakeTaskSignature();
                const changed = prevCalendarSig !== nextCalendarSig;
                if (changed) {
                    try { globalThis.__tmCalendar.refreshInPlace({ hard: true }); } catch (e2) {}
                } else {
                    try { globalThis.__tmCalendar.refreshInPlace({ layoutOnly: true, hard: true }); } catch (e2) {}
                }
            } else {
                try { render(); } catch (e2) {}
            }
        } catch (e) {}
        
    } finally {
        __tmWakeReloadInFlight = false;
    }
}


    function __tmBindWakeReload() {
        if (__tmWakeReloadBound) return;
        __tmWakeReloadBound = true;
        __tmVisibilityHandler = () => {
            try {
                if (document.visibilityState === 'hidden') {
                    __tmWasHiddenAt = Date.now();
                    // 标记页面曾被隐藏，用于下次打开时跳过加载提示
                    state.wasHidden = true;
                    return;
                }
                const gap = Date.now() - (__tmWasHiddenAt || 0);
				// 只有管理器已打开时才刷新，且不再自动打开
				if (__tmWasHiddenAt && gap > 10000 && state.modal && document.body.contains(state.modal)) {
					__tmScheduleWakeReload('visibility');
				}
			} catch (e) {}
		};
		__tmFocusHandler = () => {
			try {
				const gap = Date.now() - (__tmWasHiddenAt || 0);
				// 只有管理器已打开时才刷新
				if (__tmWasHiddenAt && gap > 10000 && state.modal && document.body.contains(state.modal)) {
					__tmScheduleWakeReload('focus');
				}
            } catch (e) {}
        };
        try { document.addEventListener('visibilitychange', __tmVisibilityHandler); } catch (e) {}
        try { window.addEventListener('focus', __tmFocusHandler); } catch (e) {}
    }

    function __tmHookTomatoTimer() {
        if (__tmTomatoTimerHooked) return;
        const timer = globalThis.__tomatoTimer;
        if (!timer || typeof timer !== 'object') return;
        if (!__tmTomatoOriginalTimerFns) __tmTomatoOriginalTimerFns = {};
        const wrap = (name) => {
            const current = timer[name];
            if (typeof current !== 'function') return;
            if (current.__tmWrapped) return;
            if (!__tmTomatoOriginalTimerFns[name]) __tmTomatoOriginalTimerFns[name] = current;
            const original = __tmTomatoOriginalTimerFns[name];
            if (typeof original !== 'function') return;
            const wrapped = function(...args) {
                const res = original.apply(this, args);
                try {
                    state.timerFocusTaskId = '';
                    if (state.modal && document.body.contains(state.modal)) render();
                } catch (e) {}
                return res;
            };
            wrapped.__tmWrapped = true;
            try { timer[name] = wrapped; } catch (e) {}
        };
        [
            'clearTaskAssociation',
            'clearAssociation',
            'clearTask',
            'clearCurrentTask',
            'unbindTask',
            'stop',
            'reset',
        ].forEach(wrap);
        __tmTomatoTimerHooked = true;
    }

    function __tmListenTomatoAssociationCleared() {
        if (__tmTomatoAssociationListenerAdded) return;
        __tmTomatoAssociationHandler = () => {
            try {
                state.timerFocusTaskId = '';
                if (state.modal && document.body.contains(state.modal)) render();
            } catch (e) {}
        };
        try { window.addEventListener('tomato:association-cleared', __tmTomatoAssociationHandler); } catch (e) {}
        globalThis.__taskHorizonOnTomatoAssociationCleared = () => {
            try {
                state.timerFocusTaskId = '';
                if (state.modal && document.body.contains(state.modal)) render();
            } catch (e) {}
        };
        __tmTomatoAssociationListenerAdded = true;
    }

    function __tmListenPinnedChanged() {
        if (__tmPinnedListenerAdded) return;
        globalThis.__taskHorizonOnPinnedChanged = (taskId, pinned) => {
            try {
                const id = String(taskId || '').trim();
                if (!id) return;
                const task = state.flatTasks?.[id];
                if (!task) return;
                const val = !!pinned;
                task.pinned = val;
                try { MetaStore.set(id, { pinned: val }); } catch (e) {}
                try { applyFilters(); } catch (e) {}
                if (state.modal && document.body.contains(state.modal)) render();
            } catch (e) {}
        };
        __tmPinnedListenerAdded = true;
    }

    function esc(s) {
        const d = document.createElement('div');
        d.textContent = s;
        return d.innerHTML;
    }

    function __tmCompareTasksByDocFlow(a, b) {
        const qa = Number(a?.docSeq);
        const qb = Number(b?.docSeq);
        if (Number.isFinite(qa) && Number.isFinite(qb) && qa !== qb) return qa - qb;
        const pa = String(a?.blockPath || '').trim();
        const pb = String(b?.blockPath || '').trim();
        if (pa && pb && pa !== pb) return pa.localeCompare(pb);
        if (pa && !pb) return -1;
        if (!pa && pb) return 1;
        const sa = Number(a?.blockSort);
        const sb = Number(b?.blockSort);
        if (Number.isFinite(sa) && Number.isFinite(sb) && sa !== sb) return sa - sb;
        const ssa = String(a?.blockSort || '').trim();
        const ssb = String(b?.blockSort || '').trim();
        if (ssa && ssb && ssa !== ssb) return ssa.localeCompare(ssb);
        if (ssa && !ssb) return -1;
        if (!ssa && ssb) return 1;
        const ca = String(a?.created || '');
        const cb = String(b?.created || '');
        if (ca !== cb) return ca.localeCompare(cb);
        return String(a?.id || '').localeCompare(String(b?.id || ''));
    }

    function __tmGetDocHeadingBucket(task, noHeadingLabel) {
        const noneLabel = String(noHeadingLabel || '').trim() || '无标题';
        const raw = String(task?.h2 || '').trim();
        const label = raw || noneLabel;
        const hid = String(task?.h2Id || '').trim();
        if (hid) return { key: `id:${hid}`, label, id: hid };
        const hrank0 = Number(task?.h2Rank);
        if (Number.isFinite(hrank0)) return { key: `rank:${Math.trunc(hrank0)}`, label, id: '' };
        const hpath = String(task?.h2Path || '').trim();
        const hsort0 = Number(task?.h2Sort);
        const hsort = Number.isFinite(hsort0) ? String(Math.trunc(hsort0)) : '';
        const hcreated = String(task?.h2Created || '').trim();
        if (hpath || hsort || hcreated) {
            return { key: `pos:${hpath}|${hsort}|${hcreated}`, label, id: '' };
        }
        return { key: `label:${label}`, label, id: '' };
    }

    function __tmBuildDocHeadingBuckets(tasks, noHeadingLabel) {
        const list = Array.isArray(tasks) ? tasks : [];
        const buckets = [];
        const seen = new Set();
        const cmpHeadingPos = (a, b) => {
            const ra = Number(a?.h2Rank);
            const rb = Number(b?.h2Rank);
            const raOk = Number.isFinite(ra);
            const rbOk = Number.isFinite(rb);
            if (raOk && rbOk && ra !== rb) return ra - rb;
            if (raOk && !rbOk) return -1;
            if (!raOk && rbOk) return 1;
            const aHas = !!String(a?.h2Id || '').trim();
            const bHas = !!String(b?.h2Id || '').trim();
            if (aHas && !bHas) return -1;
            if (!aHas && bHas) return 1;
            if (aHas && bHas) {
                const pa = String(a?.h2Path || '').trim();
                const pb = String(b?.h2Path || '').trim();
                if (pa && pb && pa !== pb) return pa.localeCompare(pb);
                const sa = Number(a?.h2Sort);
                const sb = Number(b?.h2Sort);
                if (Number.isFinite(sa) && Number.isFinite(sb) && sa !== sb) return sa - sb;
                const ca = String(a?.h2Created || '').trim();
                const cb = String(b?.h2Created || '').trim();
                if (ca !== cb) return ca.localeCompare(cb);
                const ia = String(a?.h2Id || '').trim();
                const ib = String(b?.h2Id || '').trim();
                if (ia !== ib) return ia.localeCompare(ib);
            }
            return __tmCompareTasksByDocFlow(a, b);
        };
        list
            .slice()
            .sort(cmpHeadingPos)
            .forEach((task) => {
                const b = __tmGetDocHeadingBucket(task, noHeadingLabel);
                if (!b || seen.has(b.key)) return;
                seen.add(b.key);
                buckets.push(b);
            });
        return buckets;
    }

    function __tmBuildDocHeadingOrder(tasks, noHeadingLabel) {
        return __tmBuildDocHeadingBuckets(tasks, noHeadingLabel).map((b) => String(b?.label || ''));
    }

    function __tmSafeAttrName(name, fallback) {
        const f = String(fallback || '').trim() || 'custom-tomato-minutes';
        const s = String(name || '').trim() || f;
        if (!/^custom-[a-zA-Z0-9_-]+$/.test(s)) return f;
        return s;
    }

    function __tmParseNumber(value) {
        const s = String(value ?? '').trim();
        if (!s) return Number.NaN;
        const m = s.match(/-?\d+(?:\.\d+)?/);
        if (!m) return Number.NaN;
        return Number(m[0]);
    }

    const __tmIsMobileDevice = () => {
        try {
            if (window.siyuan?.config?.isMobile !== undefined) return !!window.siyuan.config.isMobile;
        } catch (e) {}
        const ua = navigator.userAgent || '';
        return /Mobile|Android|iPhone|iPad|iPod/i.test(ua) || (window.innerWidth || 0) <= 768;
    };

    const __tmGetFontSize = () => {
        const base = SettingsStore.data.fontSize || 14;
        const mobileSize = SettingsStore.data.fontSizeMobile || base;
        return __tmIsMobileDevice() ? mobileSize : base;
    };

    const __tmApplyRowHeightVars = () => {
        const px = Number(SettingsStore.data.rowHeightPx);
        if (Number.isFinite(px) && px > 0) {
            try { document.documentElement.style.setProperty('--tm-row-height', `${Math.round(px)}px`); } catch (e) {}
            return;
        }
        try { document.documentElement.style.removeProperty('--tm-row-height'); } catch (e) {}
        const mode = String(SettingsStore.data.rowHeightMode || 'auto').trim() || 'auto';
        const presets = {
            auto: { scale: 1.35, offset: 14, min: 28, max: 48 },
            compact: { scale: 1.25, offset: 12, min: 24, max: 42 },
            normal: { scale: 1.5, offset: 16, min: 32, max: 56 },
            comfortable: { scale: 1.75, offset: 20, min: 38, max: 64 },
        };
        const p = presets[mode] || presets.auto;
        try { document.documentElement.style.setProperty('--tm-row-height-scale', String(p.scale)); } catch (e) {}
        try { document.documentElement.style.setProperty('--tm-row-height-offset', `${p.offset}px`); } catch (e) {}
        try { document.documentElement.style.setProperty('--tm-row-height-min', `${p.min}px`); } catch (e) {}
        try { document.documentElement.style.setProperty('--tm-row-height-max', `${p.max}px`); } catch (e) {}
    };

    const __tmIsDarkMode = () => {
        try {
            return String(document.documentElement.getAttribute('data-theme-mode') || '').toLowerCase() === 'dark';
        } catch (e) {
            return false;
        }
    };

    function __tmClamp(n, min, max) {
        const v = Number(n);
        if (!Number.isFinite(v)) return min;
        return Math.min(max, Math.max(min, v));
    }

    function __tmNormalizeHexColor(input, fallback) {
        const s = String(input || '').trim();
        if (/^#[0-9a-fA-F]{6}$/.test(s)) return s.toLowerCase();
        const f = String(fallback || '').trim();
        if (/^#[0-9a-fA-F]{6}$/.test(f)) return f.toLowerCase();
        return '';
    }

    function __tmHexToRgb(hex) {
        const h = __tmNormalizeHexColor(hex, '');
        if (!h) return null;
        const r = parseInt(h.slice(1, 3), 16);
        const g = parseInt(h.slice(3, 5), 16);
        const b = parseInt(h.slice(5, 7), 16);
        if (![r, g, b].every((x) => Number.isFinite(x))) return null;
        return { r, g, b };
    }

    function __tmRgbToHex(rgb) {
        const r = __tmClamp(rgb?.r, 0, 255);
        const g = __tmClamp(rgb?.g, 0, 255);
        const b = __tmClamp(rgb?.b, 0, 255);
        const to2 = (n) => Math.round(n).toString(16).padStart(2, '0');
        return `#${to2(r)}${to2(g)}${to2(b)}`.toLowerCase();
    }

    function __tmMixRgb(a, b, t) {
        const x = __tmClamp(t, 0, 1);
        return {
            r: Math.round((a.r || 0) + ((b.r || 0) - (a.r || 0)) * x),
            g: Math.round((a.g || 0) + ((b.g || 0) - (a.g || 0)) * x),
            b: Math.round((a.b || 0) + ((b.b || 0) - (a.b || 0)) * x),
        };
    }

    function __tmHslToRgb(h, s, l) {
        const hh = ((Number(h) % 360) + 360) % 360;
        const ss = __tmClamp(s, 0, 100) / 100;
        const ll = __tmClamp(l, 0, 100) / 100;
        const c = (1 - Math.abs(2 * ll - 1)) * ss;
        const x = c * (1 - Math.abs(((hh / 60) % 2) - 1));
        const m = ll - c / 2;
        let r1 = 0, g1 = 0, b1 = 0;
        if (hh < 60) { r1 = c; g1 = x; b1 = 0; }
        else if (hh < 120) { r1 = x; g1 = c; b1 = 0; }
        else if (hh < 180) { r1 = 0; g1 = c; b1 = x; }
        else if (hh < 240) { r1 = 0; g1 = x; b1 = c; }
        else if (hh < 300) { r1 = x; g1 = 0; b1 = c; }
        else { r1 = c; g1 = 0; b1 = x; }
        return {
            r: Math.round((r1 + m) * 255),
            g: Math.round((g1 + m) * 255),
            b: Math.round((b1 + m) * 255),
        };
    }

    function __tmHash32(str) {
        const s = String(str || '');
        let h = 2166136261;
        for (let i = 0; i < s.length; i++) {
            h ^= s.charCodeAt(i);
            h = Math.imul(h, 16777619);
        }
        return h >>> 0;
    }

    function __tmAutoDocColor(docId, isDark) {
        const seed = Number(SettingsStore?.data?.docColorSeed) || 1;
        const h0 = __tmHash32(`${String(docId || '')}:${String(seed)}`);
        const hue = h0 % 360;
        const sat = (isDark ? 58 : 62) + ((h0 >>> 8) % 16);
        const light = (isDark ? 58 : 42) + ((h0 >>> 16) % (isDark ? 12 : 14));
        return __tmRgbToHex(__tmHslToRgb(hue, sat, light));
    }

    function __tmThemeAdjustHex(hex, isDark) {
        const rgb = __tmHexToRgb(hex);
        if (!rgb) return __tmNormalizeHexColor(hex, '#6ba5ff') || '#6ba5ff';
        const lum = (0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b) / 255;
        if (isDark) {
            if (lum < 0.42) return __tmRgbToHex(__tmMixRgb(rgb, { r: 255, g: 255, b: 255 }, __tmClamp((0.52 - lum) * 1.2, 0.12, 0.55)));
            return __tmRgbToHex(rgb);
        }
        if (lum > 0.78) return __tmRgbToHex(__tmMixRgb(rgb, { r: 0, g: 0, b: 0 }, __tmClamp((lum - 0.72) * 1.1, 0.10, 0.55)));
        return __tmRgbToHex(rgb);
    }

    const __tmDocProgressCache = new Map();

    window.__tmUpdateDocTabProgress = async (docId, elId, color) => {
        const el = document.getElementById(elId);
        if (!el) return;
        
        // 1. 优先使用缓存
        if (__tmDocProgressCache.has(docId)) {
            const cachedPercent = __tmDocProgressCache.get(docId);
            el.style.width = `${cachedPercent}%`;
        }

        const sql = `SELECT 
            (SELECT count(*) FROM blocks WHERE root_id = '${docId}' AND type='i' AND subtype='t') as total,
            (SELECT count(*) FROM blocks WHERE root_id = '${docId}' AND type='i' AND subtype='t' AND markdown LIKE '%[x]%') as completed`;
        
        let data;
        try {
            const res = await fetch("/api/query/sql", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ stmt: sql }),
            }).then(r => r.json());
            data = res.data?.[0];
        } catch (e) { return; }
        
        if (!data) return;
        const total = Number(data.total) || 0;
        const completed = Number(data.completed) || 0;
        let percent = 0;
        if (total > 0) {
            percent = Math.min(100, Math.max(0, Math.round((completed / total) * 100)));
        }
        
        // 2. 更新缓存和 DOM
        if (__tmDocProgressCache.get(docId) !== percent) {
            __tmDocProgressCache.set(docId, percent);
            el.style.width = `${percent}%`;
        }
    };

    function __tmGetDocColorHex(docId, isDark) {
        const id = String(docId || '').trim();
        const map = (SettingsStore?.data?.docColorMap && typeof SettingsStore.data.docColorMap === 'object') ? SettingsStore.data.docColorMap : null;
        const raw = map ? __tmNormalizeHexColor(map[id], '') : '';
        if (raw) return __tmThemeAdjustHex(raw, isDark);
        return __tmAutoDocColor(id, isDark);
    }

    function __tmDarkenHex(hex, amount) {
        const rgb = __tmHexToRgb(hex);
        if (!rgb) return __tmNormalizeHexColor(hex, '#6ba5ff') || '#6ba5ff';
        const t = __tmClamp(amount, 0, 1);
        return __tmRgbToHex(__tmMixRgb(rgb, { r: 0, g: 0, b: 0 }, t));
    }

    function __tmDesaturateHex(hex, amount) {
        const rgb = __tmHexToRgb(hex);
        if (!rgb) return __tmNormalizeHexColor(hex, '#6ba5ff') || '#6ba5ff';
        const t = __tmClamp(amount, 0, 1);
        const g = Math.round(0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b);
        return __tmRgbToHex(__tmMixRgb(rgb, { r: g, g: g, b: g }, t));
    }

    function __tmParseCssColorToRgba(input) {
        const s0 = String(input || '').trim();
        if (!s0) return null;
        if (s0.startsWith('var(')) {
            const m = /^var\(\s*(--[a-zA-Z0-9\-_]+)\s*\)$/.exec(s0);
            if (!m) return null;
            const varName = m[1];
            const v = String(getComputedStyle(document.documentElement).getPropertyValue(varName) || '').trim();
            return __tmParseCssColorToRgba(v);
        }
        const hex = __tmNormalizeHexColor(s0, '');
        if (hex) {
            const rgb = __tmHexToRgb(hex);
            return rgb ? { ...rgb, a: 1 } : null;
        }
        const rgbm = /^rgba?\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)(?:\s*,\s*([0-9.]+)\s*)?\)$/.exec(s0);
        if (rgbm) {
            const r = __tmClamp(Number(rgbm[1]), 0, 255);
            const g = __tmClamp(Number(rgbm[2]), 0, 255);
            const b = __tmClamp(Number(rgbm[3]), 0, 255);
            const a = rgbm[4] === undefined ? 1 : __tmClamp(Number(rgbm[4]), 0, 1);
            return { r, g, b, a };
        }
        return null;
    }

    function __tmGroupBgFromLabelColor(colorStr, isDark) {
        const rgba = __tmParseCssColorToRgba(colorStr);
        if (!rgba) return '';
        const alpha0 = __tmClamp(Number(rgba.a ?? 1), 0, 1);
        const g = Math.round(0.299 * rgba.r + 0.587 * rgba.g + 0.114 * rgba.b);
        const mixBase = isDark ? 0.42 : 0.34;
        const mixExtra = (1 - alpha0) * (isDark ? 0.18 : 0.22);
        const mix = __tmClamp(mixBase + mixExtra, 0, 0.9);
        const soft = __tmMixRgb(rgba, { r: g, g: g, b: g }, mix);
        const baseA = isDark ? 0.22 : 0.10;
        const a = baseA * alpha0;
        return `rgba(${soft.r}, ${soft.g}, ${soft.b}, ${a})`;
    }

    function __tmWithAlpha(hex, alpha) {
        const rgb = __tmHexToRgb(hex);
        if (!rgb) return String(hex || '').trim();
        const a = __tmClamp(alpha, 0, 1);
        return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${a})`;
    }

    function __tmRemoveElementsById(...ids) {
        try {
            ids.forEach((id) => {
                const el = document.getElementById(String(id || '').trim());
                if (el) el.remove();
            });
        } catch (e) {}
    }

    function __tmCancelAnimationsWithin(rootEl) {
        const root = rootEl instanceof Element ? rootEl : null;
        if (!root) return;
        const list = root.querySelectorAll('tr[data-id],tr[data-group-key],.tm-gantt-row[data-id],.tm-gantt-row--group[data-group-key]');
        list.forEach((el) => {
            try {
                const anims = el.getAnimations?.() || [];
                anims.forEach((a) => {
                    try { a.cancel(); } catch (e2) {}
                });
            } catch (e) {}
        });
    }

    function __tmResetFlipState(modalEl) {
        const root = modalEl instanceof Element ? modalEl : state.modal;
        try { if (root) __tmCancelAnimationsWithin(root); } catch (e) {}
        try {
            const a = state.__tmFlipRunningAnims;
            if (Array.isArray(a)) {
                a.forEach((x) => { try { x?.cancel?.(); } catch (e2) {} });
                a.length = 0;
            }
        } catch (e) {}
        state.__tmFlipFirst = null;
        state.__tmFlipAction = null;
        state.__tmFlipTs = Date.now();
    }

    function __tmUpdateToggleGlyphInDom(opts) {
        const o = (opts && typeof opts === 'object') ? opts : {};
        const kind = String(o.kind || '');
        const key = String(o.key || '').trim();
        const action = String(o.action || '');
        if (!key) return;
        const modal = state.modal;
        if (!modal) return;
        const glyph = action === 'collapse' ? '▸' : action === 'expand' ? '▾' : '';
        if (!glyph) return;
        if (kind === 'task') {
            const row = modal.querySelector(`#tmTaskTable tbody tr[data-id="${CSS.escape(key)}"],#tmTimelineLeftTable tbody tr[data-id="${CSS.escape(key)}"]`);
            const t = row?.querySelector?.('.tm-tree-toggle');
            if (t) t.textContent = glyph;
            return;
        }
        if (kind === 'group') {
            const row = modal.querySelector(`#tmTaskTable tbody tr[data-group-key="${CSS.escape(key)}"],#tmTimelineLeftTable tbody tr[data-group-key="${CSS.escape(key)}"]`);
            const t = row?.querySelector?.('.tm-group-toggle');
            if (t) t.textContent = glyph;
        }
    }

    function __tmScheduleCollapseRerender() {
        try {
            const id0 = Number(state.__tmCollapseRafId) || 0;
            if (id0) cancelAnimationFrame(id0);
        } catch (e) {}
        try {
            state.__tmCollapseRafId = requestAnimationFrame(() => {
                state.__tmCollapseRafId = 0;
                if (!__tmRerenderCollapseInPlace()) render();
            });
        } catch (e) {
            if (!__tmRerenderCollapseInPlace()) render();
        }
    }

    function __tmGetActiveTbody(modalEl) {
        const modal = modalEl instanceof Element ? modalEl : state.modal;
        if (!modal) return null;
        if (state.viewMode === 'timeline') return modal.querySelector('#tmTimelineLeftTable tbody');
        return modal.querySelector('#tmTaskTable tbody');
    }

    function __tmApplyVisibilityFromState(modalEl) {
        const modal = modalEl instanceof Element ? modalEl : state.modal;
        if (!modal) return false;
        const tbody = __tmGetActiveTbody(modal);
        if (!tbody) return false;
        const collapsedTaskIds = state.collapsedTaskIds instanceof Set ? state.collapsedTaskIds : new Set();
        const collapsedGroups = state.collapsedGroups instanceof Set ? state.collapsedGroups : new Set();
        const getGroupLevel = (groupKey) => {
            const k = String(groupKey || '').trim();
            if (!k) return 0;
            if (k.includes('__h2_')) return 1;
            return 0;
        };

        const leftRows = tbody.querySelectorAll('tr');
        const groupStack = [];
        let collapsedAncestorDepth = null;

        leftRows.forEach((row) => {
            if (!(row instanceof Element)) return;
            if (row.matches('tr[data-group-key]')) {
                const gk = String(row.getAttribute('data-group-key') || '').trim();
                const level = getGroupLevel(gk);
                while (groupStack.length > 0 && groupStack[groupStack.length - 1].level >= level) {
                    groupStack.pop();
                }
                const parentCollapsed = groupStack.some(it => !!it.collapsed);
                const selfCollapsed = !!(gk && collapsedGroups.has(gk));
                const effectiveCollapsed = parentCollapsed || selfCollapsed;
                groupStack.push({ level, collapsed: effectiveCollapsed });
                row.style.display = parentCollapsed ? 'none' : '';
                collapsedAncestorDepth = null;
                return;
            }
            if (!row.matches('tr[data-id]')) return;
            const id = String(row.getAttribute('data-id') || '').trim();
            const d = Number(row.getAttribute('data-depth')) || 0;
            while (collapsedAncestorDepth !== null && d <= collapsedAncestorDepth) collapsedAncestorDepth = null;
            const groupCollapsed = groupStack.some(it => !!it.collapsed);
            const hide = groupCollapsed || collapsedAncestorDepth !== null;
            row.style.display = hide ? 'none' : '';
            row.style.visibility = '';
            row.style.pointerEvents = '';
            if (id) {
                const toggleEl = row.querySelector('.tm-tree-toggle');
                const hasToggle = !!toggleEl;
                const isCollapsed = hasToggle && collapsedTaskIds.has(id);
                if (hasToggle && toggleEl) toggleEl.textContent = isCollapsed ? '▸' : '▾';
                if (!hide && isCollapsed) collapsedAncestorDepth = d;
            }
        });

        if (state.viewMode !== 'timeline') return true;

        const ganttBody = modal.querySelector('#tmGanttBody');
        if (!ganttBody) return true;
        const rightRows = ganttBody.querySelectorAll('.tm-gantt-row,.tm-gantt-row--group');
        const n = Math.min(leftRows.length, rightRows.length);
        for (let i = 0; i < n; i++) {
            const lr = leftRows[i];
            const rr = rightRows[i];
            if (!(lr instanceof Element) || !(rr instanceof Element)) continue;
            const disp = lr.style.display || '';
            rr.style.display = disp;
        }

        const syncRowHeightsOnce = () => {
            if (Date.now() - (Number(state.__tmFlipTs) || 0) < 240) return;
            const n2 = Math.min(leftRows.length, rightRows.length);
            for (let i = 0; i < n2; i++) {
                const lr = leftRows[i];
                const rr = rightRows[i];
                if (!(lr instanceof Element) || !(rr instanceof Element)) continue;
                if ((lr.style.display || '') === 'none') continue;
                const h = lr.getBoundingClientRect?.().height;
                if (!Number.isFinite(h) || h <= 0) continue;
                rr.style.height = `${h}px`;
                rr.style.minHeight = `${h}px`;
                rr.style.maxHeight = `${h}px`;
                const bar = rr.querySelector?.('.tm-gantt-bar');
                if (bar) {
                    bar.style.top = '50%';
                    bar.style.transform = 'translateY(-50%)';
                }
            }
        };
        try {
            requestAnimationFrame(() => {
                syncRowHeightsOnce();
                if (leftRows.length <= 400) {
                    setTimeout(syncRowHeightsOnce, 60);
                    setTimeout(syncRowHeightsOnce, 260);
                }
            });
        } catch (e) {}

        return true;
    }

    function __tmGetFlipKeyForEl(el) {
        if (!(el instanceof Element)) return '';
        const isGanttRow = !!(el.classList?.contains('tm-gantt-row') || el.classList?.contains('tm-gantt-row--group'));
        const prefix = isGanttRow ? 'gantt' : 'table';
        const id = String(el.getAttribute('data-id') || '').trim();
        if (id) return `${prefix}:task:${id}`;
        const gk = String(el.getAttribute('data-group-key') || '').trim();
        if (gk) return `${prefix}:group:${gk}`;
        return '';
    }

    function __tmCaptureFlipSnapshot(modalEl) {
        const root = modalEl instanceof Element ? modalEl : state.modal;
        if (!root) return new Map();
        const list = root.querySelectorAll('tr[data-id],tr[data-group-key],.tm-gantt-row[data-id],.tm-gantt-row--group[data-group-key]');
        const m = new Map();
        list.forEach((el) => {
            const k = __tmGetFlipKeyForEl(el);
            if (!k) return;
            try {
                const r = el.getBoundingClientRect();
                if (!r || r.height <= 0 || r.width <= 0) return;
                m.set(k, r);
            } catch (e) {}
        });
        return m;
    }

    function __tmCollectAffectedRowsForCollapse(containerEl, opts) {
        const container = containerEl instanceof Element ? containerEl : null;
        const o = (opts && typeof opts === 'object') ? opts : {};
        const kind = String(o.kind || '');
        const key = String(o.key || '').trim();
        if (!container || !key) return [];
        const anchor = kind === 'group'
            ? container.querySelector(`tr[data-group-key="${CSS.escape(key)}"]`)
            : container.querySelector(`tr[data-id="${CSS.escape(key)}"]`);
        if (!anchor) return [];

        const out = [];
        if (kind === 'group') {
            let n = anchor.nextElementSibling;
            while (n) {
                if (n instanceof Element && n.matches('tr[data-group-key]')) break;
                if (n instanceof Element && n.matches('tr[data-id]')) out.push(n);
                n = n.nextElementSibling;
            }
            return out;
        }

        const baseDepth = Number(anchor.getAttribute('data-depth')) || 0;
        let n = anchor.nextElementSibling;
        while (n) {
            if (!(n instanceof Element)) break;
            if (n.matches('tr[data-group-key]')) break;
            const d = Number(n.getAttribute('data-depth'));
            if (!Number.isFinite(d) || d <= baseDepth) break;
            if (n.matches('tr[data-id]')) out.push(n);
            n = n.nextElementSibling;
        }
        return out;
    }

    function __tmCountAffectedRowsForCollapse(containerEl, opts, stopAfter = Infinity) {
        const container = containerEl instanceof Element ? containerEl : null;
        const o = (opts && typeof opts === 'object') ? opts : {};
        const kind = String(o.kind || '');
        const key = String(o.key || '').trim();
        if (!container || !key) return 0;
        const anchor = kind === 'group'
            ? container.querySelector(`tr[data-group-key="${CSS.escape(key)}"]`)
            : container.querySelector(`tr[data-id="${CSS.escape(key)}"]`);
        if (!anchor) return 0;

        let count = 0;
        if (kind === 'group') {
            let n = anchor.nextElementSibling;
            while (n) {
                if (n instanceof Element && n.matches('tr[data-group-key]')) break;
                if (n instanceof Element && n.matches('tr[data-id]')) {
                    count++;
                    if (count >= stopAfter) break;
                }
                n = n.nextElementSibling;
            }
            return count;
        }

        const baseDepth = Number(anchor.getAttribute('data-depth')) || 0;
        let n = anchor.nextElementSibling;
        while (n) {
            if (!(n instanceof Element)) break;
            if (n.matches('tr[data-group-key]')) break;
            const d = Number(n.getAttribute('data-depth'));
            if (!Number.isFinite(d) || d <= baseDepth) break;
            if (n.matches('tr[data-id]')) {
                count++;
                if (count >= stopAfter) break;
            }
            n = n.nextElementSibling;
        }
        return count;
    }

    function __tmCollectAffectedRowsForCollapseLimited(containerEl, opts, limit = 0) {
        const rows = [];
        const cap = Math.max(0, Number(limit) || 0);
        if (cap <= 0) return { rows, count: 0, truncated: false };
        const container = containerEl instanceof Element ? containerEl : null;
        const o = (opts && typeof opts === 'object') ? opts : {};
        const kind = String(o.kind || '');
        const key = String(o.key || '').trim();
        if (!container || !key) return { rows, count: 0, truncated: false };
        const anchor = kind === 'group'
            ? container.querySelector(`tr[data-group-key="${CSS.escape(key)}"]`)
            : container.querySelector(`tr[data-id="${CSS.escape(key)}"]`);
        if (!anchor) return { rows, count: 0, truncated: false };

        let count = 0;
        let truncated = false;
        if (kind === 'group') {
            let n = anchor.nextElementSibling;
            while (n) {
                if (n instanceof Element && n.matches('tr[data-group-key]')) break;
                if (n instanceof Element && n.matches('tr[data-id]')) {
                    count++;
                    if (rows.length < cap) rows.push(n);
                    else truncated = true;
                }
                n = n.nextElementSibling;
            }
            return { rows, count, truncated };
        }

        const baseDepth = Number(anchor.getAttribute('data-depth')) || 0;
        let n = anchor.nextElementSibling;
        while (n) {
            if (!(n instanceof Element)) break;
            if (n.matches('tr[data-group-key]')) break;
            const d = Number(n.getAttribute('data-depth'));
            if (!Number.isFinite(d) || d <= baseDepth) break;
            if (n.matches('tr[data-id]')) {
                count++;
                if (rows.length < cap) rows.push(n);
                else truncated = true;
            }
            n = n.nextElementSibling;
        }
        return { rows, count, truncated };
    }

    function __tmAnimateExitingRows(rows) {
        const list = Array.isArray(rows) ? rows : [];
        if (list.length === 0) return;
        list.forEach((row) => {
            if (!(row instanceof Element)) return;
            let rect;
            try { rect = row.getBoundingClientRect(); } catch (e) { return; }
            if (!rect || rect.height <= 0 || rect.width <= 0) return;
            const wrap = document.createElement('div');
            wrap.style.position = 'fixed';
            wrap.style.left = `${rect.left}px`;
            wrap.style.top = `${rect.top}px`;
            wrap.style.width = `${rect.width}px`;
            wrap.style.height = `${rect.height}px`;
            wrap.style.pointerEvents = 'none';
            wrap.style.zIndex = '100004';
            const table = document.createElement('table');
            table.className = 'tm-table';
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';
            const tbody = document.createElement('tbody');
            tbody.appendChild(row.cloneNode(true));
            table.appendChild(tbody);
            wrap.appendChild(table);
            document.body.appendChild(wrap);
            try { row.style.visibility = 'hidden'; } catch (e) {}
            try { row.style.pointerEvents = 'none'; } catch (e) {}
            try {
                const anim = wrap.animate([
                    { transform: 'translateY(0px)', opacity: 1 },
                    { transform: 'translateY(-10px)', opacity: 0 },
                ], { duration: 130, easing: 'cubic-bezier(0.2, 0.9, 0.2, 1)', fill: 'forwards' });
                anim.onfinish = () => { try { wrap.remove(); } catch (e) {} };
            } catch (e) {
                try { wrap.remove(); } catch (e2) {}
            }
        });
    }

    function __tmPrepareFlipAnimation(opts) {
        if (!state.modal) return;
        try { __tmCancelAnimationsWithin(state.modal); } catch (e) {}
        state.__tmFlipFirst = __tmCaptureFlipSnapshot(state.modal);
        state.__tmFlipAction = (opts && typeof opts === 'object') ? { ...opts } : null;
        state.__tmFlipTs = Date.now();
        if (state.__tmFlipAction?.action !== 'collapse') return;
        const tbody = state.viewMode === 'timeline'
            ? state.modal.querySelector('#tmTimelineLeftTable tbody')
            : state.modal.querySelector('#tmTaskTable tbody');
        if (!tbody) return;
        const r = __tmCollectAffectedRowsForCollapseLimited(tbody, state.__tmFlipAction, 24);
        if (!r.truncated && Array.isArray(r.rows) && r.rows.length > 0) __tmAnimateExitingRows(r.rows);
    }

    function __tmAnimateEnteringRows(modalEl, opts) {
        const root = modalEl instanceof Element ? modalEl : state.modal;
        const o = (opts && typeof opts === 'object') ? opts : {};
        if (!root || o.action !== 'expand') return;
        const tbody = state.viewMode === 'timeline'
            ? root.querySelector('#tmTimelineLeftTable tbody')
            : root.querySelector('#tmTaskTable tbody');
        if (!tbody) return;
        const kind = String(o.kind || '');
        const key = String(o.key || '').trim();
        if (!key) return;
        const anchor = kind === 'group'
            ? tbody.querySelector(`tr[data-group-key="${CSS.escape(key)}"]`)
            : tbody.querySelector(`tr[data-id="${CSS.escape(key)}"]`);
        if (!anchor) return;
        const r = __tmCollectAffectedRowsForCollapseLimited(tbody, o, 24);
        if (r.truncated || r.rows.length === 0) return;
        const rows = r.rows;
        rows.forEach((row) => {
            try {
                row.animate([
                    { opacity: 0 },
                    { opacity: 1 },
                ], { duration: 130, easing: 'cubic-bezier(0.2, 0.9, 0.2, 1)', fill: 'both' });
            } catch (e) {}
        });
    }

    function __tmRunFlipAnimation(modalEl) {
        const first = state.__tmFlipFirst;
        if (!(first instanceof Map) || first.size === 0) return;
        const root = modalEl instanceof Element ? modalEl : state.modal;
        if (!root) return;

        // 检查是否滚动到了页面下方，如果是则跳过 FLIP 动画以避免闪烁
        const timelineLeftBody = root.querySelector('#tmTimelineLeftBody');
        const listBody = root.querySelector('.tm-body');
        const isScrolledDown = timelineLeftBody
            ? (Number(timelineLeftBody.scrollTop) || 0) > 100
            : (listBody ? (Number(listBody.scrollTop) || 0) > 100 : false);
        if (isScrolledDown) {
            // 滚动到下方时直接清除 FLIP 状态，不运行动画，避免闪烁
            try { __tmResetFlipState(root); } catch (e) {}
            return;
        }

        try { __tmCancelAnimationsWithin(root); } catch (e) {}
        try { state.__tmFlipRunningAnims = Array.isArray(state.__tmFlipRunningAnims) ? state.__tmFlipRunningAnims : []; } catch (e) {}
        const els = root.querySelectorAll('tr[data-id],tr[data-group-key],.tm-gantt-row[data-id],.tm-gantt-row--group[data-group-key]');
        els.forEach((el) => {
            const k = __tmGetFlipKeyForEl(el);
            if (!k) return;
            const r0 = first.get(k);
            if (!r0) return;
            let r1;
            try { r1 = el.getBoundingClientRect(); } catch (e) { return; }
            if (!r1 || r1.height <= 0 || r1.width <= 0) return;
            const dy0 = (r0.top - r1.top);
            if (!Number.isFinite(dy0) || Math.abs(dy0) < 0.5) return;
            const dy = Math.round(dy0);
            if (!Number.isFinite(dy) || Math.abs(dy) < 1) return;
            try {
                try { el.style.willChange = 'transform'; } catch (e2) {}
                const anim = el.animate([
                    { transform: `translate3d(0px, ${dy}px, 0px)` },
                    { transform: 'translate3d(0px, 0px, 0px)' },
                ], { duration: 180, easing: 'cubic-bezier(0.2, 0.9, 0.2, 1)', fill: 'both' });
                try { state.__tmFlipRunningAnims.push(anim); } catch (e2) {}
                if (anim && typeof anim.commitStyles === 'function') {
                    anim.onfinish = () => {
                        try { anim.commitStyles(); } catch (e2) {}
                        try { anim.cancel(); } catch (e2) {}
                        try { el.style.willChange = ''; } catch (e2) {}
                        try {
                            const a = state.__tmFlipRunningAnims;
                            if (Array.isArray(a)) {
                                const idx = a.indexOf(anim);
                                if (idx !== -1) a.splice(idx, 1);
                            }
                        } catch (e2) {}
                    };
                } else if (anim) {
                    anim.onfinish = () => {
                        try { el.style.willChange = ''; } catch (e2) {}
                        try {
                            const a = state.__tmFlipRunningAnims;
                            if (Array.isArray(a)) {
                                const idx = a.indexOf(anim);
                                if (idx !== -1) a.splice(idx, 1);
                            }
                        } catch (e2) {}
                    };
                }
            } catch (e) {}
        });
        try { __tmAnimateEnteringRows(root, state.__tmFlipAction); } catch (e) {}
        state.__tmFlipFirst = null;
        state.__tmFlipAction = null;
    }

    function __tmRerenderListInPlace(modalEl) {
        const modal = modalEl instanceof Element ? modalEl : state.modal;
        if (!modal) return false;
        const body = modal.querySelector('.tm-body');
        const table = modal.querySelector('#tmTaskTable');
        const tbody = modal.querySelector('#tmTaskTable tbody');
        if (!tbody) return false;
        const top = Number(body?.scrollTop) || 0;
        const left = Number(body?.scrollLeft) || 0;
        const isCalendarTaskTable = String(table?.getAttribute?.('data-tm-table') || '') === 'calendar';
        const originalOrder = SettingsStore.data.columnOrder;
        const originalWidths = SettingsStore.data.columnWidths;
        if (isCalendarTaskTable) {
            try {
                if (!SettingsStore.data.calendarColumnWidths || Object.keys(SettingsStore.data.calendarColumnWidths).length === 0) {
                    SettingsStore.data.calendarColumnWidths = { content: 140, duration: 60, spent: 60 };
                }
                SettingsStore.data.columnOrder = ['content', 'duration', 'spent'];
                SettingsStore.data.columnWidths = SettingsStore.data.calendarColumnWidths;
            } catch (e) {}
        }
        try { tbody.innerHTML = renderTaskList(); } catch (e) { return false; } finally {
            if (isCalendarTaskTable) {
                SettingsStore.data.columnOrder = originalOrder;
                SettingsStore.data.columnWidths = originalWidths;
            }
        }
        try { if (body) body.scrollTop = top; } catch (e) {}
        try { if (body) body.scrollLeft = left; } catch (e) {}
        try { queueMicrotask(() => { try { __tmRunFlipAnimation(modal); } catch (e) {} }); } catch (e) {
            try { Promise.resolve().then(() => { try { __tmRunFlipAnimation(modal); } catch (e2) {} }); } catch (e2) {}
        }
        return true;
    }

    function __tmRerenderTimelineInPlace(modalEl) {
        const modal = modalEl instanceof Element ? modalEl : state.modal;
        if (!modal) return false;
        const leftBody = modal.querySelector('#tmTimelineLeftBody');
        const ganttBody = modal.querySelector('#tmGanttBody');
        const ganttHeader = modal.querySelector('#tmGanttHeader');
        const tbody = modal.querySelector('#tmTimelineLeftTable tbody');
        if (!leftBody || !ganttBody || !tbody) return false;

        const savedTop = Number(leftBody.scrollTop) || 0;
        const savedLeft = Number(ganttBody.scrollLeft) || 0;

        const widths = SettingsStore.data.columnWidths || {};
        const isGloballyLocked = GlobalLock.isLocked();
        const timelineContentWidth0 = Number(SettingsStore.data.timelineContentWidth);
        const timelineContentWidth = Number.isFinite(timelineContentWidth0) ? Math.max(10, Math.min(800, Math.round(timelineContentWidth0))) : (Number(widths.content) || 360);
        const timelineStartW = Math.max(10, Math.min(240, Math.round(Number(widths.startDate) || 90)));
        const timelineEndW = Math.max(10, Math.min(360, Math.round(Number(widths.completionTime) || 170)));
        const isDark = __tmIsDarkMode();
        const progressBarColor = isDark
            ? __tmNormalizeHexColor(SettingsStore.data.progressBarColorDark, '#81c784')
            : __tmNormalizeHexColor(SettingsStore.data.progressBarColorLight, '#4caf50');
        const enableGroupBg = !!SettingsStore.data.enableGroupTaskBgByGroupColor;
        let currentGroupBg = '';

        const renderGroupRow = (row) => {
            const isCollapsed = !!row?.collapsed;
            const toggle = `<span class="tm-group-toggle" onclick="tmToggleGroupCollapse('${row.key}', event)" style="cursor:pointer;margin-right:8px;display:inline-block;width:12px;">${isCollapsed ? '▸' : '▾'}</span>`;
            if (row.kind === 'doc') {
                const labelColor = String(row.labelColor || 'var(--tm-group-doc-label-color)');
                return `<tr class="tm-group-row tm-timeline-row" data-group-key="${esc(row.key)}"><td colspan="3" onclick="tmToggleGroupCollapse('${row.key}', event)" style="cursor:pointer;font-weight:bold;color:var(--tm-text-color);"><div class="tm-group-sticky">${toggle}<span class="tm-group-label" style="color:${labelColor};">📄 ${esc(row.label || '')}</span><span class="tm-badge tm-badge--count">${Number(row.count) || 0}</span></div></td></tr>`;
            }
            // 按任务名分组：分组行使用🧩 emoji
            if (row.kind === 'task') {
                const labelColor = String(row.labelColor || 'var(--tm-primary-color)');
                return `<tr class="tm-group-row tm-timeline-row" data-group-key="${esc(row.key)}"><td colspan="3" onclick="tmToggleGroupCollapse('${row.key}', event)" style="cursor:pointer;font-weight:bold;color:var(--tm-text-color);"><div class="tm-group-sticky">${toggle}<span class="tm-group-label" style="color:${labelColor};">🧩 ${esc(row.label || '')}</span><span class="tm-badge tm-badge--count">${Number(row.count) || 0}</span></div></td></tr>`;
            }
            if (row.kind === 'time') {
                const labelColor = String(row.labelColor || 'var(--tm-text-color)');
                const durationSum = String(row.durationSum || '').trim();
                return `<tr class="tm-group-row tm-timeline-row" data-group-key="${esc(row.key)}"><td colspan="3" onclick="tmToggleGroupCollapse('${row.key}', event)" style="cursor:pointer;font-weight:bold;color:var(--tm-text-color);"><div class="tm-group-sticky">${toggle}<span class="tm-group-label" style="color:${labelColor};">${esc(row.label || '')}</span><span class="tm-badge tm-badge--count">${Number(row.count) || 0}</span>${durationSum ? `<span class="tm-badge tm-badge--duration"><span class="tm-badge__icon">📊</span>${esc(durationSum)}</span>` : ''}</div></td></tr>`;
            }
            if (row.kind === 'h2') {
                return `<tr class="tm-group-row tm-timeline-row" data-group-kind="h2" data-group-key="${esc(row.key)}"><td colspan="3" onclick="tmToggleGroupCollapse('${row.key}', event)" style="cursor:pointer;font-weight:bold;color:var(--tm-secondary-text);"><div class="tm-group-sticky" style="padding-left:2ch;">${toggle}<span class="tm-group-label">🧩 ${esc(row.label || '')}</span><span class="tm-badge tm-badge--count">${Number(row.count) || 0}</span></div></td></tr>`;
            }
            if (row.kind === 'quadrant') {
                const durationSum = String(row.durationSum || '').trim();
                const colorMap = { red: 'var(--tm-quadrant-red)', yellow: 'var(--tm-quadrant-yellow)', blue: 'var(--tm-quadrant-blue)', green: 'var(--tm-quadrant-green)' };
                const color = colorMap[String(row.color || '')] || 'var(--tm-text-color)';
                return `<tr class="tm-group-row tm-timeline-row" data-group-key="${esc(row.key)}"><td colspan="3" onclick="tmToggleGroupCollapse('${row.key}', event)" style="cursor:pointer;font-weight:bold;color:${color};"><div class="tm-group-sticky">${toggle}${esc(row.label || '')}<span class="tm-badge tm-badge--count">${Number(row.count) || 0}</span>${durationSum ? `<span class="tm-badge tm-badge--duration"><span class="tm-badge__icon">📊</span>${esc(durationSum)}</span>` : ''}</div></td></tr>`;
            }
            return `<tr class="tm-group-row tm-timeline-row" data-group-key="${esc(row.key)}"><td colspan="3" onclick="tmToggleGroupCollapse('${row.key}', event)" style="cursor:pointer;font-weight:bold;color:var(--tm-text-color);"><div class="tm-group-sticky">${toggle}${esc(row.label || '')}</div></td></tr>`;
        };

        const renderTaskRow = (row) => {
            const task = state.flatTasks[row.id];
            if (!task) return '';
            const indent = (Math.max(0, Number(row.depth) || 0)) * 12;
            const toggle = row.hasChildren
                ? `<span class="tm-tree-toggle" onclick="tmToggleCollapse('${task.id}', event)">${row.collapsed ? '▸' : '▾'}</span>`
                : `<span class="tm-tree-spacer"></span>`;
            const focusId = SettingsStore.data.enableTomatoIntegration ? String(state.timerFocusTaskId || '').trim() : '';
            const rowClass = focusId ? (focusId === String(task.id) ? 'tm-timer-focus' : 'tm-timer-dim') : '';

            const allChildren = task.children || [];
            const totalChildren = allChildren.length;
            const completedChildren = allChildren.filter(c => c.done).length;
            const progressPercent = totalChildren > 0 ? Math.round((completedChildren / totalChildren) * 100) : 0;
            const isDoneSubtask = !!task.done && (Math.max(0, Number(row.depth) || 0) > 0);
            const groupBg = enableGroupBg ? currentGroupBg : '';
            const doneSubtaskBg = (!enableGroupBg && isDoneSubtask) ? __tmWithAlpha(progressBarColor, isDark ? 0.22 : 0.14) : '';
            const baseBg = groupBg || doneSubtaskBg;
            const progressBgStyle = (row.hasChildren && progressPercent > 0)
                ? (enableGroupBg && groupBg
                    ? `background-image:linear-gradient(90deg, ${progressBarColor} ${progressPercent}%, transparent ${progressPercent}%);background-repeat:no-repeat;background-size:100% 3px;background-position:left bottom;`
                    : `background-image:linear-gradient(90deg, ${progressBarColor} ${progressPercent}%, transparent ${progressPercent}%);background-repeat:no-repeat;`)
                : '';
            const contentCellBgStyle = `${baseBg ? `background-color:${baseBg};` : ''}${progressBgStyle ? `${progressBgStyle};` : ''}`;
            const otherCellBgStyle = groupBg ? `background-color:${groupBg};` : '';

            return `
                <tr class="tm-timeline-row ${rowClass}" data-id="${task.id}" data-depth="${row.depth}" onclick="tmRowClick(event, '${task.id}')" oncontextmenu="tmShowTaskContextMenu(event, '${task.id}')">
                    <td style="width: ${timelineContentWidth}px; min-width: ${timelineContentWidth}px; max-width: ${timelineContentWidth}px; ${contentCellBgStyle}">
                        <div class="tm-task-cell" style="padding-left:${indent}px">
                            ${toggle}
                            <input class="tm-task-checkbox ${isGloballyLocked ? 'tm-operating' : ''}"
                                   type="checkbox" ${task.done ? 'checked' : ''}
                                   ${isGloballyLocked ? 'disabled' : ''}
                                   onchange="tmSetDone('${task.id}', this.checked, event)">
                            <span class="tm-task-text ${task.done ? 'tm-task-done' : ''}" data-level="${row.depth}" title="${esc(task.content || '')}">
                                <span class="tm-task-content-clickable" onclick="tmJumpToTask('${task.id}', event)" title="${esc(task.content || '')}">${esc(task.content || '')}</span>
                            </span>
                        </div>
                    </td>
                    <td class="tm-cell-editable" style="width:${timelineStartW}px; min-width:${timelineStartW}px; max-width:${timelineStartW}px; ${otherCellBgStyle}" onclick="tmBeginCellEdit('${task.id}','startDate',this,event)">${__tmFormatTaskTime(task.startDate)}</td>
                    <td class="tm-cell-editable" style="width:${timelineEndW}px; min-width:${timelineEndW}px; max-width:${timelineEndW}px; ${otherCellBgStyle}" onclick="tmBeginCellEdit('${task.id}','completionTime',this,event)">${__tmFormatTaskTime(task.completionTime)}</td>
                </tr>
            `;
        };

        const rowModel = __tmBuildTaskRowModel();
        try { globalThis.__tmTimelineRowModel = rowModel; } catch (e) {}
        const leftRows = [];
        for (const r of (Array.isArray(rowModel) ? rowModel : [])) {
            if (r?.type === 'group') {
                let labelColor = '';
                if (r.kind === 'doc') labelColor = String(r.labelColor || 'var(--tm-group-doc-label-color)');
                else if (r.kind === 'task') labelColor = String(r.labelColor || 'var(--tm-primary-color)');
                else if (r.kind === 'time') labelColor = String(r.labelColor || 'var(--tm-text-color)');
                else if (r.kind === 'quadrant') {
                    const colorMap = { red: 'var(--tm-quadrant-red)', yellow: 'var(--tm-quadrant-yellow)', blue: 'var(--tm-quadrant-blue)', green: 'var(--tm-quadrant-green)' };
                    labelColor = colorMap[String(r.color || '')] || 'var(--tm-text-color)';
                } else {
                    labelColor = 'var(--tm-text-color)';
                }
                // 任务名分组使用文档颜色作为背景
                if (r.kind === 'task' && r.groupDocColor) {
                    currentGroupBg = enableGroupBg ? __tmGroupBgFromLabelColor(r.groupDocColor, isDark) : '';
                } else {
                    currentGroupBg = enableGroupBg ? __tmGroupBgFromLabelColor(labelColor, isDark) : '';
                }
                leftRows.push(renderGroupRow(r));
                continue;
            }
            if (r?.type === 'task') {
                // 按任务名分组时，每个任务使用自己文档的颜色
                if (state.groupByTaskName) {
                    const task = state.flatTasks[r.id];
                    if (task?.root_id) {
                        const taskDocColor = __tmGetDocColorHex(task.root_id, isDark) || '';
                        if (taskDocColor && enableGroupBg) {
                            currentGroupBg = __tmGroupBgFromLabelColor(taskDocColor, isDark);
                        } else {
                            currentGroupBg = '';
                        }
                    } else {
                        currentGroupBg = '';
                    }
                }
                leftRows.push(renderTaskRow(r));
                continue;
            }
        }
        const html = leftRows.join('') || `<tr><td colspan="3" style="text-align:center; padding:40px; color:var(--tm-secondary-text);">暂无任务</td></tr>`;
        try { tbody.innerHTML = html; } catch (e) { return false; }

        const view = globalThis.__TaskHorizonGanttView;
        if (view && typeof view.render === 'function' && ganttHeader && ganttBody) {
            try {
                view.render({
                    headerEl: ganttHeader,
                    bodyEl: ganttBody,
                    rowModel,
                    getTaskById: (id) => state.flatTasks[String(id)],
                    viewState: state.ganttView,
                    onUpdateTaskDates: async (taskId, patch) => {
                        const id = String(taskId || '').trim();
                        if (!id) return;
                        const task = state.flatTasks[id];
                        if (!task) return;
                        const startDate = String(patch?.startDate || '').trim();
                        const completionTime = String(patch?.completionTime || '').trim();
                        const nextStart = startDate ? __tmNormalizeDateOnly(startDate) : '';
                        const nextEnd = completionTime ? __tmNormalizeDateOnly(completionTime) : '';
                        task.startDate = nextStart;
                        task.completionTime = nextEnd;
                        try {
                            await __tmPersistMetaAndAttrsAsync(id, { startDate: nextStart, completionTime: nextEnd });
                        } catch (e) {
                            hint(`❌ 更新失败: ${e.message}`, 'error');
                        }
                        __tmScheduleRender({ withFilters: true });
                    },
                    onUpdateTaskMeta: async (taskId, patch) => {
                        const id = String(taskId || '').trim();
                        if (!id || !patch || typeof patch !== 'object') return;
                        const task = state.flatTasks[id];
                        if (!task) return;
                        const hasMilestone = Object.prototype.hasOwnProperty.call(patch, 'milestone');
                        if (!hasMilestone) return;
                        const val = !!patch.milestone;
                        task.milestone = val;
                        try {
                            await __tmPersistMetaAndAttrsAsync(id, { milestone: val ? '1' : '' });
                        } catch (e) {
                            hint(`❌ 更新失败: ${e.message}`, 'error');
                        }
                        __tmScheduleRender({ withFilters: true });
                    },
                });
            } catch (e) {}
        }

        try { leftBody.scrollTop = savedTop; } catch (e) {}
        try { ganttBody.scrollTop = savedTop; } catch (e) {}
        try { ganttBody.scrollLeft = savedLeft; } catch (e) {}
        try {
            const inner = ganttHeader?.querySelector?.('.tm-gantt-header-inner');
            if (inner) inner.style.transform = `translateX(${-ganttBody.scrollLeft}px)`;
        } catch (e) {}

        const syncRowHeights = () => {
            if (Date.now() - (Number(state.__tmFlipTs) || 0) < 320) return;
            const leftRowsNow = leftBody.querySelectorAll('tbody tr');
            const rightRowsNow = ganttBody.querySelectorAll('.tm-gantt-row');
            const n = Math.min(leftRowsNow.length, rightRowsNow.length);
            if (n <= 0) return;
            for (let i = 0; i < n; i++) {
                const rr = rightRowsNow[i];
                rr.style.height = '';
                rr.style.minHeight = '';
                rr.style.maxHeight = '';
                const bar = rr.querySelector?.('.tm-gantt-bar');
                if (bar) {
                    bar.style.top = '50%';
                    bar.style.transform = 'translateY(-50%)';
                }
            }
        };
        try {
            requestAnimationFrame(() => requestAnimationFrame(() => {
                syncRowHeights();
                setTimeout(syncRowHeights, 60);
                setTimeout(syncRowHeights, 260);
                setTimeout(syncRowHeights, 420);
            }));
        } catch (e) {}

        try { queueMicrotask(() => { try { __tmRunFlipAnimation(modal); } catch (e) {} }); } catch (e) {
            try { Promise.resolve().then(() => { try { __tmRunFlipAnimation(modal); } catch (e2) {} }); } catch (e2) {}
        }
        return true;
    }

    function __tmRerenderCollapseInPlace() {
        const modal = state.modal;
        if (!modal) return false;
        if (state.viewMode === 'timeline') return __tmRerenderTimelineInPlace(modal);
        return __tmRerenderListInPlace(modal);
    }

    function __tmOpenColorPickerDialog(titleText, initialColor, onApply, options = {}) {
        __tmRemoveElementsById('tm-color-picker-backdrop');
        const swatches = Array.isArray(options?.swatches) && options.swatches.length > 0 ? options.swatches : [
            '#F44336', '#E91E63', '#9C27B0', '#673AB7', '#3F51B5',
            '#2196F3', '#03A9F4', '#00BCD4', '#009688', '#4CAF50',
            '#8BC34A', '#CDDC39', '#FFEB3B', '#FFC107', '#FF9800',
            '#795548', '#9E9E9E', '#607D8B', '#000000', '#FFFFFF'
        ];

        const defaultColor = __tmNormalizeHexColor(options?.defaultColor, '#f44336') || '#f44336';
        let current = __tmNormalizeHexColor(initialColor, defaultColor) || defaultColor;

        const backdrop = document.createElement('div');
        backdrop.id = 'tm-color-picker-backdrop';
        backdrop.className = 'tm-color-picker-backdrop';

        const dialog = document.createElement('div');
        dialog.className = 'tm-color-picker-dialog';

        const title = document.createElement('div');
        title.textContent = String(titleText || '选择颜色');
        title.style.cssText = 'font-weight:700;font-size:15px;margin-bottom:12px;color:var(--tm-text-color);';
        dialog.appendChild(title);

        const preview = document.createElement('div');
        preview.style.cssText = 'display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px;';
        const previewBox = document.createElement('div');
        previewBox.style.cssText = `width:44px;height:28px;border-radius:8px;border:1px solid var(--tm-border-color);background:${current};flex:0 0 auto;`;
        const hexInput = document.createElement('input');
        hexInput.type = 'text';
        hexInput.value = String(current || '').toUpperCase();
        hexInput.placeholder = '#RRGGBB';
        hexInput.style.cssText = 'flex:1;padding:8px 10px;border:1px solid var(--tm-input-border);border-radius:8px;background:var(--tm-input-bg);color:var(--tm-text-color);';
        hexInput.oninput = () => {
            const norm = __tmNormalizeHexColor(hexInput.value, '');
            if (norm) {
                current = norm;
                previewBox.style.background = current;
                hexInput.style.borderColor = 'var(--tm-input-border)';
            } else {
                hexInput.style.borderColor = 'var(--tm-danger-color)';
            }
        };
        preview.appendChild(previewBox);
        preview.appendChild(hexInput);
        dialog.appendChild(preview);

        const grid = document.createElement('div');
        grid.className = 'tm-color-grid-10';
        swatches.forEach((c) => {
            const norm = __tmNormalizeHexColor(c, '');
            if (!norm) return;
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.style.background = norm;
            btn.onclick = () => {
                current = norm;
                hexInput.value = String(current || '').toUpperCase();
                hexInput.style.borderColor = 'var(--tm-input-border)';
                previewBox.style.background = current;
            };
            grid.appendChild(btn);
        });
        dialog.appendChild(grid);

        const actions = document.createElement('div');
        actions.className = 'tm-color-actions';
        const cancelBtn = document.createElement('button');
        cancelBtn.type = 'button';
        cancelBtn.className = 'tm-btn tm-btn-gray';
        cancelBtn.textContent = '取消';
        const okBtn = document.createElement('button');
        okBtn.type = 'button';
        okBtn.className = 'tm-btn tm-btn-primary';
        okBtn.textContent = '应用';

        const close = () => {
            try { backdrop.remove(); } catch (e) {}
        };

        cancelBtn.onclick = close;
        okBtn.onclick = () => {
            const norm = __tmNormalizeHexColor(current, '');
            if (!norm) return;
            try { onApply?.(norm); } catch (e) {}
            close();
        };
        actions.appendChild(cancelBtn);
        actions.appendChild(okBtn);
        dialog.appendChild(actions);

        backdrop.onclick = (e) => {
            if (e.target === backdrop) close();
        };

        backdrop.appendChild(dialog);
        document.body.appendChild(backdrop);
    }

    function __tmApplyAppearanceThemeVars() {
        const isDark = __tmIsDarkMode();
        const root = document.documentElement;

        const start = isDark
            ? __tmNormalizeHexColor(SettingsStore.data.topbarGradientDarkStart, '#3b49b7')
            : __tmNormalizeHexColor(SettingsStore.data.topbarGradientLightStart, '#667eea');
        const end = isDark
            ? __tmNormalizeHexColor(SettingsStore.data.topbarGradientDarkEnd, '#5b2d7a')
            : __tmNormalizeHexColor(SettingsStore.data.topbarGradientLightEnd, '#764ba2');
        const topbarText = isDark
            ? __tmNormalizeHexColor(SettingsStore.data.topbarTextColorDark, '#ffffff')
            : __tmNormalizeHexColor(SettingsStore.data.topbarTextColorLight, '#ffffff');
        const taskColor = isDark
            ? __tmNormalizeHexColor(SettingsStore.data.taskContentColorDark, '#e0e0e0')
            : __tmNormalizeHexColor(SettingsStore.data.taskContentColorLight, '#333333');
        const docGroupColor = isDark
            ? __tmNormalizeHexColor(SettingsStore.data.groupDocLabelColorDark, '#e0e0e0')
            : __tmNormalizeHexColor(SettingsStore.data.groupDocLabelColorLight, '#333333');
        const timeBase = isDark
            ? __tmNormalizeHexColor(SettingsStore.data.timeGroupBaseColorDark, '#6ba5ff')
            : __tmNormalizeHexColor(SettingsStore.data.timeGroupBaseColorLight, '#1a73e8');
        const timeOverdue = isDark
            ? __tmNormalizeHexColor(SettingsStore.data.timeGroupOverdueColorDark, '#ff6b6b')
            : __tmNormalizeHexColor(SettingsStore.data.timeGroupOverdueColorLight, '#d93025');
        const tableBorder = isDark
            ? __tmNormalizeHexColor(SettingsStore.data.tableBorderColorDark, '#333333')
            : __tmNormalizeHexColor(SettingsStore.data.tableBorderColorLight, '#e9ecef');
        const lightInk = topbarText || '#ffffff';
        const controlText = lightInk;
        const controlBg = __tmWithAlpha('#ffffff', 0.12);
        const controlBorder = __tmWithAlpha('#ffffff', 0.34);
        const controlHover = __tmWithAlpha('#000000', 0.12);
        const segBg = __tmWithAlpha('#ffffff', 0.18);
        const segBorder = __tmWithAlpha('#ffffff', 0.26);
        const segText = __tmWithAlpha('#ffffff', 0.86);
        const segSep = __tmWithAlpha('#ffffff', 0.22);
        const segHover = __tmWithAlpha('#000000', 0.12);
        const segActive = __tmWithAlpha('#000000', 0.26);
        const segActiveHover = __tmWithAlpha('#000000', 0.32);
        const searchBg = __tmWithAlpha('#ffffff', 0.9);
        const searchText = '#333333';
        const searchBorder = __tmWithAlpha('#ffffff', 0.3);
        const thumb = __tmWithAlpha('#ffffff', 0.25);

        try { if (start) root.style.setProperty('--tm-topbar-grad-start', start); } catch (e) {}
        try { if (end) root.style.setProperty('--tm-topbar-grad-end', end); } catch (e) {}
        try { if (topbarText) root.style.setProperty('--tm-topbar-text-color', topbarText); } catch (e) {}
        try { root.style.setProperty('--tm-topbar-control-bg', controlBg); } catch (e) {}
        try { root.style.setProperty('--tm-topbar-control-text', controlText); } catch (e) {}
        try { root.style.setProperty('--tm-topbar-control-border', controlBorder); } catch (e) {}
        try { root.style.setProperty('--tm-topbar-control-hover', controlHover); } catch (e) {}
        try { root.style.setProperty('--tm-topbar-seg-bg', segBg); } catch (e) {}
        try { root.style.setProperty('--tm-topbar-seg-border', segBorder); } catch (e) {}
        try { root.style.setProperty('--tm-topbar-seg-item-text', segText); } catch (e) {}
        try { root.style.setProperty('--tm-topbar-seg-item-sep', segSep); } catch (e) {}
        try { root.style.setProperty('--tm-topbar-seg-item-hover', segHover); } catch (e) {}
        try { root.style.setProperty('--tm-topbar-seg-item-active-bg', segActive); } catch (e) {}
        try { root.style.setProperty('--tm-topbar-seg-item-active-hover', segActiveHover); } catch (e) {}
        try { root.style.setProperty('--tm-topbar-search-bg', searchBg); } catch (e) {}
        try { root.style.setProperty('--tm-topbar-search-text', searchText); } catch (e) {}
        try { root.style.setProperty('--tm-topbar-search-border', searchBorder); } catch (e) {}
        try { root.style.setProperty('--tm-topbar-scrollbar-thumb', thumb); } catch (e) {}
        try { if (taskColor) root.style.setProperty('--tm-task-content-color', taskColor); } catch (e) {}
        try { if (docGroupColor) root.style.setProperty('--tm-group-doc-label-color', docGroupColor); } catch (e) {}
        try { if (timeBase) root.style.setProperty('--tm-time-group-base-color', timeBase); } catch (e) {}
        try { if (timeOverdue) root.style.setProperty('--tm-time-group-overdue-color', timeOverdue); } catch (e) {}
        try { if (tableBorder) root.style.setProperty('--tm-table-border-color', tableBorder); } catch (e) {}
    }

    function __tmDocHasUndoneTasks(doc) {
        if (!doc || !Array.isArray(doc.tasks) || doc.tasks.length === 0) return false;
        let hasUndone = false;
        const excludeCompletedParent = !!SettingsStore.data.excludeCompletedTasks;
        const walk = (list, parentDone) => {
            for (const t of list) {
                if (excludeCompletedParent && parentDone) continue;
                if (!t.done) {
                    hasUndone = true;
                    return;
                }
                if (t.children && t.children.length > 0) walk(t.children, excludeCompletedParent ? true : false);
                if (hasUndone) return;
            }
        };
        walk(doc.tasks, false);
        return hasUndone;
    }

    function hint(msg, type) {
        const colors = { success: '#34a853', error: '#ea4335', info: '#4285f4', warning: '#f9ab00' };
        const el = document.createElement('div');
        el.className = 'tm-hint';
        el.style.background = colors[type] || '#666';
        if (!__tmIsMobileDevice()) el.style.top = '35px';
        el.textContent = msg;
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 2500);
    }

    function showPrompt(title, placeholder = '', defaultValue = '') {
        return new Promise((resolve) => {
            const existing = document.querySelector('.tm-prompt-modal');
            if (existing) existing.remove();
            
            const modal = document.createElement('div');
            modal.className = 'tm-prompt-modal';
            
            modal.innerHTML = `
                <div class="tm-prompt-box">
                    <div class="tm-prompt-title">${title}</div>
                    <input type="text" class="tm-prompt-input" placeholder="${placeholder}" value="${defaultValue}" autofocus>
                    <div class="tm-prompt-buttons">
                        <button class="tm-prompt-btn tm-prompt-btn-secondary" id="tm-prompt-cancel">取消</button>
                        <button class="tm-prompt-btn tm-prompt-btn-primary" id="tm-prompt-ok">确定</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            const input = modal.querySelector('.tm-prompt-input');
            const okBtn = modal.querySelector('#tm-prompt-ok');
            const cancelBtn = modal.querySelector('#tm-prompt-cancel');
            
            okBtn.onclick = () => {
                const value = input.value.trim();
                modal.remove();
                resolve(value);
            };
            
            cancelBtn.onclick = () => {
                modal.remove();
                resolve(null);
            };
            
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    okBtn.click();
                } else if (e.key === 'Escape') {
                    cancelBtn.click();
                }
            };
            
            modal.onclick = (e) => {
                if (e.target === modal) {
                    cancelBtn.click();
                }
            };
        });
    }

    function showConfirm(title, message) {
        return new Promise((resolve) => {
            const existing = document.querySelector('.tm-prompt-modal');
            if (existing) existing.remove();

            const modal = document.createElement('div');
            modal.className = 'tm-prompt-modal';

            modal.innerHTML = `
                <div class="tm-prompt-box">
                    <div class="tm-prompt-title">${esc(String(title || '确认'))}</div>
                    <div style="padding: 10px 0; color: var(--tm-text-color); font-size: 14px; line-height: 1.5;">
                        ${esc(String(message || ''))}
                    </div>
                    <div class="tm-prompt-buttons">
                        <button class="tm-prompt-btn tm-prompt-btn-secondary" id="tm-confirm-cancel">取消</button>
                        <button class="tm-prompt-btn tm-prompt-btn-primary" id="tm-confirm-ok">确定</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            const okBtn = modal.querySelector('#tm-confirm-ok');
            const cancelBtn = modal.querySelector('#tm-confirm-cancel');
            const cleanupKey = () => {
                try { document.removeEventListener('keydown', onKey, true); } catch (e) {}
            };
            function onKey(e) {
                if (e.key === 'Escape') {
                    cleanupKey();
                    cancelBtn.click();
                }
            }

            okBtn.onclick = () => {
                cleanupKey();
                modal.remove();
                resolve(true);
            };
            cancelBtn.onclick = () => {
                cleanupKey();
                modal.remove();
                resolve(false);
            };
            modal.onclick = (e) => {
                if (e.target === modal) cancelBtn.click();
            };
            document.addEventListener('keydown', onKey, true);
        });
    }

    function showSelectPrompt(title, options, defaultValue) {
        return new Promise((resolve) => {
            const existing = document.querySelector('.tm-prompt-modal');
            if (existing) existing.remove();

            const modal = document.createElement('div');
            modal.className = 'tm-prompt-modal';

            const opts = Array.isArray(options) ? options : [];
            const items = opts.map(opt => {
                const value = typeof opt === 'string' ? opt : String(opt?.value || '');
                const label = typeof opt === 'string' ? opt : String(opt?.label || opt?.value || '');
                const selected = value === String(defaultValue ?? '') ? 'selected' : '';
                return `<option value="${esc(value)}" ${selected}>${esc(label)}</option>`;
            }).join('');

            modal.innerHTML = `
                <div class="tm-prompt-box">
                    <div class="tm-prompt-title">${title}</div>
                    <select class="tm-prompt-input" style="height: 36px;">
                        ${items}
                    </select>
                    <div class="tm-prompt-buttons">
                        <button class="tm-prompt-btn tm-prompt-btn-secondary" id="tm-prompt-cancel">取消</button>
                        <button class="tm-prompt-btn tm-prompt-btn-primary" id="tm-prompt-ok">确定</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
            const select = modal.querySelector('.tm-prompt-input');
            const okBtn = modal.querySelector('#tm-prompt-ok');
            const cancelBtn = modal.querySelector('#tm-prompt-cancel');

            okBtn.onclick = () => {
                const value = String(select.value || '').trim();
                modal.remove();
                resolve(value);
            };
            cancelBtn.onclick = () => {
                modal.remove();
                resolve(null);
            };
            select.onkeydown = (e) => {
                if (e.key === 'Enter') okBtn.click();
                else if (e.key === 'Escape') cancelBtn.click();
            };
            modal.onclick = (e) => {
                if (e.target === modal) cancelBtn.click();
            };
        });
    }

    function __tmToDatetimeLocalValue(iso) {
        if (!iso) return '';
        const d = new Date(iso);
        if (Number.isNaN(d.getTime())) return '';
        const pad = (n) => String(n).padStart(2, '0');
        return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
    }

    function __tmParseDatetimeLocalToISO(raw) {
        const s = String(raw || '').trim();
        if (!s) return '';
        if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(s) === false && /^\d{4}-\d{2}-\d{2}$/.test(s) === false) {
            const d0 = new Date(s);
            if (!Number.isNaN(d0.getTime())) return d0.toISOString();
        }
        if (/^\d{4}-\d{2}-\d{2}$/.test(s)) {
            const m0 = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
            const y0 = Number(m0[1]);
            const mon0 = Number(m0[2]) - 1;
            const d0 = Number(m0[3]);
            const dt0 = new Date(y0, mon0, d0, 0, 0, 0, 0);
            if (Number.isNaN(dt0.getTime())) return '';
            return dt0.toISOString();
        }
        const m = s.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})(?::(\d{2}))?$/);
        if (!m) return '';
        const y = Number(m[1]);
        const mon = Number(m[2]) - 1;
        const d = Number(m[3]);
        const hh = Number(m[4]);
        const mm = Number(m[5]);
        const ss = Number(m[6] || 0);
        const dt = new Date(y, mon, d, hh, mm, ss, 0);
        if (Number.isNaN(dt.getTime())) return '';
        return dt.toISOString();
    }

    function showDateTimePrompt(title, defaultIso) {
        return new Promise((resolve) => {
            const existing = document.querySelector('.tm-prompt-modal');
            if (existing) existing.remove();

            const modal = document.createElement('div');
            modal.className = 'tm-prompt-modal';

            modal.innerHTML = `
                <div class="tm-prompt-box">
                    <div class="tm-prompt-title">${title}</div>
                    <input type="datetime-local" class="tm-prompt-input" value="${esc(__tmToDatetimeLocalValue(defaultIso))}" autofocus>
                    <div class="tm-prompt-buttons" style="justify-content: space-between;">
                        <button class="tm-prompt-btn tm-prompt-btn-secondary" id="tm-prompt-clear">清空</button>
                        <div style="display:flex;gap:10px;">
                            <button class="tm-prompt-btn tm-prompt-btn-secondary" id="tm-prompt-cancel">取消</button>
                            <button class="tm-prompt-btn tm-prompt-btn-primary" id="tm-prompt-ok">确定</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
            const input = modal.querySelector('.tm-prompt-input');
            const okBtn = modal.querySelector('#tm-prompt-ok');
            const cancelBtn = modal.querySelector('#tm-prompt-cancel');
            const clearBtn = modal.querySelector('#tm-prompt-clear');

            okBtn.onclick = () => {
                const raw = String(input.value || '').trim();
                modal.remove();
                if (!raw) return resolve('');
                resolve(__tmParseDatetimeLocalToISO(raw));
            };
            clearBtn.onclick = () => {
                modal.remove();
                resolve('');
            };
            cancelBtn.onclick = () => {
                modal.remove();
                resolve(null);
            };
            input.onkeydown = (e) => {
                if (e.key === 'Enter') okBtn.click();
                else if (e.key === 'Escape') cancelBtn.click();
            };
            modal.onclick = (e) => {
                if (e.target === modal) cancelBtn.click();
            };
        });
    }

    function showDatePrompt(title, defaultDate) {
        return new Promise((resolve) => {
            const existing = document.querySelector('.tm-prompt-modal');
            if (existing) existing.remove();

            const modal = document.createElement('div');
            modal.className = 'tm-prompt-modal';

            const d0 = String(defaultDate || '').trim().slice(0, 10);
            modal.innerHTML = `
                <div class="tm-prompt-box">
                    <div class="tm-prompt-title">${title}</div>
                    <input type="date" class="tm-prompt-input" value="${esc(d0)}" autofocus>
                    <div class="tm-prompt-buttons" style="justify-content: space-between;">
                        <button class="tm-prompt-btn tm-prompt-btn-secondary" id="tm-prompt-clear">清空</button>
                        <div style="display:flex;gap:10px;">
                            <button class="tm-prompt-btn tm-prompt-btn-secondary" id="tm-prompt-cancel">取消</button>
                            <button class="tm-prompt-btn tm-prompt-btn-primary" id="tm-prompt-ok">确定</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
            const input = modal.querySelector('.tm-prompt-input');
            const okBtn = modal.querySelector('#tm-prompt-ok');
            const cancelBtn = modal.querySelector('#tm-prompt-cancel');
            const clearBtn = modal.querySelector('#tm-prompt-clear');

            okBtn.onclick = () => {
                const raw = String(input.value || '').trim();
                modal.remove();
                resolve(raw ? __tmNormalizeDateOnly(raw) : '');
            };
            clearBtn.onclick = () => {
                modal.remove();
                resolve('');
            };
            cancelBtn.onclick = () => {
                modal.remove();
                resolve(null);
            };
            input.onclick = () => { try { input.showPicker?.(); } catch (e) {} };
            input.onkeydown = (e) => {
                if (e.key === 'Enter') okBtn.click();
                else if (e.key === 'Escape') cancelBtn.click();
            };
            modal.onclick = (e) => {
                if (e.target === modal) cancelBtn.click();
            };
            try {
                input.focus();
                input.showPicker?.();
            } catch (e) {}
        });
    }

    // 显示规则管理器
    async function showRulesManager() {
        if (state.rulesModal) return;
        
        state.rulesModal = document.createElement('div');
        state.rulesModal.className = 'tm-rules-manager';
        
        state.rulesModal.innerHTML = `
            <div class="tm-rules-box">
                <div class="tm-rules-header">
                    <div class="tm-rules-title">📋 筛选规则管理器</div>
                    <div style="display:flex;gap:10px;align-items:center;">
                        <button class="tm-rule-btn tm-rule-btn-secondary" data-tm-action="showPriorityScoreSettings">
                            优先级算法
                        </button>
                        <button class="tm-rule-btn tm-rule-btn-success" data-tm-action="addNewRule">
                            <span>+</span> 添加规则
                        </button>
                    </div>
                </div>
                
                <div class="tm-rules-body">
                    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px 12px; border-bottom:1px solid var(--tm-border-color); background: var(--tm-bg-color);">
                        <div style="font-size:13px; color: var(--tm-text-color);">时间轴强制按完成日期排序（越近今天越靠前）</div>
                        <input type="checkbox" ${SettingsStore.data.timelineForceSortByCompletionNearToday ? 'checked' : ''} onchange="tmToggleTimelineForceSortByCompletionNearToday(this.checked)">
                    </div>
                    ${renderRulesList()}
                </div>
                
                <div class="tm-rules-footer">
                    <div class="tm-rule-info">
                        当前有 ${state.filterRules.filter(r => r.enabled).length} 个启用的规则
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button class="tm-rule-btn tm-rule-btn-secondary" data-tm-action="closeRulesManager">取消</button>
                        <button class="tm-rule-btn tm-rule-btn-success" data-tm-action="saveRules">保存规则</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(state.rulesModal);
        __tmBindRulesManagerEvents(state.rulesModal);
    }

    function __tmBindRulesManagerEvents(rootEl) {
        const root = rootEl || state.rulesModal;
        if (!root || root.__tmRulesManagerBound) return;
        root.__tmRulesManagerBound = true;

        root.addEventListener('click', async (e) => {
            const target = e.target?.closest?.('[data-tm-call],[data-tm-action]');
            if (!target || !root.contains(target)) return;
            const tag = String(target.tagName || '').toLowerCase();
            if (tag === 'select' || tag === 'input' || tag === 'textarea' || tag === 'option') return;
            e.preventDefault();

            const callName = String(target.dataset.tmCall || '');
            if (callName) {
                const fn = window[callName];
                if (typeof fn !== 'function') return;
                let args = [];
                const raw = target.dataset.tmArgs;
                if (raw) {
                    try {
                        const parsed = JSON.parse(raw);
                        args = Array.isArray(parsed) ? parsed : [parsed];
                    } catch (e2) {}
                }
                return await fn(...args);
            }

            const action = String(target.dataset.tmAction || '');
            const ruleId = String(target.dataset.ruleId || '');
            const index = target.dataset.index !== undefined ? Number(target.dataset.index) : NaN;
            const delta = target.dataset.delta !== undefined ? Number(target.dataset.delta) : NaN;
            const tab = String(target.dataset.tab || '');

            if (action === 'editRule') return window.editRule?.(ruleId);
            if (action === 'deleteRule') return window.deleteRule?.(ruleId);
            if (action === 'applyRuleNow') return window.applyRuleNow?.(ruleId);
            if (action === 'removeCondition') return window.removeCondition?.(index);
            if (action === 'moveSortRule') return window.moveSortRule?.(index, delta);
            if (action === 'removeSortRule') return window.removeSortRule?.(index);
            if (action === 'tmSwitchSettingsTab') return window.tmSwitchSettingsTab?.(tab);

            const fn = window[action];
            if (typeof fn === 'function') return await fn();
        });

        root.addEventListener('change', (e) => {
            const target = e.target?.closest?.('[data-tm-call],[data-tm-change]');
            if (!target || !root.contains(target)) return;

            const callName = String(target.dataset.tmCall || '');
            if (callName) {
                const fn = window[callName];
                if (typeof fn !== 'function') return;
                let args = [];
                const raw = target.dataset.tmArgs;
                if (raw) {
                    try {
                        const parsed = JSON.parse(raw);
                        args = Array.isArray(parsed) ? parsed : [parsed];
                    } catch (e2) {}
                }
                const val = (target.type === 'checkbox') ? !!target.checked : target.value;
                return fn(...args, val);
            }

            const changeType = String(target.dataset.tmChange || '');
            const ruleId = String(target.dataset.ruleId || '');
            const index = target.dataset.index !== undefined ? Number(target.dataset.index) : NaN;
            const optionValue = String(target.dataset.optionValue || '');
            const rangeKey = String(target.dataset.rangeKey || '');

            if (changeType === 'toggleRuleEnabled') return window.toggleRuleEnabled?.(ruleId, !!target.checked);
            if (changeType === 'updateConditionField') return window.updateConditionField?.(index, target.value);
            if (changeType === 'updateConditionOperator') return window.updateConditionOperator?.(index, target.value);
            if (changeType === 'updateConditionValue') return window.updateConditionValue?.(index, target.value);
            if (changeType === 'toggleConditionMultiValue') return window.toggleConditionMultiValue?.(index, optionValue, !!target.checked);
            if (changeType === 'updateConditionValueRange') return window.updateConditionValueRange?.(index, rangeKey, target.value);
            if (changeType === 'updateSortField') return window.updateSortField?.(index, target.value);
            if (changeType === 'updateSortOrder') return window.updateSortOrder?.(index, target.value);
        });

        root.addEventListener('input', (e) => {
            const target = e.target?.closest?.('[data-tm-call],[data-tm-input]');
            if (!target || !root.contains(target)) return;

            const callName = String(target.dataset.tmCall || '');
            if (callName) {
                const fn = window[callName];
                if (typeof fn !== 'function') return;
                let args = [];
                const raw = target.dataset.tmArgs;
                if (raw) {
                    try {
                        const parsed = JSON.parse(raw);
                        args = Array.isArray(parsed) ? parsed : [parsed];
                    } catch (e2) {}
                }
                const val = (target.type === 'checkbox') ? !!target.checked : target.value;
                return fn(...args, val);
            }

            const inputType = String(target.dataset.tmInput || '');
            if (inputType === 'updateEditingRuleName') return window.updateEditingRuleName?.(target.value);
        });
    }

    // 渲染规则列表
    function renderRulesList() {
        const isAddingNew = state.editingRule && !state.filterRules.some(r => r.id === state.editingRule.id);

        if (state.filterRules.length === 0 && !isAddingNew) {
            return '<div style="text-align: center; padding: 40px; color: var(--tm-secondary-text);">暂无规则，点击"添加规则"创建</div>';
        }
        
        let html = state.filterRules.map((rule, index) => renderRuleItem(rule, index)).join('');

        if (isAddingNew) {
            html = renderRuleEditor(state.editingRule) + html;
        }
        
        return html;
    }

    // 渲染单个规则项
    function renderRuleItem(rule, index) {
        const isEditing = state.editingRule?.id === rule.id;
        
        if (isEditing) {
            return renderRuleEditor(rule);
        }
        
        const conditionText = rule.conditions.length > 0
            ? rule.conditions.map(c => {
                const field = RuleManager.getAvailableFields().find(f => f.value === c.field);
                let valueDisplay = c.value;

                // 状态字段特殊显示
                if (c.field === 'customStatus') {
                    if (Array.isArray(c.value)) {
                        valueDisplay = c.value.map(v => {
                            const option = SettingsStore.data.customStatusOptions.find(o => o.id === v);
                            return option ? option.name : v;
                        }).join('、');
                    } else {
                        const option = SettingsStore.data.customStatusOptions.find(o => o.id === c.value);
                        valueDisplay = option ? option.name : c.value;
                    }
                } else if (c.field === 'priority') {
                    // 优先级显示
                    const priorityMap = {
                        'high': '高',
                        'medium': '中',
                        'low': '低',
                        'none': '无'
                    };
                    if (Array.isArray(c.value)) {
                        valueDisplay = c.value.map(v => priorityMap[v] || v).join('、');
                    } else {
                        valueDisplay = priorityMap[c.value] || c.value;
                    }
                } else if (field?.type === 'boolean') {
                    if (c.value === true || c.value === 'true') valueDisplay = 'true';
                    else if (c.value === false || c.value === 'false') valueDisplay = 'false';
                    else valueDisplay = 'true';
                }

                // 多值显示处理
                if (Array.isArray(c.value) && c.field !== 'customStatus' && c.field !== 'priority') {
                    if (c.value.length > 1) {
                        valueDisplay = c.value.join('、');
                    } else {
                        valueDisplay = c.value[0] || '无';
                    }
                } else if ((c.operator === 'in' || c.operator === 'not_in') && c.field !== 'customStatus' && c.field !== 'priority') {
                    // 兼容旧格式（逗号分隔的字符串）
                    if (typeof c.value === 'string' && c.value.includes(',')) {
                        valueDisplay = c.value.split(',').join('、');
                    }
                }

                return `${field?.label || c.field} ${c.operator} ${valueDisplay}`;
            }).join('， ')
            : '无条件';
        
        const sortText = __tmRuleHasExplicitSort(rule)
            ? rule.sort.map((s, i) => {
                const fieldLabel = (RuleManager.getSortFields().find(f => f.value === s.field)?.label || s.field);
                return `${i + 1}. ${fieldLabel} (${s.order === 'desc' ? '降序' : '升序'})`;
            }).join(' → ')
            : '无排序';
        
        return `
            <div class="tm-rule-group">
                <div class="tm-rule-group-header">
                    <div class="tm-rule-group-title">
                        <input type="checkbox" ${rule.enabled ? 'checked' : ''} 
                               data-tm-change="toggleRuleEnabled"
                               data-rule-id="${esc(String(rule.id))}"
                               style="margin-right: 8px;">
                        ${esc(rule.name)}
                        ${state.currentRule === rule.id ? '<span style="color: var(--tm-success-color); margin-left: 8px;">(当前应用)</span>' : ''}
                    </div>
                    <div class="tm-rule-group-controls">
                        <button class="tm-rule-btn tm-rule-btn-primary" data-tm-action="editRule" data-rule-id="${esc(String(rule.id))}">
                            编辑
                        </button>
                        <button class="tm-rule-btn tm-rule-btn-danger" data-tm-action="deleteRule" data-rule-id="${esc(String(rule.id))}">
                            删除
                        </button>
                    </div>
                </div>
                
                <div style="font-size: 12px; color: var(--tm-secondary-text); margin-bottom: 8px;">
                    <strong>筛选条件：</strong>${conditionText}
                </div>
                <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
                    <strong>排序规则：</strong>${sortText}
                </div>
                
                <div class="tm-rule-actions">
                    <button class="tm-rule-btn tm-rule-btn-primary" data-tm-action="applyRuleNow" data-rule-id="${esc(String(rule.id))}">
                        立即应用
                    </button>
                </div>
            </div>
        `;
    }

    // 渲染规则编辑器
    function renderRuleEditor(rule) {
        const availableFields = RuleManager.getAvailableFields();
        const sortFields = RuleManager.getSortFields();
        
        return `
            <div class="tm-rule-group">
                <div class="tm-rule-group-header">
                    <input type="text" class="tm-rule-input" value="${esc(rule.name)}" 
                           placeholder="规则名称" data-tm-input="updateEditingRuleName">
                </div>
                
                <div class="tm-rule-section">
                    <div class="tm-rule-section-title">
                        <span>筛选条件</span>
                        <button class="tm-rule-btn tm-rule-btn-add" data-tm-action="addCondition">
                            + 添加条件
                        </button>
                    </div>
                    <div class="tm-rule-conditions">
                        ${renderConditions(rule.conditions)}
                    </div>
                </div>
                
                <div class="tm-rule-section">
                    <div class="tm-rule-section-title">
                        <span>排序规则</span>
                        <button class="tm-rule-btn tm-rule-btn-add" data-tm-action="addSortRule">
                            + 添加排序
                        </button>
                    </div>
                    <div class="tm-rule-sort-items">
                        ${renderSortRules(rule.sort)}
                    </div>
                </div>
                
                <div class="tm-rule-actions">
                    <button class="tm-rule-btn tm-rule-btn-secondary" data-tm-action="cancelEditRule">
                        取消
                    </button>
                    <button class="tm-rule-btn tm-rule-btn-success" data-tm-action="saveEditRule">
                        保存规则
                    </button>
                </div>
            </div>
        `;
    }

    // 渲染条件列表
    function renderConditions(conditions) {
        if (conditions.length === 0) {
            return '<div style="text-align: center; padding: 10px; color: var(--tm-secondary-text);">暂无筛选条件</div>';
        }
        
        const availableFields = RuleManager.getAvailableFields();
        
        return conditions.map((condition, index) => {
            const field = availableFields.find(f => f.value === condition.field);
            const operators = RuleManager.getOperators(field?.type || 'text');
            
            return `
                <div class="tm-rule-condition">
                    <select class="tm-rule-condition-field" data-tm-change="updateConditionField" data-index="${index}">
                        ${availableFields.map(f => 
                            `<option value="${f.value}" ${condition.field === f.value ? 'selected' : ''}>
                                ${f.label}
                            </option>`
                        ).join('')}
                    </select>
                    <select class="tm-rule-condition-operator" data-tm-change="updateConditionOperator" data-index="${index}">
                        ${operators.map(op => 
                            `<option value="${op.value}" ${condition.operator === op.value ? 'selected' : ''}>
                                ${op.label}
                            </option>`
                        ).join('')}
                    </select>
                    ${renderConditionValue(condition, index, field?.type)}
                    <button class="tm-rule-btn tm-rule-btn-danger" data-tm-action="removeCondition" data-index="${index}">
                        ×
                    </button>
                </div>
            `;
        }).join('');
    }

    // 渲染条件值输入
    function renderConditionValue(condition, index, fieldType) {
        if (fieldType === 'boolean') {
            return `
                <select class="tm-rule-condition-value" data-tm-change="updateConditionValue" data-index="${index}">
                    <option value="__all__" ${String(condition.value) === '__all__' ? 'selected' : ''}>所有状态(忽略不查找已完成父任务)</option>
                    <option value="true" ${condition.value === true || condition.value === 'true' ? 'selected' : ''}>是</option>
                    <option value="false" ${condition.value === false || condition.value === 'false' ? 'selected' : ''}>否</option>
                </select>
            `;
        }
        
        if (fieldType === 'select') {
            const field = RuleManager.getAvailableFields().find(f => f.value === condition.field);
            
            // 准备选项和显示标签
            let allOptions = [];
            let optionLabels = { 'high': '高', 'medium': '中', 'low': '低', 'none': '无' };

            if (condition.field === 'customStatus') {
                allOptions = SettingsStore.data.customStatusOptions.map(o => o.id);
                optionLabels = SettingsStore.data.customStatusOptions.reduce((acc, cur) => {
                    acc[cur.id] = cur.name;
                    return acc;
                }, {});
            } else {
                allOptions = [...(field.options || []), '无'];
            }

            // 如果操作符是 in 或 not_in，显示多选框组
            if (condition.operator === 'in' || condition.operator === 'not_in') {
                // value 应该是数组
                let selectedValues = [];
                if (Array.isArray(condition.value)) {
                    selectedValues = condition.value;
                } else if (typeof condition.value === 'string' && condition.value.includes(',')) {
                    selectedValues = condition.value.split(',').map(v => v.trim());
                }

                return `
                    <div class="tm-multi-select" style="display: flex; flex-wrap: wrap; gap: 8px; min-width: 200px;">
                        ${allOptions.map(opt => `
                            <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                <input type="checkbox"
                                       ${selectedValues.includes(opt) ? 'checked' : ''}
                                       data-tm-change="toggleConditionMultiValue"
                                       data-index="${index}"
                                       data-option-value="${esc(String(opt))}">
                                <span>${optionLabels[opt] || opt}</span>
                            </label>
                        `).join('')}
                    </div>
                `;
            }
            // 否则显示单选下拉框
            // 如果值是数组（之前是in/not_in），转为空字符串
            const singleValue = Array.isArray(condition.value) ? '' : condition.value;
            
            return `
                <select class="tm-rule-condition-value" data-tm-change="updateConditionValue" data-index="${index}">
                    <option value="">-- 请选择 --</option>
                    ${allOptions.map(opt =>
                        `<option value="${opt}" ${singleValue === opt ? 'selected' : ''}>
                            ${optionLabels[opt] || opt}
                        </option>`
                    ).join('')}
                </select>
            `;
        }
        
        if (condition.operator === 'between' && (fieldType === 'datetime' || fieldType === 'number')) {
            const inputType = fieldType === 'datetime' ? 'date' : 'number';
            return `
                <div class="tm-time-range">
                    <input type="${inputType}" 
                           class="tm-time-input" 
                           placeholder="开始值"
                           value="${condition.value?.from || ''}"
                           data-tm-change="updateConditionValueRange"
                           data-index="${index}"
                           data-range-key="from">
                    <span class="tm-time-separator">至</span>
                    <input type="${inputType}" 
                           class="tm-time-input" 
                           placeholder="结束值"
                           value="${condition.value?.to || ''}"
                           data-tm-change="updateConditionValueRange"
                           data-index="${index}"
                           data-range-key="to">
                </div>
            `;
        }
        
        return `
            <input type="text" class="tm-rule-condition-value" 
                   value="${esc(String(condition.value || ''))}"
                   placeholder="输入值"
                   data-tm-change="updateConditionValue"
                   data-index="${index}">
        `;
    }

    // 渲染排序规则
    function renderSortRules(sortRules) {
        if (sortRules.length === 0) {
            return '<div style="text-align: center; padding: 10px; color: var(--tm-secondary-text);">暂无排序规则</div>';
        }
        
        const sortFields = RuleManager.getSortFields();
        
        return sortRules.map((sortRule, index) => `
            <div class="tm-rule-sort-item">
                <select class="tm-rule-sort-field" data-tm-change="updateSortField" data-index="${index}">
                    ${sortFields.map(f => 
                        `<option value="${f.value}" ${sortRule.field === f.value ? 'selected' : ''}>
                            ${f.label}
                        </option>`
                    ).join('')}
                </select>
                <select class="tm-rule-sort-order" data-tm-change="updateSortOrder" data-index="${index}">
                    <option value="asc" ${sortRule.order === 'asc' ? 'selected' : ''}>升序</option>
                    <option value="desc" ${sortRule.order === 'desc' ? 'selected' : ''}>降序</option>
                </select>
                <button class="tm-rule-btn tm-rule-btn-secondary" data-tm-action="moveSortRule" data-index="${index}" data-delta="-1" ${index === 0 ? 'disabled' : ''} style="width: 28px; padding: 2px 0;">↑</button>
                <button class="tm-rule-btn tm-rule-btn-secondary" data-tm-action="moveSortRule" data-index="${index}" data-delta="1" ${index === sortRules.length - 1 ? 'disabled' : ''} style="width: 28px; padding: 2px 0;">↓</button>
                <button class="tm-rule-btn tm-rule-btn-danger" data-tm-action="removeSortRule" data-index="${index}">
                    ×
                </button>
            </div>
        `).join('');
    }

    // 全局规则管理函数
    window.showRulesManager = showRulesManager;

    function __tmGetDefaultPriorityScoreConfig() {
        return {
            base: 100,
            weights: { importance: 1, status: 1, due: 1, duration: 1, doc: 1 },
            importanceDelta: { high: 20, medium: 10, low: -5, none: 0 },
            statusDelta: { todo: 0, in_progress: 15, done: -80, blocked: -10, review: 5 },
            dueRanges: [
                { days: 0, delta: 20 },
                { days: 1, delta: 15 },
                { days: 3, delta: 10 },
                { days: 7, delta: 5 },
                { days: 30, delta: 0 }
            ],
            durationUnit: 'minutes',
            durationBuckets: [
                { maxMinutes: 15, delta: 10 },
                { maxMinutes: 60, delta: 0 },
                { maxMinutes: 240, delta: -5 },
                { maxMinutes: 999999, delta: -10 }
            ],
            docDeltas: {}
        };
    }

    function __tmCloneJson(obj) {
        try { return JSON.parse(JSON.stringify(obj || {})); } catch (e) { return {}; }
    }

    function __tmEnsurePriorityDraft() {
        const base = __tmGetDefaultPriorityScoreConfig();
        const cur = (SettingsStore.data.priorityScoreConfig && typeof SettingsStore.data.priorityScoreConfig === 'object')
            ? SettingsStore.data.priorityScoreConfig
            : {};
        const merged = { ...base, ...__tmCloneJson(cur) };
        merged.weights = { ...base.weights, ...(merged.weights || {}) };
        merged.importanceDelta = { ...base.importanceDelta, ...(merged.importanceDelta || {}) };
        merged.statusDelta = { ...base.statusDelta, ...(merged.statusDelta || {}) };
        merged.dueRanges = Array.isArray(merged.dueRanges) ? merged.dueRanges : base.dueRanges;
        merged.durationUnit = (merged.durationUnit === 'hours' || merged.durationUnit === 'minutes') ? merged.durationUnit : 'minutes';
        merged.durationBuckets = Array.isArray(merged.durationBuckets) ? merged.durationBuckets : base.durationBuckets;
        merged.docDeltas = (merged.docDeltas && typeof merged.docDeltas === 'object') ? merged.docDeltas : {};

        const statuses = SettingsStore.data.customStatusOptions || [];
        statuses.forEach(s => {
            const id = String(s?.id || '').trim();
            if (!id) return;
            if (merged.statusDelta[id] === undefined) merged.statusDelta[id] = 0;
        });
        return merged;
    }

    function __tmRenderPriorityScoreSettings(isEmbeddedInSettings) {
        const embedded = !!isEmbeddedInSettings;
        const cfg = state.priorityScoreDraft || __tmEnsurePriorityDraft();
        const statuses = SettingsStore.data.customStatusOptions || [];
        const docs = state.allDocuments || [];
        const docRows = Object.entries(cfg.docDeltas || {}).map(([docId, delta]) => {
            const dName = docs.find(d => d.id === docId)?.name;
            return `
                <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;flex-wrap:wrap;">
                    <button class="tm-btn tm-btn-secondary" data-tm-call="tmPickPriorityDocDelta" data-tm-args='["${esc(docId)}"]' style="flex:1;min-width:180px;display:flex;align-items:center;justify-content:space-between;gap:10px;">
                        <span style="min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${esc(dName || docId)}</span>
                        <span style="opacity:0.8;">▾</span>
                    </button>
                    <input class="tm-input" style="width:120px;" type="number" value="${Number(delta) || 0}" data-tm-call="tmSetPriorityDocDelta" data-tm-args='["${esc(docId)}"]'>
                    <button class="tm-btn tm-btn-gray" data-tm-call="tmRemovePriorityDocDelta" data-tm-args='["${esc(docId)}"]'>删除</button>
                </div>
            `;
        }).join('');

        const dueRows = (Array.isArray(cfg.dueRanges) ? cfg.dueRanges : []).map((r, i) => `
            <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;">
                <span style="width:70px;color:var(--tm-secondary-text);">≤ 天数</span>
                <input class="tm-input" style="width:120px;" type="number" value="${Number(r.days) || 0}" data-tm-call="tmSetPriorityDueRange" data-tm-args='[${i},"days"]'>
                <span style="width:40px;color:var(--tm-secondary-text);">加分</span>
                <input class="tm-input" style="width:120px;" type="number" value="${Number(r.delta) || 0}" data-tm-call="tmSetPriorityDueRange" data-tm-args='[${i},"delta"]'>
                <button class="tm-btn tm-btn-gray" data-tm-call="tmRemovePriorityDueRange" data-tm-args='[${i}]'>删除</button>
            </div>
        `).join('');

        const durationUnit = (cfg.durationUnit === 'hours' || cfg.durationUnit === 'minutes') ? cfg.durationUnit : 'minutes';
        const __tmDurationBucketToInputValue = (maxMinutes) => {
            const m = Number(maxMinutes);
            if (!Number.isFinite(m)) return 0;
            const v = durationUnit === 'hours' ? (m / 60) : m;
            return Math.round(v * 100) / 100;
        };
        const durationLabel = durationUnit === 'hours' ? '≤ 小时' : '≤ 分钟';
        const durRows = (Array.isArray(cfg.durationBuckets) ? cfg.durationBuckets : []).map((b, i) => `
            <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;">
                <span style="width:70px;color:var(--tm-secondary-text);">${durationLabel}</span>
                <input class="tm-input" style="width:120px;" type="number" value="${__tmDurationBucketToInputValue(b.maxMinutes)}" data-tm-call="tmSetPriorityDurationBucket" data-tm-args='[${i},"maxMinutes"]'>
                <span style="width:40px;color:var(--tm-secondary-text);">加分</span>
                <input class="tm-input" style="width:120px;" type="number" value="${Number(b.delta) || 0}" data-tm-call="tmSetPriorityDurationBucket" data-tm-args='[${i},"delta"]'>
                <button class="tm-btn tm-btn-gray" data-tm-call="tmRemovePriorityDurationBucket" data-tm-args='[${i}]'>删除</button>
            </div>
        `).join('');

        if (embedded) {
            return `
                <div style="display:flex;flex-direction:column;gap:12px;">
                    <div style="font-weight: 700; font-size: 15px;">⚙️ 优先级算法</div>

                    <div class="tm-rule-section" style="margin-bottom:0;">
                        <div style="font-weight: 700; margin-bottom: 10px;">基础分</div>
                        <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
                            <input class="tm-input" type="number" value="${Number(cfg.base) || 100}" data-tm-call="tmSetPriorityBase" style="width: 180px;">
                            <div style="font-size: 12px; color: var(--tm-secondary-text);">用于所有任务的起始分</div>
                        </div>
                    </div>

                    <div class="tm-rule-section" style="margin-bottom:0;">
                        <div style="font-weight: 700; margin-bottom: 10px;">权重（微调）</div>
                        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:10px;">
                            <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">重要性 <input class="tm-input" style="width:120px;max-width:100%;" type="number" value="${Number(cfg.weights.importance) || 1}" data-tm-call="tmSetPriorityWeight" data-tm-args='["importance"]'></label>
                            <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">状态 <input class="tm-input" style="width:120px;max-width:100%;" type="number" value="${Number(cfg.weights.status) || 1}" data-tm-call="tmSetPriorityWeight" data-tm-args='["status"]'></label>
                            <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">完成日期 <input class="tm-input" style="width:120px;max-width:100%;" type="number" value="${Number(cfg.weights.due) || 1}" data-tm-call="tmSetPriorityWeight" data-tm-args='["due"]'></label>
                            <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">时长 <input class="tm-input" style="width:120px;max-width:100%;" type="number" value="${Number(cfg.weights.duration) || 1}" data-tm-call="tmSetPriorityWeight" data-tm-args='["duration"]'></label>
                            <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">文档 <input class="tm-input" style="width:120px;max-width:100%;" type="number" value="${Number(cfg.weights.doc) || 1}" data-tm-call="tmSetPriorityWeight" data-tm-args='["doc"]'></label>
                        </div>
                    </div>

                    <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:12px;">
                        <div class="tm-rule-section" style="margin-bottom:0;">
                            <div style="font-weight: 700; margin-bottom: 10px;">重要性加减分</div>
                            <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:10px;">
                                <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">高 <input class="tm-input" style="width:120px;max-width:100%;" type="number" value="${Number(cfg.importanceDelta.high) || 0}" data-tm-call="tmSetPriorityImportance" data-tm-args='["high"]'></label>
                                <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">中 <input class="tm-input" style="width:120px;max-width:100%;" type="number" value="${Number(cfg.importanceDelta.medium) || 0}" data-tm-call="tmSetPriorityImportance" data-tm-args='["medium"]'></label>
                                <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">低 <input class="tm-input" style="width:120px;max-width:100%;" type="number" value="${Number(cfg.importanceDelta.low) || 0}" data-tm-call="tmSetPriorityImportance" data-tm-args='["low"]'></label>
                                <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">无 <input class="tm-input" style="width:120px;max-width:100%;" type="number" value="${Number(cfg.importanceDelta.none) || 0}" data-tm-call="tmSetPriorityImportance" data-tm-args='["none"]'></label>
                            </div>
                        </div>

                        <div class="tm-rule-section" style="margin-bottom:0;">
                            <div style="font-weight: 700; margin-bottom: 10px;">状态加减分</div>
                            <div style="display:flex;flex-wrap:wrap;gap:10px;">
                                ${statuses.map(s => `
                                    <label style="display:flex;align-items:center;gap:8px; padding: 6px 8px; border: 1px solid var(--tm-border-color); border-radius: 8px; background: var(--tm-bg-color);">
                                        <span style="max-width: 140px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${esc(s.name || s.id)}</span>
                                        <input class="tm-input" style="width:110px;" type="number" value="${Number(cfg.statusDelta[s.id]) || 0}" data-tm-call="tmSetPriorityStatus" data-tm-args='["${esc(String(s.id))}"]'>
                                    </label>
                                `).join('')}
                            </div>
                            ${statuses.length === 0 ? '<div style="color: var(--tm-secondary-text); font-size: 12px;">暂无自定义状态</div>' : ''}
                        </div>
                    </div>

                    <div class="tm-rule-section" style="margin-bottom:0;">
                        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px;">
                            <div style="font-weight: 700;">完成日期接近度（按“≤ 天数”匹配）</div>
                            <button class="tm-btn tm-btn-secondary" data-tm-call="tmAddPriorityDueRange">+ 添加</button>
                        </div>
                        ${dueRows || '<div style="color: var(--tm-secondary-text);">暂无配置</div>'}
                    </div>

                    <div class="tm-rule-section" style="margin-bottom:0;">
                        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px;flex-wrap:wrap;">
                            <div style="font-weight: 700;">时长分段</div>
                            <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
                                <select class="tm-input" style="width: 160px;" data-tm-call="tmSetPriorityDurationUnit">
                                    <option value="minutes" ${durationUnit === 'minutes' ? 'selected' : ''}>分钟</option>
                                    <option value="hours" ${durationUnit === 'hours' ? 'selected' : ''}>小时（可小数）</option>
                                </select>
                                <button class="tm-btn tm-btn-secondary" data-tm-call="tmAddPriorityDurationBucket">+ 添加</button>
                            </div>
                        </div>
                        ${durRows || '<div style="color: var(--tm-secondary-text);">暂无配置</div>'}
                    </div>

                    <div class="tm-rule-section" style="margin-bottom:0;">
                        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px;">
                            <div style="font-weight: 700;">文档加减分</div>
                            <button class="tm-btn tm-btn-secondary" data-tm-call="tmAddPriorityDocDelta">+ 添加</button>
                        </div>
                        ${docRows || '<div style="color: var(--tm-secondary-text);">暂无配置</div>'}
                    </div>
                </div>
            `;
        }

        return `
            <div class="tm-box" style="width: ${embedded ? '100%' : '720px'}; height: auto; ${embedded ? '' : 'max-height: 86vh;'}">
                <div class="tm-header">
                    <div style="font-size: 16px; font-weight: 700; color: var(--tm-text-color);">⚙️ 优先级算法</div>
                    ${embedded
                        ? '<button class="tm-btn tm-btn-gray" data-tm-action="tmSwitchSettingsTab" data-tab="rules">返回</button>'
                        : '<button class="tm-btn tm-btn-gray" data-tm-action="closePriorityScoreSettings">关闭</button>'}
                </div>
                <div style="padding: 14px; overflow: auto;">
                    <div style="margin-bottom: 14px;">
                        <div style="font-weight: 700; margin-bottom: 8px;">基础分</div>
                        <input class="tm-input" type="number" value="${Number(cfg.base) || 100}" data-tm-call="tmSetPriorityBase" style="width: 160px;">
                    </div>

                    <div style="margin-bottom: 14px;">
                        <div style="font-weight: 700; margin-bottom: 8px;">权重（微调）</div>
                        <div style="display:flex;gap:10px;flex-wrap:wrap;">
                            <label style="display:flex;align-items:center;gap:6px;">重要性 <input class="tm-input" style="width:90px;" type="number" value="${Number(cfg.weights.importance) || 1}" data-tm-call="tmSetPriorityWeight" data-tm-args='["importance"]'></label>
                            <label style="display:flex;align-items:center;gap:6px;">状态 <input class="tm-input" style="width:90px;" type="number" value="${Number(cfg.weights.status) || 1}" data-tm-call="tmSetPriorityWeight" data-tm-args='["status"]'></label>
                            <label style="display:flex;align-items:center;gap:6px;">完成日期 <input class="tm-input" style="width:90px;" type="number" value="${Number(cfg.weights.due) || 1}" data-tm-call="tmSetPriorityWeight" data-tm-args='["due"]'></label>
                            <label style="display:flex;align-items:center;gap:6px;">时长 <input class="tm-input" style="width:90px;" type="number" value="${Number(cfg.weights.duration) || 1}" data-tm-call="tmSetPriorityWeight" data-tm-args='["duration"]'></label>
                            <label style="display:flex;align-items:center;gap:6px;">文档 <input class="tm-input" style="width:90px;" type="number" value="${Number(cfg.weights.doc) || 1}" data-tm-call="tmSetPriorityWeight" data-tm-args='["doc"]'></label>
                        </div>
                    </div>

                    <div style="margin-bottom: 14px;">
                        <div style="font-weight: 700; margin-bottom: 8px;">重要性加减分</div>
                        <div style="display:flex;gap:10px;flex-wrap:wrap;">
                            <label style="display:flex;align-items:center;gap:6px;">高 <input class="tm-input" style="width:90px;" type="number" value="${Number(cfg.importanceDelta.high) || 0}" data-tm-call="tmSetPriorityImportance" data-tm-args='["high"]'></label>
                            <label style="display:flex;align-items:center;gap:6px;">中 <input class="tm-input" style="width:90px;" type="number" value="${Number(cfg.importanceDelta.medium) || 0}" data-tm-call="tmSetPriorityImportance" data-tm-args='["medium"]'></label>
                            <label style="display:flex;align-items:center;gap:6px;">低 <input class="tm-input" style="width:90px;" type="number" value="${Number(cfg.importanceDelta.low) || 0}" data-tm-call="tmSetPriorityImportance" data-tm-args='["low"]'></label>
                            <label style="display:flex;align-items:center;gap:6px;">无 <input class="tm-input" style="width:90px;" type="number" value="${Number(cfg.importanceDelta.none) || 0}" data-tm-call="tmSetPriorityImportance" data-tm-args='["none"]'></label>
                        </div>
                    </div>

                    <div style="margin-bottom: 14px;">
                        <div style="font-weight: 700; margin-bottom: 8px;">状态加减分</div>
                        <div style="display:flex;gap:10px;flex-wrap:wrap;">
                            ${statuses.map(s => `
                                <label style="display:flex;align-items:center;gap:6px;">
                                    ${esc(s.name || s.id)}
                                    <input class="tm-input" style="width:90px;" type="number" value="${Number(cfg.statusDelta[s.id]) || 0}" data-tm-call="tmSetPriorityStatus" data-tm-args='["${esc(String(s.id))}"]'>
                                </label>
                            `).join('')}
                        </div>
                    </div>

                    <div style="margin-bottom: 14px;">
                        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:8px;">
                            <div style="font-weight: 700;">完成日期接近度（按“≤ 天数”匹配）</div>
                            <button class="tm-btn tm-btn-secondary" data-tm-call="tmAddPriorityDueRange">+ 添加</button>
                        </div>
                        ${dueRows || '<div style="color: var(--tm-secondary-text);">暂无配置</div>'}
                    </div>

                    <div style="margin-bottom: 14px;">
                        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:8px;flex-wrap:wrap;">
                            <div style="font-weight: 700;">时长分段</div>
                            <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
                                <select class="tm-input" style="width: 160px;" data-tm-call="tmSetPriorityDurationUnit">
                                    <option value="minutes" ${durationUnit === 'minutes' ? 'selected' : ''}>分钟</option>
                                    <option value="hours" ${durationUnit === 'hours' ? 'selected' : ''}>小时（可小数）</option>
                                </select>
                                <button class="tm-btn tm-btn-secondary" data-tm-call="tmAddPriorityDurationBucket">+ 添加</button>
                            </div>
                        </div>
                        ${durRows || '<div style="color: var(--tm-secondary-text);">暂无配置</div>'}
                    </div>

                    <div style="margin-bottom: 14px;">
                        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:8px;">
                            <div style="font-weight: 700;">文档加减分</div>
                            <button class="tm-btn tm-btn-secondary" data-tm-call="tmAddPriorityDocDelta">+ 添加</button>
                        </div>
                        ${docRows || '<div style="color: var(--tm-secondary-text);">暂无配置</div>'}
                    </div>
                </div>
                <div class="tm-settings-footer" style="padding: 12px 14px;">
                    <button class="tm-btn tm-btn-secondary" data-tm-action="closePriorityScoreSettings">取消</button>
                    <button class="tm-btn tm-btn-success" data-tm-action="savePriorityScoreSettings">保存</button>
                </div>
            </div>
        `;
    }

    function showPriorityScoreSettings() {
        if (state.priorityModal) return;
        state.priorityScoreDraft = __tmEnsurePriorityDraft();
        state.priorityModal = document.createElement('div');
        state.priorityModal.className = 'tm-modal';
        state.priorityModal.style.zIndex = '200002';
        state.priorityModal.innerHTML = __tmRenderPriorityScoreSettings(false);
        document.body.appendChild(state.priorityModal);
        __tmBindRulesManagerEvents(state.priorityModal);
    }
    window.showPriorityScoreSettings = showPriorityScoreSettings;

    function __tmRerenderPriorityScoreSettings() {
        if (state.priorityModal) {
            state.priorityModal.innerHTML = __tmRenderPriorityScoreSettings(false);
            return;
        }
        const container = state.settingsModal?.querySelector?.('#tm-priority-settings');
        if (container) container.innerHTML = __tmRenderPriorityScoreSettings(true);
    }

    window.closePriorityScoreSettings = function() {
        if (state.priorityModal) {
            state.priorityModal.remove();
            state.priorityModal = null;
            // 只有关闭独立的优先级设置模态框时才重置draft
            state.priorityScoreDraft = null;
        }
        // 在设置界面中切换Tab时，不重置draft，保留用户输入的数据
        if (state.settingsModal && state.settingsActiveTab === 'priority') {
            showSettings();
        }
    };

    window.savePriorityScoreSettings = async function() {
        if (!state.priorityScoreDraft) return;
        SettingsStore.data.priorityScoreConfig = state.priorityScoreDraft;
        await SettingsStore.save();
        __tmScheduleRender({ withFilters: true });
        closePriorityScoreSettings();
        hint('✅ 优先级算法已保存', 'success');
    };

    // 渲染四象限设置
    function renderQuadrantSettings() {
        const quadrantConfig = SettingsStore.data.quadrantConfig || {
            enabled: false,
            rules: [
                { id: 'urgent-important', name: '重要紧急', color: 'red', importance: ['high', 'medium'], timeRanges: ['overdue', 'today', 'tomorrow', 'within1days'] },
                { id: 'not-urgent-important', name: '重要不紧急', color: 'yellow', importance: ['high', 'medium'], timeRanges: ['within3days', 'beyond3days', 'within7days', 'beyond7days', 'within15days', 'beyond15days', 'within30days', 'beyond30days', 'nodate'] },
                { id: 'urgent-not-important', name: '不重要紧急', color: 'blue', importance: ['low', 'none'], timeRanges: ['overdue', 'today', 'tomorrow', 'within1days'] },
                { id: 'not-urgent-not-important', name: '不重要不紧急', color: 'green', importance: ['low', 'none'], timeRanges: ['within3days', 'beyond3days', 'within7days', 'beyond7days', 'within15days', 'beyond15days', 'within30days', 'beyond30days', 'nodate'] }
            ]
        };
        
        const rules = quadrantConfig.rules || [];
        const colorLabels = { red: '🔴 红色', yellow: '🟡 黄色', blue: '🔵 蓝色', green: '🟢 绿色' };
        const importanceLabels = { high: '高', medium: '中', low: '低', none: '无' };
        const timeRangeLabels = { 
            overdue: '已过期', 
            today: '今天', 
            tomorrow: '明天',
            within1days: '余1天以内',
            within3days: '余3天以内',
            beyond3days: '余3天以上',
            within7days: '余7天以内',
            beyond7days: '余7天以上',
            within15days: '余15天以内',
            beyond15days: '余15天以上',
            within30days: '余30天以内',
            beyond30days: '余30天以上',
            nodate: '无日期' 
        };
        
        let html = '<div style="display: flex; flex-direction: column; gap: 12px;">';
        
        rules.forEach((rule, index) => {
            const importanceNames = (rule.importance || []).map(i => importanceLabels[i] || i).join('+');
            const timeRangeNames = (rule.timeRanges || []).map(t => timeRangeLabels[t] || t).join('+');
            
            html += `
                <div style="background: var(--tm-bg-color); border: 1px solid var(--tm-border-color); border-radius: 8px; padding: 12px;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                        <span class="tm-quadrant-indicator tm-quadrant-bg-${rule.color}"></span>
                        <span style="font-weight: 600; color: var(--tm-quadrant-${rule.color});">${esc(rule.name)}</span>
                        <span style="margin-left: auto; color: var(--tm-secondary-text); font-size: 12px;">${colorLabels[rule.color]}</span>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 13px;">
                        <div style="padding: 8px; background: var(--tm-section-bg); border-radius: 4px;">
                            <div style="color: var(--tm-secondary-text); font-size: 11px; margin-bottom: 4px;">重要性</div>
                            <div>${esc(importanceNames)}</div>
                        </div>
                        <div style="padding: 8px; background: var(--tm-section-bg); border-radius: 4px;">
                            <div style="color: var(--tm-secondary-text); font-size: 11px; margin-bottom: 4px;">完成日期</div>
                            <div>${esc(timeRangeNames)}</div>
                        </div>
                    </div>
                    <div style="margin-top: 8px; display: flex; gap: 8px;">
                        <button class="tm-btn tm-btn-secondary" data-tm-call="tmEditQuadrantRule" data-tm-args='[${index}]' style="flex: 1; padding: 4px 8px; font-size: 12px;">编辑规则</button>
                        <button class="tm-btn tm-btn-secondary" data-tm-call="tmResetQuadrantRule" data-tm-args='[${index}]' style="padding: 4px 8px; font-size: 12px;">重置</button>
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
        
        html += `
            <div style="margin-top: 16px; padding: 12px; background: var(--tm-info-bg); border: 1px solid var(--tm-info-border); border-radius: 8px; font-size: 12px; color: var(--tm-secondary-text);">
                <div style="font-weight: 600; margin-bottom: 8px;">📌 使用说明</div>
                <ul style="margin: 0; padding-left: 16px;">
                    <li>在顶部工具栏启用「四象限分组」即可按此规则分组显示</li>
                    <li>任务会根据「重要性」和「完成日期」自动分配到对应象限</li>
                    <li>点击「编辑规则」可自定义每个象限的条件</li>
                    <li>点击「重置」可恢复该象限的默认配置</li>
                </ul>
            </div>
        `;
        
        return html;
    }

    // 编辑四象限规则
    window.tmEditQuadrantRule = async function(index) {
        const quadrantConfig = SettingsStore.data.quadrantConfig || {
            enabled: false,
            rules: [
                { id: 'urgent-important', name: '重要紧急', color: 'red', importance: ['high', 'medium'], timeRanges: ['overdue', 'within7days'] },
                { id: 'not-urgent-important', name: '重要不紧急', color: 'yellow', importance: ['high', 'medium'], timeRanges: ['beyond7days', 'nodate'] },
                { id: 'urgent-not-important', name: '不重要紧急', color: 'blue', importance: ['low', 'none'], timeRanges: ['overdue', 'within7days'] },
                { id: 'not-urgent-not-important', name: '不重要不紧急', color: 'green', importance: ['low', 'none'], timeRanges: ['beyond7days', 'nodate'] }
            ]
        };
        
        const rules = quadrantConfig.rules || [];
        const rule = rules[index];
        if (!rule) return;
        
        const importanceOptions = [
            { value: 'high', label: '高' },
            { value: 'medium', label: '中' },
            { value: 'low', label: '低' },
            { value: 'none', label: '无' }
        ];
        
        const timeRangeOptions = [
            { value: 'overdue', label: '已过期' },
            { value: 'within3days', label: '余3天以内' },
            { value: 'beyond3days', label: '余3天以上' },
            { value: 'within7days', label: '余7天以内' },
            { value: 'beyond7days', label: '余7天以上' },
            { value: 'within15days', label: '余15天以内' },
            { value: 'beyond15days', label: '余15天以上' },
            { value: 'within30days', label: '余30天以内' },
            { value: 'beyond30days', label: '余30天以上' },
            { value: 'nodate', label: '无日期' }
        ];
        
        // 根据象限类型过滤时间范围选项
        // 判断是否紧急象限：ID必须以 'urgent-' 开头（urgent-important, urgent-not-important）
        const isUrgent = rule.id && (rule.id.startsWith('urgent-') || rule.id === 'urgent-important' || rule.id === 'urgent-not-important');
        const filteredTimeRangeOptions = timeRangeOptions.filter(opt => {
            if (isUrgent) {
                // 紧急象限：只显示已过期、以及余X天以内
                return opt.value === 'overdue' || opt.value.startsWith('within');
            } else {
                // 不紧急象限：只显示无日期、以及余X天以上
                return opt.value === 'nodate' || opt.value.startsWith('beyond');
            }
        });
        
        const importanceCheckboxes = importanceOptions.map(opt => `
            <label style="display: inline-flex; align-items: center; gap: 4px; margin-right: 12px; margin-bottom: 6px; cursor: pointer; white-space: nowrap;">
                <input type="checkbox" value="${opt.value}" ${rule.importance?.includes(opt.value) ? 'checked' : ''} data-quadrant-importance>
                ${opt.label}
            </label>
        `).join('');
        
        const timeRangeCheckboxes = filteredTimeRangeOptions.map(opt => `
            <label style="display: inline-flex; align-items: center; gap: 4px; margin-right: 12px; margin-bottom: 6px; cursor: pointer; white-space: nowrap;">
                <input type="checkbox" value="${opt.value}" ${rule.timeRanges?.includes(opt.value) ? 'checked' : ''} data-quadrant-timerange>
                ${opt.label}
            </label>
        `).join('');
        
        const modal = document.createElement('div');
        modal.className = 'tm-prompt-modal';
        modal.innerHTML = `
            <div class="tm-prompt-box" style="width: 90%; max-width: 400px; max-height: 90vh; overflow-y: auto; box-sizing: border-box;">
                <div class="tm-prompt-title">编辑四象限规则 - ${esc(rule.name)}</div>
                <div style="margin-bottom: 16px; max-height: 60vh; overflow-y: auto;">
                    <div style="margin-bottom: 12px;">
                        <div style="font-size: 13px; font-weight: 500; margin-bottom: 6px;">重要性（可多选）</div>
                        ${importanceCheckboxes}
                    </div>
                    <div>
                        <div style="font-size: 13px; font-weight: 500; margin-bottom: 6px;">完成日期范围（可多选）</div>
                        ${timeRangeCheckboxes}
                    </div>
                </div>
                <div class="tm-prompt-buttons">
                    <button class="tm-prompt-btn tm-prompt-btn-secondary" onclick="this.closest('.tm-prompt-modal').remove()">取消</button>
                    <button class="tm-prompt-btn tm-prompt-btn-primary" id="tm-save-quadrant-rule">保存</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        document.getElementById('tm-save-quadrant-rule').onclick = async function() {
            const selectedImportance = Array.from(modal.querySelectorAll('[data-quadrant-importance]:checked')).map(cb => cb.value);
            const selectedTimeRanges = Array.from(modal.querySelectorAll('[data-quadrant-timerange]:checked')).map(cb => cb.value);
            
            if (selectedImportance.length === 0) {
                hint('⚠ 请至少选择一个重要性条件', 'warning');
                return;
            }
            
            if (selectedTimeRanges.length === 0) {
                hint('⚠ 请至少选择一个时间范围条件', 'warning');
                return;
            }
            
            rules[index].importance = selectedImportance;
            rules[index].timeRanges = selectedTimeRanges;
            
            SettingsStore.data.quadrantConfig = quadrantConfig;
            await SettingsStore.save();
            
            modal.remove();
            hint('✅ 四象限规则已更新', 'success');
            showSettings();
        };
    };

    // 重置四象限规则
    window.tmResetQuadrantRule = async function(index) {
        const defaultRules = [
            { id: 'urgent-important', name: '重要紧急', color: 'red', importance: ['high', 'medium'], timeRanges: ['overdue', 'within7days'] },
            { id: 'not-urgent-important', name: '重要不紧急', color: 'yellow', importance: ['high', 'medium'], timeRanges: ['beyond7days', 'nodate'] },
            { id: 'urgent-not-important', name: '不重要紧急', color: 'blue', importance: ['low', 'none'], timeRanges: ['overdue', 'within7days'] },
            { id: 'not-urgent-not-important', name: '不重要不紧急', color: 'green', importance: ['low', 'none'], timeRanges: ['beyond7days', 'nodate'] }
        ];
        
        const quadrantConfig = SettingsStore.data.quadrantConfig || { enabled: false, rules: defaultRules };
        const rules = quadrantConfig.rules || [];
        
        if (rules[index]) {
            rules[index] = { ...defaultRules[index] };
            SettingsStore.data.quadrantConfig = quadrantConfig;
            await SettingsStore.save();
            hint('✅ 已重置为默认值', 'success');
            showSettings();
        }
    };

    window.tmSetPriorityBase = function(value) {
        if (!state.priorityScoreDraft) return;
        state.priorityScoreDraft.base = Number(value) || 0;
    };
    window.tmSetPriorityWeight = function(key, value) {
        if (!state.priorityScoreDraft) return;
        if (!state.priorityScoreDraft.weights) state.priorityScoreDraft.weights = {};
        state.priorityScoreDraft.weights[key] = Number(value) || 0;
    };
    window.tmSetPriorityDurationUnit = function(value) {
        if (!state.priorityScoreDraft) return;
        const v = String(value || '').trim();
        state.priorityScoreDraft.durationUnit = (v === 'hours' || v === 'minutes') ? v : 'minutes';
        __tmRerenderPriorityScoreSettings();
    };
    window.tmSetPriorityImportance = function(key, value) {
        if (!state.priorityScoreDraft) return;
        if (!state.priorityScoreDraft.importanceDelta) state.priorityScoreDraft.importanceDelta = {};
        state.priorityScoreDraft.importanceDelta[key] = Number(value) || 0;
    };
    window.tmSetPriorityStatus = function(statusId, value) {
        if (!state.priorityScoreDraft) return;
        if (!state.priorityScoreDraft.statusDelta) state.priorityScoreDraft.statusDelta = {};
        state.priorityScoreDraft.statusDelta[statusId] = Number(value) || 0;
    };
    window.tmAddPriorityDueRange = function() {
        if (!state.priorityScoreDraft) return;
        if (!Array.isArray(state.priorityScoreDraft.dueRanges)) state.priorityScoreDraft.dueRanges = [];
        state.priorityScoreDraft.dueRanges.push({ days: 7, delta: 0 });
        __tmRerenderPriorityScoreSettings();
    };
    window.tmRemovePriorityDueRange = function(index) {
        if (!state.priorityScoreDraft) return;
        if (!Array.isArray(state.priorityScoreDraft.dueRanges)) return;
        state.priorityScoreDraft.dueRanges.splice(index, 1);
        __tmRerenderPriorityScoreSettings();
    };
    window.tmSetPriorityDueRange = function(index, field, value) {
        if (!state.priorityScoreDraft) return;
        if (!Array.isArray(state.priorityScoreDraft.dueRanges)) return;
        const row = state.priorityScoreDraft.dueRanges[index];
        if (!row) return;
        row[field] = Number(value) || 0;
    };
    window.tmAddPriorityDurationBucket = function() {
        if (!state.priorityScoreDraft) return;
        if (!Array.isArray(state.priorityScoreDraft.durationBuckets)) state.priorityScoreDraft.durationBuckets = [];
        state.priorityScoreDraft.durationBuckets.push({ maxMinutes: 60, delta: 0 });
        __tmRerenderPriorityScoreSettings();
    };
    window.tmRemovePriorityDurationBucket = function(index) {
        if (!state.priorityScoreDraft) return;
        if (!Array.isArray(state.priorityScoreDraft.durationBuckets)) return;
        state.priorityScoreDraft.durationBuckets.splice(index, 1);
        __tmRerenderPriorityScoreSettings();
    };
    window.tmSetPriorityDurationBucket = function(index, field, value) {
        if (!state.priorityScoreDraft) return;
        if (!Array.isArray(state.priorityScoreDraft.durationBuckets)) return;
        const row = state.priorityScoreDraft.durationBuckets[index];
        if (!row) return;
        if (field === 'maxMinutes') {
            const unit = state.priorityScoreDraft.durationUnit === 'hours' ? 'hours' : 'minutes';
            const n = Number(value);
            if (!Number.isFinite(n)) {
                row.maxMinutes = 0;
            } else {
                const mins = unit === 'hours' ? (n * 60) : n;
                row.maxMinutes = Math.max(0, mins);
            }
        } else {
            row[field] = Number(value) || 0;
        }
    };
    window.tmAddPriorityDocDelta = function() {
        if (!state.priorityScoreDraft) return;
        state.priorityDocDeltaMode = 'add';
        state.priorityDocDeltaFromDocId = '';
        window.tmPickPriorityDocDelta?.('');
    };
    window.tmSetPriorityDocDelta = function(docId, value) {
        if (!state.priorityScoreDraft) return;
        if (!state.priorityScoreDraft.docDeltas || typeof state.priorityScoreDraft.docDeltas !== 'object') state.priorityScoreDraft.docDeltas = {};
        state.priorityScoreDraft.docDeltas[docId] = Number(value) || 0;
        // 不再调用 __tmRerenderPriorityScoreSettings()，避免重新渲染导致输入框失去焦点
        // 数据已保存在 state.priorityScoreDraft 中，用户点击"应用修改"或"保存"时会持久化
    };
    window.tmUpdatePriorityDocDelta = function(oldDocId, newDocId) {
        if (!state.priorityScoreDraft) return;
        const map = (state.priorityScoreDraft.docDeltas && typeof state.priorityScoreDraft.docDeltas === 'object') ? state.priorityScoreDraft.docDeltas : {};
        const from = String(oldDocId || '').trim();
        const to = String(newDocId || '').trim();
        if (!from || !to || from === to) return;
        const val = Number(map[from] ?? 0) || 0;
        delete map[from];
        if (map[to] === undefined) map[to] = val;
        state.priorityScoreDraft.docDeltas = map;
        __tmRerenderPriorityScoreSettings();
    };
    window.tmRemovePriorityDocDelta = function(docId) {
        if (!state.priorityScoreDraft) return;
        const map = (state.priorityScoreDraft.docDeltas && typeof state.priorityScoreDraft.docDeltas === 'object') ? state.priorityScoreDraft.docDeltas : {};
        delete map[docId];
        state.priorityScoreDraft.docDeltas = map;
        __tmRerenderPriorityScoreSettings();
    };

    window.tmClosePriorityDocDeltaPicker = function() {
        if (state.priorityDocDeltaPicker) {
            try { state.priorityDocDeltaPicker.remove(); } catch (e) {}
            state.priorityDocDeltaPicker = null;
        }
    };

    window.tmPriorityDocDeltaSelectDoc = function(docId) {
        const to = String(docId || '').trim();
        if (!to) return;
        const mode = String(state.priorityDocDeltaMode || 'replace');
        if (mode === 'add') {
            if (!state.priorityScoreDraft) return;
            if (!state.priorityScoreDraft.docDeltas || typeof state.priorityScoreDraft.docDeltas !== 'object') state.priorityScoreDraft.docDeltas = {};
            if (state.priorityScoreDraft.docDeltas[to] === undefined) state.priorityScoreDraft.docDeltas[to] = 0;
            __tmRerenderPriorityScoreSettings();
        } else {
            const from = String(state.priorityDocDeltaFromDocId || '').trim();
            if (!from || from === to) return;
            try { window.tmUpdatePriorityDocDelta?.(from, to); } catch (e) {}
        }
        state.priorityDocDeltaFromDocId = '';
        state.priorityDocDeltaMode = '';
        window.tmClosePriorityDocDeltaPicker?.();
    };

    window.tmPickPriorityDocDelta = async function(oldDocId) {
        if (!state.priorityScoreDraft) return;
        window.tmClosePriorityDocDeltaPicker?.();

        const docs = state.allDocuments || [];
        const groups = SettingsStore.data.docGroups || [];
        const resolveDocName = (docId) => {
            if (!docId) return '未知文档';
            const found = docs.find(d => d.id === docId);
            if (found) return found.name || '未命名文档';
            const entry = state.taskTree?.find?.(d => d.id === docId);
            return entry?.name || '未命名文档';
        };

        const selected = String(oldDocId || '').trim();
        state.priorityDocDeltaFromDocId = selected;
        state.priorityDocDeltaMode = selected ? 'replace' : 'add';

        const picker = document.createElement('div');
        picker.className = 'tm-prompt-modal';
        picker.style.zIndex = '100011';
        picker.innerHTML = `
            <div class="tm-prompt-box" style="width:min(92vw,520px);max-height:70vh;overflow:auto;">
                <div class="tm-prompt-title" style="margin:0 0 10px 0;">选择文档</div>
                <div id="tmPriorityDocDeltaList"></div>
                <div style="display:flex;gap:8px;margin-top:10px;">
                    <button class="tm-btn tm-btn-gray" onclick="tmClosePriorityDocDeltaPicker()" style="padding: 6px 10px; font-size: 12px;">关闭</button>
                </div>
            </div>
        `;
        document.body.appendChild(picker);
        state.priorityDocDeltaPicker = picker;

        const listEl = picker.querySelector('#tmPriorityDocDeltaList');

        const renderGroup = (label, docs0, groupKey, initialOpen = false) => {
            const wrap = document.createElement('div');
            wrap.style.cssText = 'border:1px solid var(--tm-border-color);border-radius:8px;margin-bottom:8px;overflow:hidden;';
            const head = document.createElement('div');
            head.style.cssText = 'display:flex;align-items:center;justify-content:space-between;padding:8px 10px;background:var(--tm-header-bg);cursor:pointer;';
            head.innerHTML = `<div style="font-weight:600;">${esc(label)}</div><div style="opacity:0.75;">${initialOpen ? '▾' : '▸'}</div>`;
            const body = document.createElement('div');
            body.style.cssText = `padding:6px 10px;display:${initialOpen ? 'block' : 'none'};`;

            const renderDocs = (docList) => {
                body.innerHTML = '';
                if (!docList || docList.length === 0) {
                    body.innerHTML = '<div style="color:var(--tm-secondary-text);padding:8px 0;font-size:13px;">暂无文档</div>';
                    return;
                }
                docList.forEach(d => {
                    const id = String(d?.id || d || '').trim();
                    if (!id) return;
                    const row = document.createElement('div');
                    const checked = id === selected;
                    row.style.cssText = 'display:flex;align-items:center;justify-content:space-between;padding:8px 0;cursor:pointer;';
                    row.innerHTML = `<div style="min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${esc(resolveDocName(id))}</div><div style="margin-left:10px;">${checked ? '✅' : '◻️'}</div>`;
                    row.onclick = () => window.tmPriorityDocDeltaSelectDoc?.(id);
                    body.appendChild(row);
                });
            };

            if (initialOpen) renderDocs(docs0);

            head.onclick = async () => {
                const open = body.style.display !== 'none';
                if (!open) {
                    body.style.display = 'block';
                    head.lastElementChild.textContent = '▾';
                    if (groupKey) {
                        body.innerHTML = '<div style="color:var(--tm-secondary-text);padding:8px 0;font-size:13px;">🔄 加载文档中...</div>';
                        try {
                            const allSet = new Set();
                            const entries = Array.isArray(docs0) ? docs0 : [];
                            await Promise.all(entries.map(async (d) => {
                                const id = String(d?.id || d || '').trim();
                                if (!id) return;
                                allSet.add(id);
                                const rec = !!(typeof d === 'object' && d && d.recursive);
                                if (rec) {
                                    try {
                                        const subIds = await API.getSubDocIds(id);
                                        (subIds || []).forEach(sid => {
                                            const s = String(sid || '').trim();
                                            if (s) allSet.add(s);
                                        });
                                    } catch (e) {}
                                }
                            }));
                            const allIds = Array.from(allSet);

                            const tasksMap = new Map();
                            allIds.forEach(id => {
                                const treeDoc = state.taskTree.find(d => d.id === id);
                                if (treeDoc && treeDoc.tasks && treeDoc.tasks.length > 0) tasksMap.set(id, true);
                            });

                            const uncheckedIds = allIds.filter(id => !tasksMap.has(id));
                            if (uncheckedIds.length > 0) {
                                const CHUNK_SIZE = 50;
                                for (let i = 0; i < uncheckedIds.length; i += CHUNK_SIZE) {
                                    const chunk = uncheckedIds.slice(i, i + CHUNK_SIZE);
                                    const idsStr = chunk.map(id => `'${id}'`).join(',');
                                    const sql = `SELECT DISTINCT root_id FROM blocks WHERE type='i' AND subtype='t' AND root_id IN (${idsStr})`;
                                    try {
                                        const res = await API.call('/api/query/sql', { stmt: sql });
                                        if (res.code === 0 && res.data) res.data.forEach(row => tasksMap.set(row.root_id, true));
                                    } catch (e) {}
                                }
                            }

                            const docList = allIds.map(id => ({ id, hasTasks: tasksMap.has(id) })).filter(item => item.hasTasks);
                            docList.sort((a, b) => resolveDocName(a.id).localeCompare(resolveDocName(b.id)));
                            renderDocs(docList);
                        } catch (e) {
                            renderDocs(docs0);
                        }
                    } else {
                        renderDocs(docs0);
                    }
                } else {
                    body.style.display = 'none';
                    head.lastElementChild.textContent = '▸';
                }
            };

            wrap.appendChild(head);
            wrap.appendChild(body);
            return wrap;
        };

        groups.forEach(g => {
            const ds = Array.isArray(g?.docs) ? g.docs : [];
            if (ds.length === 0) return;
            listEl.appendChild(renderGroup(String(g?.name || '分组'), ds, String(g?.id || '')));
        });
    };

    function __tmRerenderRulesManagerUI(scope) {
        const html = renderRulesList();
        if (state.rulesModal) {
            if (scope === 'conditions') {
                const el = state.rulesModal.querySelector('.tm-rule-conditions');
                if (el && state.editingRule) el.innerHTML = renderConditions(state.editingRule.conditions);
            } else if (scope === 'sort') {
                const el = state.rulesModal.querySelector('.tm-rule-sort-items');
                if (el && state.editingRule) el.innerHTML = renderSortRules(state.editingRule.sort);
            } else {
                const el = state.rulesModal.querySelector('.tm-rules-body');
                if (el) el.innerHTML = html;
            }
        }
        if (state.settingsModal) {
            if (scope === 'conditions') {
                const el = state.settingsModal.querySelector('.tm-rule-conditions');
                if (el && state.editingRule) el.innerHTML = renderConditions(state.editingRule.conditions);
            } else if (scope === 'sort') {
                const el = state.settingsModal.querySelector('.tm-rule-sort-items');
                if (el && state.editingRule) el.innerHTML = renderSortRules(state.editingRule.sort);
            } else {
                const el = state.settingsModal.querySelector('#tm-rules-list');
                if (el) el.innerHTML = html;
            }
        }
    }

    window.addNewRule = function() {
        const newRule = RuleManager.createRule('新规则');
        state.editingRule = newRule;
        __tmRerenderRulesManagerUI();
    };

    window.editRule = function(ruleId) {
        const rule = state.filterRules.find(r => r.id === ruleId);
        if (rule) {
            state.editingRule = JSON.parse(JSON.stringify(rule));
            __tmRerenderRulesManagerUI();
        }
    };

    window.cancelEditRule = function() {
        state.editingRule = null;
        __tmRerenderRulesManagerUI();
    };

    window.saveEditRule = async function() {
        if (!state.editingRule) return;
        const savedRuleId = String(state.editingRule.id || '').trim();

        try {
            const fields = RuleManager.getAvailableFields();
            (state.editingRule.conditions || []).forEach(c => {
                const fieldInfo = fields.find(f => f.value === c.field);
                if (!fieldInfo || fieldInfo.type !== 'boolean') return;
                if (c.value === '' || c.value === null || typeof c.value === 'undefined') c.value = 'true';
            });
        } catch (e) {}
        
        const index = state.filterRules.findIndex(r => r.id === state.editingRule.id);
        if (index >= 0) {
            state.filterRules[index] = state.editingRule;
        } else {
            state.filterRules.push(state.editingRule);
        }
        
        state.editingRule = null;
        try { await RuleManager.saveRules(state.filterRules); } catch (e) {}
        __tmRerenderRulesManagerUI();
        if (savedRuleId && String(state.currentRule || '').trim() === savedRuleId) {
            const prevDoneOnly = !!state.__tmQueryDoneOnly;
            const nextRule = state.filterRules.find(r => r.id === savedRuleId);
            const nextDoneOnly = !!(nextRule && nextRule.conditions && nextRule.conditions.some(c => c && c.field === 'done' && c.operator === '=' && (c.value === true || String(c.value) === 'true' || c.value === '')));
            state.__tmQueryDoneOnly = nextDoneOnly;
            if (prevDoneOnly !== nextDoneOnly) {
                await loadSelectedDocuments();
                hint('✅ 规则已保存', 'success');
                return;
            }
            __tmScheduleRender({ withFilters: true });
        }
        hint('✅ 规则已保存', 'success');
    };

    window.updateEditingRuleName = function(name) {
        if (state.editingRule) {
            state.editingRule.name = name;
        }
    };

    window.addCondition = function() {
        if (!state.editingRule) return;
        
        const availableFields = RuleManager.getAvailableFields();
        const firstField = availableFields[0];
        const operators = RuleManager.getOperators(firstField.type);
        
        state.editingRule.conditions.push({
            field: firstField.value,
            operator: operators[0].value,
            value: ''
        });
        
        __tmRerenderRulesManagerUI('conditions');
    };

    window.updateConditionField = function(index, field) {
        if (state.editingRule && state.editingRule.conditions[index]) {
            state.editingRule.conditions[index].field = field;
            // 重置操作符和值为新字段的默认值
            const availableFields = RuleManager.getAvailableFields();
            const fieldInfo = availableFields.find(f => f.value === field);
            const operators = RuleManager.getOperators(fieldInfo?.type || 'text');
            state.editingRule.conditions[index].operator = operators[0].value;
            state.editingRule.conditions[index].value = (fieldInfo?.type === 'boolean') ? 'true' : '';
            
            if (state.rulesModal) {
                const conditionsDiv = state.rulesModal.querySelector('.tm-rule-conditions');
                conditionsDiv.innerHTML = renderConditions(state.editingRule.conditions);
            }
            if (state.settingsModal) {
                const conditionsDiv = state.settingsModal.querySelector('.tm-rule-conditions');
                if (conditionsDiv) conditionsDiv.innerHTML = renderConditions(state.editingRule.conditions);
            }
        }
    };

    window.updateConditionOperator = function(index, operator) {
        if (state.editingRule && state.editingRule.conditions[index]) {
            state.editingRule.conditions[index].operator = operator;

            // 如果操作符变为 between，初始化值对象
            if (operator === 'between') {
                state.editingRule.conditions[index].value = { from: '', to: '' };
            }
            // 如果操作符变为 in/not_in，初始化为数组
            else if (operator === 'in' || operator === 'not_in') {
                const fieldInfo = RuleManager.getAvailableFields().find(f => f.value === state.editingRule.conditions[index].field);
                if (fieldInfo?.type === 'select') {
                    // 初始化为所有选项都选中，或者根据当前单值转换
                    const currentValue = state.editingRule.conditions[index].value;
                    if (typeof currentValue === 'string' && currentValue && !currentValue.includes(',')) {
                        state.editingRule.conditions[index].value = [currentValue];
                    } else if (!Array.isArray(currentValue)) {
                        state.editingRule.conditions[index].value = [...(fieldInfo.options || [])];
                    }
                }
            }
            // 如果操作符从 in/not_in 变为其他，重置为单值
            else {
                const fieldInfo = RuleManager.getAvailableFields().find(f => f.value === state.editingRule.conditions[index].field);
                if (fieldInfo?.type === 'select' && Array.isArray(state.editingRule.conditions[index].value)) {
                    // 取第一个值或空
                    state.editingRule.conditions[index].value = state.editingRule.conditions[index].value[0] || '';
                }
            }
            
            // 立即重新渲染条件区域，以更新值输入框的类型
            __tmRerenderRulesManagerUI('conditions');
        }
    };

    window.updateConditionValue = function(index, value) {
        if (state.editingRule && state.editingRule.conditions[index]) {
            state.editingRule.conditions[index].value = value;
        }
    };

    // 切换多值选择的选项
    window.toggleConditionMultiValue = function(index, optionValue, isChecked) {
        if (!state.editingRule || !state.editingRule.conditions[index]) return;

        const condition = state.editingRule.conditions[index];
        let currentValues = [];

        if (Array.isArray(condition.value)) {
            currentValues = [...condition.value];
        } else if (typeof condition.value === 'string' && condition.value.includes(',')) {
            currentValues = condition.value.split(',').map(v => v.trim());
        }

        if (isChecked) {
            if (!currentValues.includes(optionValue)) {
                currentValues.push(optionValue);
            }
        } else {
            currentValues = currentValues.filter(v => v !== optionValue);
        }

        condition.value = currentValues;
    };

    window.updateConditionValueRange = function(index, key, value) {
        if (state.editingRule && state.editingRule.conditions[index]) {
            if (!state.editingRule.conditions[index].value || typeof state.editingRule.conditions[index].value !== 'object') {
                state.editingRule.conditions[index].value = { from: '', to: '' };
            }
            state.editingRule.conditions[index].value[key] = value;
        }
    };

    window.removeCondition = function(index) {
        if (state.editingRule) {
            state.editingRule.conditions.splice(index, 1);
            __tmRerenderRulesManagerUI('conditions');
        }
    };

    window.addSortRule = function() {
        if (!state.editingRule) return;
        
        state.editingRule.sort.push({
            field: 'priority',
            order: 'desc'
        });
        
        __tmRerenderRulesManagerUI('sort');
    };

    window.updateSortField = function(index, field) {
        if (state.editingRule && state.editingRule.sort[index]) {
            state.editingRule.sort[index].field = field;
        }
    };

    window.updateSortOrder = function(index, order) {
        if (state.editingRule && state.editingRule.sort[index]) {
            state.editingRule.sort[index].order = order;
        }
    };

    window.removeSortRule = function(index) {
        if (state.editingRule) {
            state.editingRule.sort.splice(index, 1);
            __tmRerenderRulesManagerUI('sort');
        }
    };

    window.moveSortRule = function(index, delta) {
        if (!state.editingRule) return;
        const list = state.editingRule.sort || [];
        const from = Number(index);
        const d = Number(delta);
        const to = from + d;
        if (!Number.isInteger(from) || !Number.isInteger(to)) return;
        if (from < 0 || from >= list.length) return;
        if (to < 0 || to >= list.length) return;
        const tmp = list[from];
        list[from] = list[to];
        list[to] = tmp;
        state.editingRule.sort = list;
        __tmRerenderRulesManagerUI('sort');
    };

    window.toggleRuleEnabled = function(ruleId, enabled) {
        const rule = state.filterRules.find(r => r.id === ruleId);
        if (rule) {
            rule.enabled = enabled;
            try {
                SettingsStore.data.filterRules = state.filterRules;
                SettingsStore.save();
            } catch (e) {}
        }
    };

    window.deleteRule = function(ruleId) {
        if (!confirm('确定要删除这个规则吗？')) return;
        
        const index = state.filterRules.findIndex(r => r.id === ruleId);
        if (index >= 0) {
            state.filterRules.splice(index, 1);
            if (state.currentRule === ruleId) {
                state.currentRule = null;
            }
            try {
                SettingsStore.data.filterRules = state.filterRules;
                if (SettingsStore.data.currentRule === ruleId) SettingsStore.data.currentRule = null;
                SettingsStore.save();
            } catch (e) {}
            __tmRerenderRulesManagerUI();
            hint('✅ 规则已删除', 'success');
        }
    };

    window.applyRuleNow = async function(ruleId) {
        const rule = state.filterRules.find(r => r.id === ruleId);
        if (rule) {
            state.currentRule = ruleId;
            SettingsStore.data.currentRule = ruleId;
            await SettingsStore.save();
            applyFilters();
            render();
            closeRulesManager();
            hint(`✅ 已应用规则: ${rule.name}`, 'success');
        }
    };

    window.closeRulesManager = function() {
        if (state.rulesModal) {
            state.rulesModal.remove();
            state.rulesModal = null;
        }
        if (state.priorityModal) {
            state.priorityModal.remove();
            state.priorityModal = null;
        }
    };

    window.saveRules = async function() {
        await RuleManager.saveRules(state.filterRules);
        // 同时保存当前选中的规则
        SettingsStore.data.currentRule = state.currentRule;
        await SettingsStore.save();
        hint('✅ 所有规则已保存', 'success');
        closeRulesManager();
    };

    function __tmIsAllRuleLike(rule) {
        if (!rule || typeof rule !== 'object') return false;
        const id = String(rule.id || '').trim().toLowerCase();
        const name = String(rule.name || '').trim().toLowerCase();
        if (id === 'all' || id === '__all__' || id === 'all_tasks' || id.includes('all')) return true;
        if (name === '全部' || name === 'all' || name === 'all tasks' || name === 'all_tasks' || name.includes('全部')) return true;
        const conds = Array.isArray(rule.conditions) ? rule.conditions.filter(Boolean) : [];
        if (conds.length === 0) return true;
        if (conds.length === 1) {
            const c = conds[0] || {};
            if (String(c.field || '') === 'done' && String(c.operator || '') === '=' && String(c.value) === '__all__') {
                return true;
            }
        }
        return false;
    }

    function __tmRuleHasExplicitSort(rule) {
        if (!rule || typeof rule !== 'object') return false;
        return Array.isArray(rule.sort) && rule.sort.length > 0;
    }

    // 修改原有的applyFilters函数以支持规则
    function applyFilters() {
        let tasks = [];
        
        // 初始化 activeDocId
        state.activeDocId = state.activeDocId || 'all';
        
        // 收集所有任务
        state.taskTree.forEach(doc => {
            // 如果选中了特定文档，只收集该文档的任务
            if (state.activeDocId !== 'all' && doc.id !== state.activeDocId) return;

            // 递归收集所有子任务，确保扁平化列表包含所有层级
            const collect = (list) => {
                list.forEach(t => {
                    tasks.push(t);
                    if (t.children && t.children.length > 0) {
                        collect(t.children);
                    }
                });
            };
            collect(doc.tasks);
        });

        const taskMap = state.flatTasks || {};
        const hasDoneAncestor = (task) => {
            let parentId = task?.parentTaskId;
            const seen = new Set();
            while (parentId) {
                if (seen.has(parentId)) break;
                seen.add(parentId);
                const parent = taskMap[parentId];
                if (!parent) break;
                if (parent.done) return true;
                parentId = parent.parentTaskId;
            }
            return false;
        };

        const rule = state.currentRule ? state.filterRules.find(r => r.id === state.currentRule) : null;
        const hasExplicitSortRule = __tmRuleHasExplicitSort(rule);
        const keepDocFlowOrder = !!state.groupByDocName && !hasExplicitSortRule;

        const currentRuleExcludesCompleted = () => {
            if (!rule || !rule.conditions || rule.conditions.length === 0) return false;
            return rule.conditions.some(condition =>
                condition.field === 'done' &&
                condition.operator === '=' &&
                String(condition.value) === 'false'
            );
        };

        const currentRuleIncludesCompleted = () => {
            if (!rule || !rule.conditions || rule.conditions.length === 0) return false;
            return rule.conditions.some(condition =>
                condition.field === 'done' &&
                condition.operator === '=' &&
                (condition.value === true || String(condition.value) === 'true' || condition.value === '')
            );
        };

        const currentRuleAllStatuses = () => {
            if (!rule || !rule.conditions || rule.conditions.length === 0) return false;
            return rule.conditions.some(condition =>
                condition.field === 'done' &&
                condition.operator === '=' &&
                String(condition.value) === '__all__'
            );
        };

        const excludeCompleted = state.excludeCompletedTasks && !currentRuleIncludesCompleted() && !currentRuleAllStatuses();

        // 过滤逻辑：
        // 1. 未完成父任务下的所有子任务（无论是否完成）保留显示
        // 2. 如果 excludeCompleted 开启，已完成根任务：过滤
        // 3. 已完成父任务下的所有子任务：过滤
        // 4. 如果 excludeCompleted 开启且当前规则没有排除已完成，则已完成子任务（父任务未完成）保留显示
        const ruleExcludesCompleted = currentRuleExcludesCompleted();
        tasks = tasks.filter(t => {
            // 排除已完成任务时，已完成根任务才过滤
            if (excludeCompleted && t.done && !t.parentTaskId) return false;

            // 父任务已完成：过滤
            if (excludeCompleted && hasDoneAncestor(t)) return false;

            // 已完成子任务（父任务未完成）的处理
            if (excludeCompleted && t.done && t.parentTaskId) {
                // 如果当前规则没有明确排除已完成任务，则保留显示已完成子任务
                if (!ruleExcludesCompleted) return true;
                // 如果当前规则明确排除已完成任务，则过滤
                return false;
            }

            return true;
        });

        tasks.forEach(t => {
            try { t.priorityScore = __tmComputePriorityScore(t); } catch (e) { t.priorityScore = 0; }
        });

        let matched = tasks;
        if (rule) {
            matched = RuleManager.applyRuleFilter(matched, rule);
        }

        if (state.searchKeyword) {
            const keyword = state.searchKeyword.toLowerCase();
            matched = matched.filter(task => String(task.content || '').toLowerCase().includes(keyword));
        }

        const matchedSet = new Set();
        matched.forEach(t => matchedSet.add(t.id));

        const ancestorSet = new Set();
        try {
            matched.forEach(t => {
                let parentId = t?.parentTaskId;
                const seen = new Set();
                while (parentId) {
                    if (seen.has(parentId)) break;
                    seen.add(parentId);
                    const p = taskMap[parentId];
                    if (!p) break;
                    ancestorSet.add(p.id);
                    parentId = p.parentTaskId;
                }
            });
        } catch (e) {}

        const ordered = [];
        const added = new Set();
        const traverse = (list, ancestorMatched = false) => {
            const siblings = keepDocFlowOrder
                ? [...(list || [])].sort(__tmCompareTasksByDocFlow)
                : RuleManager.applyRuleSort(list || [], rule);
            siblings.forEach(t => {
                if (!t) return;
                // 如果任务本身已完成且有已完成祖先，则不显示（这是合理的）
                // 但已完成子任务（父任务未完成）应该显示，所以不能在这里过滤
                // 这里只检查是否已存在于 matchedSet（由规则筛选结果决定）
                const isMatched = matchedSet.has(t.id);
                const isAncestor = ancestorSet.has(t.id);
                const show = isMatched || isAncestor || ancestorMatched;
                if (show && !added.has(t.id)) {
                    added.add(t.id);
                    ordered.push(t);
                }
                // 无论任务是否完成，都需要处理子任务
                if (t.children && t.children.length > 0) {
                    traverse(t.children, ancestorMatched || isMatched);
                }
            });
        };

        if (state.activeDocId === 'all') {
            // 全部模式下：先收集所有任务，再进行全局排序
            // 这样排序规则 > 文档分组
            
            // 收集所有文档的所有任务到一个扁平数组
            const allTasks = [];
            const collectAll = (list) => {
                const siblings = keepDocFlowOrder
                    ? [...(list || [])].sort(__tmCompareTasksByDocFlow)
                    : (list || []);
                siblings.forEach(t => {
                    allTasks.push(t);
                    if (t.children && t.children.length > 0) {
                        collectAll(t.children);
                    }
                });
            };
            state.taskTree.forEach(doc => {
                collectAll(doc.tasks || []);
            });
            
            // 确保所有任务都有 priorityScore（排序需要）
            allTasks.forEach(t => {
                try { t.priorityScore = __tmComputePriorityScore(t); } catch (e) { t.priorityScore = 0; }
            });
            
            // 对所有任务应用排序规则
            const sortedAllTasks = keepDocFlowOrder
                ? allTasks
                : RuleManager.applyRuleSort(allTasks, rule);
            
            // 筛选并保持排序后的顺序
            const globalAdded = new Set();
            sortedAllTasks.forEach(t => {
                if (!t) return;

                // 检查是否应该过滤（与之前的过滤逻辑保持一致）
                let shouldFilter = false;

                // 已完成根任务且开启了排除已完成
                if (excludeCompleted && t.done && !t.parentTaskId) {
                    shouldFilter = true;
                }
                // 父任务已完成
                else if (excludeCompleted && hasDoneAncestor(t)) {
                    shouldFilter = true;
                }
                // 已完成子任务（父任务未完成）的处理
                else if (excludeCompleted && t.done && t.parentTaskId && !hasDoneAncestor(t)) {
                    // 如果当前规则没有明确排除已完成任务，则保留显示已完成子任务
                    if (ruleExcludesCompleted) {
                        shouldFilter = true;
                    }
                }

                if (shouldFilter) return;
                
                const isMatched = matchedSet.has(t.id);
                const isAncestor = ancestorSet.has(t.id);
                if (isMatched || isAncestor) {
                    if (!globalAdded.has(t.id)) {
                        globalAdded.add(t.id);
                        ordered.push(t);
                    }
                }
            });
        } else {
            // 单个文档模式下：保持原有逻辑
            state.taskTree.forEach(doc => {
                if (state.activeDocId !== 'all' && doc.id !== state.activeDocId) return;
                traverse(doc.tasks || [], false);
            });
        }

        const finalOrdered = __tmApplyWhiteboardSequenceFilter(ordered);
        state.filteredTasks = finalOrdered;
        try { window.dispatchEvent(new CustomEvent('tm:filtered-tasks-updated')); } catch (e) {}
    }

    function __tmIsTaskAndDescDone(taskId, memo, visiting) {
        const id = String(taskId || '').trim();
        if (!id) return true;
        const m = (memo && typeof memo === 'object') ? memo : {};
        if (Object.prototype.hasOwnProperty.call(m, id)) return !!m[id];
        const v = visiting instanceof Set ? visiting : new Set();
        if (v.has(id)) return true;
        v.add(id);
        const t = state.flatTasks?.[id];
        if (!t) {
            m[id] = true;
            v.delete(id);
            return true;
        }
        if (!t.done) {
            m[id] = false;
            v.delete(id);
            return false;
        }
        const kids = Array.isArray(t.children) ? t.children : [];
        for (const c of kids) {
            const cid = String(c?.id || '').trim();
            if (!cid) continue;
            if (!__tmIsTaskAndDescDone(cid, m, v)) {
                m[id] = false;
                v.delete(id);
                return false;
            }
        }
        m[id] = true;
        v.delete(id);
        return true;
    }

    function __tmIsTaskAndDescDoneForSequence(taskId, memo, visiting, options = {}) {
        const id = String(taskId || '').trim();
        if (!id) return true;
        const m = (memo && typeof memo === 'object') ? memo : {};
        if (Object.prototype.hasOwnProperty.call(m, id)) return !!m[id];
        const v = visiting instanceof Set ? visiting : new Set();
        if (v.has(id)) return true;
        v.add(id);
        const t = state.flatTasks?.[id];
        if (!t) {
            m[id] = true;
            v.delete(id);
            return true;
        }
        if (!t.done) {
            m[id] = false;
            v.delete(id);
            return false;
        }
        const ignoreChildRoots = (options && options.ignoreChildRoots instanceof Set) ? options.ignoreChildRoots : new Set();
        const kids = Array.isArray(t.children) ? t.children : [];
        for (const c of kids) {
            const cid = String(c?.id || '').trim();
            if (!cid) continue;
            if (ignoreChildRoots.has(cid)) continue;
            if (!__tmIsTaskAndDescDoneForSequence(cid, m, v, options)) {
                m[id] = false;
                v.delete(id);
                return false;
            }
        }
        m[id] = true;
        v.delete(id);
        return true;
    }

    function __tmCollectSequenceDescendants(rootId, allowedSet, excludedChildRoots) {
        const root = String(rootId || '').trim();
        if (!root) return [];
        const allowed = allowedSet instanceof Set ? allowedSet : new Set();
        const excluded = excludedChildRoots instanceof Set ? excludedChildRoots : new Set();
        const out = [];
        const seen = new Set();
        const stack = [];
        const t0 = state.flatTasks?.[root];
        (Array.isArray(t0?.children) ? t0.children : []).forEach((c) => {
            const cid = String(c?.id || '').trim();
            if (cid) stack.push(cid);
        });
        while (stack.length) {
            const id = String(stack.pop() || '').trim();
            if (!id || seen.has(id)) continue;
            seen.add(id);
            if (excluded.has(id)) continue;
            if (!allowed.has(id)) continue;
            out.push(id);
            const t = state.flatTasks?.[id];
            const kids = Array.isArray(t?.children) ? t.children : [];
            kids.forEach((c) => {
                const cid = String(c?.id || '').trim();
                if (cid) stack.push(cid);
            });
        }
        return out;
    }

    function __tmCollectCyclicNodes(nodes, adj) {
        const color = new Map();
        const stack = [];
        const cycleNodes = new Set();
        const markCycleFrom = (startId) => {
            let hit = false;
            for (const sid of stack) {
                if (sid === startId) hit = true;
                if (hit) cycleNodes.add(sid);
            }
            cycleNodes.add(startId);
        };
        const dfs = (u) => {
            color.set(u, 1);
            stack.push(u);
            const outs = Array.isArray(adj.get(u)) ? adj.get(u) : [];
            for (const v of outs) {
                if (!nodes.has(v)) continue;
                const c = Number(color.get(v) || 0);
                if (c === 0) dfs(v);
                else if (c === 1) markCycleFrom(v);
            }
            stack.pop();
            color.set(u, 2);
        };
        nodes.forEach((id) => {
            if (Number(color.get(id) || 0) === 0) dfs(id);
        });
        return cycleNodes;
    }

    function __tmBuildWhiteboardSequenceVisibleTaskSet(candidateTasks) {
        const list = Array.isArray(candidateTasks) ? candidateTasks : [];
        if (!list.length) return null;
        const orderMap = new Map(list.map((t, i) => [String(t?.id || '').trim(), i]));
        const taskIds = Array.from(orderMap.keys()).filter(Boolean);
        if (!taskIds.length) return null;

        const byDoc = new Map();
        taskIds.forEach((id) => {
            const did = String(__tmGetTaskDocIdById(id) || state.flatTasks?.[id]?.docId || state.flatTasks?.[id]?.root_id || '').trim();
            if (!did) return;
            if (!byDoc.has(did)) byDoc.set(did, new Set());
            byDoc.get(did).add(id);
        });
        if (!byDoc.size) return null;

        const manualLinks = __tmGetManualTaskLinks();
        const visible = new Set();

        byDoc.forEach((nodes, docId) => {
            const linkedDetachedChildren = new Set();
            manualLinks.forEach((ln) => {
                const did = String(ln?.docId || '').trim();
                if (did !== docId) return;
                const from = String(ln?.from || '').trim();
                const to = String(ln?.to || '').trim();
                [from, to].forEach((id) => {
                    if (!id || !nodes.has(id)) return;
                    const pid = String(__tmResolveWhiteboardTaskParentId(id) || '').trim();
                    if (!pid || !nodes.has(pid)) return;
                    if (!__tmIsWhiteboardChildDetached(id)) return;
                    linkedDetachedChildren.add(id);
                });
            });

            const seqNodes = new Set();
            nodes.forEach((id) => {
                const pid = String(__tmResolveWhiteboardTaskParentId(id) || '').trim();
                const hasParentInScope = !!(pid && nodes.has(pid));
                if (!hasParentInScope || linkedDetachedChildren.has(id)) seqNodes.add(id);
            });
            if (!seqNodes.size) return;

            const adj = new Map();
            seqNodes.forEach((id) => {
                adj.set(id, []);
            });
            manualLinks.forEach((ln) => {
                const did = String(ln?.docId || '').trim();
                if (did !== docId) return;
                const from = String(ln?.from || '').trim();
                const to = String(ln?.to || '').trim();
                if (!from || !to || from === to) return;
                if (!seqNodes.has(from) || !seqNodes.has(to)) return;
                const arr = adj.get(from);
                if (!Array.isArray(arr)) return;
                if (arr.includes(to)) return;
                arr.push(to);
            });

            const addVisibleWithChildren = (id) => {
                const k = String(id || '').trim();
                if (!k) return;
                visible.add(k);
                __tmCollectSequenceDescendants(k, nodes, linkedDetachedChildren).forEach((cid) => visible.add(cid));
            };

            const cyclic = __tmCollectCyclicNodes(seqNodes, adj);
            cyclic.forEach((id) => addVisibleWithChildren(id));

            const dagNodes = new Set(Array.from(seqNodes).filter((id) => !cyclic.has(id)));
            if (!dagNodes.size) return;

            const indeg2 = new Map();
            dagNodes.forEach((id) => indeg2.set(id, 0));
            dagNodes.forEach((from) => {
                const outs = Array.isArray(adj.get(from)) ? adj.get(from) : [];
                outs.forEach((to) => {
                    if (!dagNodes.has(to)) return;
                    indeg2.set(to, Number(indeg2.get(to) || 0) + 1);
                });
            });

            const layers = [];
            const seen = new Set();
            let frontier = Array.from(dagNodes).filter((id) => Number(indeg2.get(id) || 0) === 0);
            while (frontier.length) {
                frontier.sort((a, b) => (orderMap.get(a) ?? 999999) - (orderMap.get(b) ?? 999999));
                layers.push(frontier.slice());
                const next = [];
                frontier.forEach((u) => {
                    seen.add(u);
                    const outs = Array.isArray(adj.get(u)) ? adj.get(u) : [];
                    outs.forEach((v) => {
                        if (!dagNodes.has(v)) return;
                        const nv = Number(indeg2.get(v) || 0) - 1;
                        indeg2.set(v, nv);
                        if (nv === 0) next.push(v);
                    });
                });
                frontier = Array.from(new Set(next));
            }
            const leftovers = Array.from(dagNodes).filter((id) => !seen.has(id));
            if (leftovers.length) {
                leftovers.sort((a, b) => (orderMap.get(a) ?? 999999) - (orderMap.get(b) ?? 999999));
                layers.push(leftovers);
            }
            if (!layers.length) return;

            const doneMemo = {};
            let currentLayerIdx = layers.findIndex((layer) => !layer.every((id) => __tmIsTaskAndDescDoneForSequence(id, doneMemo, new Set(), { ignoreChildRoots: linkedDetachedChildren })));
            if (currentLayerIdx < 0) currentLayerIdx = layers.length - 1;
            (layers[currentLayerIdx] || []).forEach((id) => addVisibleWithChildren(id));
        });

        return visible;
    }

    function __tmApplyWhiteboardSequenceFilter(tasks) {
        const list = Array.isArray(tasks) ? tasks : [];
        if (!list.length) return list;
        if (state.viewMode === 'whiteboard') return list;
        if (!SettingsStore.data.whiteboardSequenceMode) return list;
        const visibleSet = __tmBuildWhiteboardSequenceVisibleTaskSet(list);
        if (!(visibleSet instanceof Set) || !visibleSet.size) return list;
        return list.filter((t) => visibleSet.has(String(t?.id || '').trim()));
    }

    window.tmSwitchDoc = function(docId) {
        if (Number(state.suppressDocTabClickUntil || 0) > Date.now()) return;
        state.activeDocId = docId;
        applyFilters();
        render();
        if (state.viewMode === 'whiteboard') {
            try {
                requestAnimationFrame(() => {
                    try { window.tmWhiteboardResetView?.(); } catch (e) {}
                });
            } catch (e) {}
        }
    };

    function __tmHideDocTabMenu() {
        const menu = document.getElementById('tm-doc-tab-menu');
        if (menu) menu.remove();
        if (state.docTabMenuCloseHandler) {
            try { document.removeEventListener('click', state.docTabMenuCloseHandler); } catch (e) {}
            try { document.removeEventListener('contextmenu', state.docTabMenuCloseHandler); } catch (e) {}
            state.docTabMenuCloseHandler = null;
        }
    }

    function __tmGetDocPinnedIdsForGroup(groupId) {
        const gid = String(groupId || 'all').trim() || 'all';
        const map0 = SettingsStore.data?.docPinnedByGroup;
        const map = (map0 && typeof map0 === 'object' && !Array.isArray(map0)) ? map0 : {};
        const list0 = Array.isArray(map[gid]) ? map[gid] : [];
        return list0.map(id => String(id || '').trim()).filter(Boolean);
    }

    function __tmIsDocPinnedInGroup(docId, groupId) {
        const id = String(docId || '').trim();
        if (!id) return false;
        return __tmGetDocPinnedIdsForGroup(groupId).includes(id);
    }

    function __tmSortDocEntriesByPinned(docEntries, groupId) {
        const list = Array.isArray(docEntries) ? [...docEntries] : [];
        if (list.length <= 1) return list;
        const pinned = __tmGetDocPinnedIdsForGroup(groupId);
        if (!pinned.length) return list;
        const rank = new Map();
        pinned.forEach((id, idx) => rank.set(String(id || '').trim(), idx));
        return list.sort((a, b) => {
            const aId = String((a && typeof a === 'object') ? (a.id || '') : (a || '')).trim();
            const bId = String((b && typeof b === 'object') ? (b.id || '') : (b || '')).trim();
            const ai = rank.has(aId) ? rank.get(aId) : -1;
            const bi = rank.has(bId) ? rank.get(bId) : -1;
            if (ai >= 0 && bi >= 0) return ai - bi;
            if (ai >= 0) return -1;
            if (bi >= 0) return 1;
            return 0;
        });
    }

    async function __tmSetDocPinnedForGroup(docId, pinned, groupId) {
        const id = String(docId || '').trim();
        const gid = String(groupId || 'all').trim() || 'all';
        if (!id) return;
        const map0 = SettingsStore.data.docPinnedByGroup;
        const map = (map0 && typeof map0 === 'object' && !Array.isArray(map0)) ? map0 : {};
        const list0 = Array.isArray(map[gid]) ? map[gid] : [];
        const next = list0.map(x => String(x || '').trim()).filter(Boolean).filter(x => x !== id);
        if (pinned) next.unshift(id);
        map[gid] = next;
        SettingsStore.data.docPinnedByGroup = map;
        await SettingsStore.save();
    }

    function __tmShowDocTabMenuAt(docId, x, y) {
        const id = String(docId || '').trim();
        if (!id || id === 'all') return;
        __tmHideDocTabMenu();

        const menu = document.createElement('div');
        menu.id = 'tm-doc-tab-menu';
        menu.style.cssText = `
            position: fixed;
            top: ${Math.max(8, Number(y) || 0)}px;
            left: ${Math.max(8, Number(x) || 0)}px;
            background: var(--b3-theme-background);
            border: 1px solid var(--b3-theme-surface-light);
            border-radius: 6px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.22);
            padding: 6px 0;
            z-index: 200000;
            min-width: 160px;
            user-select: none;
        `;

        const name = state.taskTree?.find?.(d => d.id === id)?.name
            || state.allDocuments?.find?.(d => d.id === id)?.name
            || id;

        const title = document.createElement('div');
        title.textContent = String(name || '文档');
        title.style.cssText = 'padding: 6px 12px; font-size: 12px; opacity: 0.75; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;';
        menu.appendChild(title);

        const hr = document.createElement('hr');
        hr.style.cssText = 'margin: 4px 0; border: none; border-top: 1px solid var(--b3-theme-surface-light);';
        menu.appendChild(hr);

        const item = (text, onClick) => {
            const el = document.createElement('div');
            el.textContent = text;
            el.style.cssText = 'padding: 8px 12px; cursor: pointer; font-size: 13px;';
            el.onmouseenter = () => el.style.backgroundColor = 'var(--b3-theme-surface-light)';
            el.onmouseleave = () => el.style.backgroundColor = 'transparent';
            el.onclick = (e) => {
                try { e.stopPropagation(); } catch (e2) {}
                __tmHideDocTabMenu();
                try { onClick?.(); } catch (e2) {}
            };
            return el;
        };

        const map = (SettingsStore.data.docColorMap && typeof SettingsStore.data.docColorMap === 'object') ? SettingsStore.data.docColorMap : (SettingsStore.data.docColorMap = {});
        const existing = __tmNormalizeHexColor(map[id], '');
        const pinGroupId = String(SettingsStore.data.currentGroupId || 'all').trim() || 'all';
        const pinnedInGroup = __tmIsDocPinnedInGroup(id, pinGroupId);

        menu.appendChild(item('📖 打开文档', async () => {
            await window.tmOpenDocById?.(id);
        }));

        menu.appendChild(item(pinnedInGroup ? '📌 取消钉住' : '📌 钉住到最左侧', async () => {
            await __tmSetDocPinnedForGroup(id, !pinnedInGroup, pinGroupId);
            await loadSelectedDocuments();
        }));

        menu.appendChild(item('🎨 设置颜色…', () => {
            const initial = existing || __tmGetDocColorHex(id, __tmIsDarkMode());
            __tmOpenColorPickerDialog('文档颜色', initial, async (next) => {
                const v = __tmNormalizeHexColor(next, '');
                if (!v) return;
                map[id] = v;
                try { await SettingsStore.save(); } catch (e) {}
                render();
            }, { defaultColor: initial });
        }));

        menu.appendChild(item('♻ 恢复自动颜色', async () => {
            if (map[id]) delete map[id];
            try { await SettingsStore.save(); } catch (e) {}
            render();
        }));

        menu.appendChild(item('🎲 重新随机未自定义颜色', async () => {
            SettingsStore.data.docColorSeed = Math.floor(Math.random() * 1000000000) + 1;
            try { await SettingsStore.save(); } catch (e) {}
            render();
        }));

        document.body.appendChild(menu);

        const closeHandler = (ev) => {
            try {
                if (menu.contains(ev.target)) return;
            } catch (e) {}
            __tmHideDocTabMenu();
        };
        state.docTabMenuCloseHandler = closeHandler;
        setTimeout(() => {
            document.addEventListener('click', closeHandler);
            document.addEventListener('contextmenu', closeHandler);
        }, 0);
    }

    window.tmShowDocTabContextMenu = function(event, docId) {
        try { event?.preventDefault?.(); } catch (e) {}
        try { event?.stopPropagation?.(); } catch (e) {}
        __tmShowDocTabMenuAt(docId, event?.clientX, event?.clientY);
    };

    window.tmDocTabTouchStart = function(event, docId) {
        if (!__tmIsMobileDevice()) return;
        try { state.docTabTouchMoved = false; } catch (e) {}
        try { if (state.docTabLongPressTimer) clearTimeout(state.docTabLongPressTimer); } catch (e) {}
        const t = event?.touches?.[0];
        const x = t?.clientX;
        const y = t?.clientY;
        try { state.docTabTouchStartX = Number(x) || 0; } catch (e) {}
        try { state.docTabTouchStartY = Number(y) || 0; } catch (e) {}
        state.docTabLongPressTimer = setTimeout(() => {
            if (state.docTabTouchMoved) return;
            __tmShowDocTabMenuAt(docId, x, y);
        }, 520);
    };

    window.tmDocTabTouchMove = function(event) {
        if (!__tmIsMobileDevice()) return;
        const t = event?.touches?.[0];
        const x = Number(t?.clientX) || 0;
        const y = Number(t?.clientY) || 0;
        const dx = x - (Number(state.docTabTouchStartX) || 0);
        const dy = y - (Number(state.docTabTouchStartY) || 0);
        if (Math.abs(dx) + Math.abs(dy) > 10) state.docTabTouchMoved = true;
    };

    window.tmDocTabTouchEnd = function() {
        if (!__tmIsMobileDevice()) return;
        try { if (state.docTabLongPressTimer) clearTimeout(state.docTabLongPressTimer); } catch (e) {}
        state.docTabLongPressTimer = null;
        state.docTabTouchMoved = false;
    };

    function __tmEnsureDocTabTouchDelegation() {
        try { if (state.docTabTouchDelegationBound) return; } catch (e) {}
        state.docTabTouchDelegationBound = true;
        const start = (ev) => {
            const el = ev?.target?.closest?.('.tm-doc-tab[data-tm-doc-id]');
            if (!el) return;
            const docId = String(el.getAttribute('data-tm-doc-id') || '').trim();
            if (!docId) return;
            state.docTabTouchActive = true;
            state.docTabTouchActiveDocId = docId;
            tmDocTabTouchStart(ev, docId);
        };
        const move = (ev) => {
            if (!state.docTabTouchActive) return;
            tmDocTabTouchMove(ev);
        };
        const end = () => {
            if (!state.docTabTouchActive) return;
            state.docTabTouchActive = false;
            state.docTabTouchActiveDocId = null;
            tmDocTabTouchEnd();
        };
        const opts = { passive: true };
        state.docTabTouchDelegationHandlers = { start, move, end };
        state.docTabTouchDelegationOptions = opts;
        document.addEventListener('touchstart', start, opts);
        document.addEventListener('touchmove', move, opts);
        document.addEventListener('touchend', end, opts);
        document.addEventListener('touchcancel', end, opts);
    }

    // 搜索弹窗
    window.tmShowSearchModal = function() {
        const modal = document.createElement('div');
        modal.className = 'tm-modal';
        modal.style.zIndex = '200001'; // 高于主界面
        modal.innerHTML = `
            <div class="tm-box" style="width: 500px; height: auto; max-height: 80vh; position: relative;">
                <div class="tm-header">
                    <div style="font-size: 18px; font-weight: bold; color: var(--tm-text-color);">🔍 搜索任务</div>
                    <button class="tm-btn tm-btn-gray" onclick="this.closest('.tm-modal').remove()">关闭</button>
                </div>
                <div style="padding: 20px;">
                    <input type="text" id="tmPopupSearchInput" class="tm-input" 
                           placeholder="输入关键词搜索..." 
                           value="${state.searchKeyword}" 
                           style="width: 100%; margin-bottom: 15px; font-size: 16px; padding: 8px;">
                    <div style="display: flex; justify-content: flex-end; gap: 10px;">
                         <button class="tm-btn tm-btn-secondary" onclick="tmSearch(''); this.closest('.tm-modal').remove()">清除搜索</button>
                         <button class="tm-btn tm-btn-primary" onclick="tmSearch(document.getElementById('tmPopupSearchInput').value); this.closest('.tm-modal').remove()">搜索</button>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        // 自动聚焦
        setTimeout(() => modal.querySelector('input').focus(), 50);
        
        // 回车搜索
        const input = modal.querySelector('input');
        input.onkeyup = (e) => {
            if (e.key === 'Enter') {
                tmSearch(input.value);
                modal.remove();
            }
        };
    };

    window.tmSearch = function(keyword) {
        const next = String(keyword || '').trim();
        state.searchKeyword = next;
        applyFilters();
        render();
    };

    window.tmSwitchDocGroup = async function(groupId) {
        const nextGroupId = String(groupId || 'all').trim() || 'all';
        const prevGroupId = String(SettingsStore.data.currentGroupId || 'all').trim() || 'all';
        if (nextGroupId === prevGroupId) {
            try { __tmHideMobileMenu(); } catch (e) {}
            return;
        }
        SettingsStore.data.currentGroupId = nextGroupId;
        // 切换文档分组后，统一回到“全部文档”页签，避免白板停留在旧分组文档导致空白
        state.activeDocId = 'all';
        state.whiteboardSelectedTaskId = '';
        state.whiteboardSelectedNoteId = '';
        state.whiteboardSelectedLinkId = '';
        state.whiteboardSelectedLinkDocId = '';
        state.whiteboardMultiSelectedTaskIds = [];
        state.whiteboardMultiSelectedNoteIds = [];

        const firstRuleId = (state.filterRules || []).find(r => r && r.enabled)?.id || '';
        state.currentRule = firstRuleId || null;
        SettingsStore.data.currentRule = firstRuleId || null;

        await SettingsStore.save();
        try { __tmHideMobileMenu(); } catch (e) {}
        await loadSelectedDocuments();
        if (state.viewMode === 'whiteboard') {
            try {
                requestAnimationFrame(() => {
                    try { window.tmWhiteboardResetView?.(); } catch (e) {}
                });
            } catch (e) {}
        }
    };

    window.tmDocTabDragOver = function(ev) {
        try {
            ev.preventDefault?.();
            ev.stopPropagation?.();
            ev.dataTransfer.dropEffect = 'move';
        } catch (e) {}
        try { ev.currentTarget?.classList?.add('is-drop-target'); } catch (e) {}
    };

    window.tmDocTabDragEnter = function(ev) {
        try {
            ev.preventDefault?.();
            ev.stopPropagation?.();
            ev.dataTransfer.dropEffect = 'move';
        } catch (e) {}
        try { ev.currentTarget?.classList?.add('is-drop-target'); } catch (e) {}
    };

    window.tmDocTabDragLeave = function(ev) {
        try {
            const cur = ev?.currentTarget;
            const rel = ev?.relatedTarget;
            if (cur instanceof Element && rel instanceof Element && cur.contains(rel)) return;
        } catch (e) {}
        try { ev.currentTarget?.classList?.remove('is-drop-target'); } catch (e) {}
    };

    function __tmGetDraggedTaskId(ev) {
        let taskId = '';
        try {
            taskId = String(ev?.dataTransfer?.getData?.('application/x-tm-task-id') || '').trim();
            if (taskId) return taskId;
        } catch (e) {}
        try {
            const raw = String(ev?.dataTransfer?.getData?.('text/plain') || '').trim();
            if (raw && !raw.startsWith('{') && !raw.startsWith('[')) {
                taskId = raw;
            }
        } catch (e) {}
        if (!taskId) taskId = String(state.draggingTaskId || '').trim();
        if (!taskId) return '';
        return state.flatTasks?.[taskId] ? taskId : '';
    }

    function __tmClearDocTabDropTarget() {
        try {
            state.modal?.querySelectorAll?.('.tm-doc-tab.is-drop-target')?.forEach?.((el) => {
                try { el.classList.remove('is-drop-target'); } catch (e) {}
            });
        } catch (e) {}
    }

    async function __tmMoveTaskToDoc(taskId, targetDocId, opts = {}) {
        const id = String(taskId || '').trim();
        const did = String(targetDocId || '').trim();
        if (!id || !did) return false;
        const o = (opts && typeof opts === 'object') ? opts : {};
        const t = state.flatTasks?.[id];
        const fromDocId = String(t?.docId || t?.root_id || '').trim();
        if (fromDocId && fromDocId === did) return false;
        const topListId = await API.getFirstDirectChildListIdOfDoc(did);
        if (topListId) {
            await API.moveBlock(id, { parentID: topListId });
        } else {
            await API.moveBlock(id, { parentID: did });
        }
        try { await API.call('/api/sqlite/flushTransaction', {}); } catch (e) {}
        try {
            if (t) {
                t.root_id = did;
                t.docId = did;
                const name = state.allDocuments.find(d => d.id === did)?.name || '';
                if (name) {
                    t.doc_name = name;
                    t.docName = name;
                }
            }
        } catch (e) {}
        if (!o.silentHint) {
            try { hint('✅ 任务已移动', 'success'); } catch (e) {}
        }
        return true;
    }

    window.tmDocTabDrop = async function(ev, docId) {
        try {
            ev.preventDefault?.();
            ev.stopPropagation?.();
        } catch (e) {}
        state.suppressDocTabClickUntil = Date.now() + 300;
        try { ev.currentTarget?.classList?.remove('is-drop-target'); } catch (e) {}
        try { __tmClearDocTabDropTarget(); } catch (e) {}
        const targetDocId = String(docId || '').trim();
        if (!targetDocId || targetDocId === 'all') return;
        const taskId = __tmGetDraggedTaskId(ev);
        if (!taskId) return;
        const task = state.flatTasks?.[taskId];
        if (!task) return;
        const fromDocId = String(task.docId || task.root_id || '').trim();
        if (fromDocId && fromDocId === targetDocId) return;
        try {
            hint('🔄 正在移动任务...', 'info');
            await __tmMoveTaskToDoc(taskId, targetDocId, { silentHint: true });
            hint('✅ 任务已移动', 'success');
            await loadSelectedDocuments();
        } catch (e) {
            hint(`❌ 移动失败: ${e.message}`, 'error');
        }
    };

    window.tmDragTaskStart = function(ev, taskId) {
        const id = String(taskId || '').trim();
        if (!id) return;
        state.draggingTaskId = id;
        let meta = null;
        try {
            if (typeof window.tmCalendarGetTaskDragMeta === 'function') {
                meta = window.tmCalendarGetTaskDragMeta(id);
            }
        } catch (e) {}
        const calendarId = String(meta?.calendarId || '').trim();
        const durationMin = Number(meta?.durationMin);
        const title = String(meta?.title || '').trim();
        try {
            const row = (ev?.currentTarget instanceof Element)
                ? ev.currentTarget.closest?.('tr[data-id], .tm-kanban-card[data-id], .tm-whiteboard-pool-item[data-task-id], .tm-whiteboard-node[data-task-id]')
                : null;
            if (row && calendarId) row.setAttribute('data-calendar-id', calendarId);
        } catch (e) {}
        try {
            ev.dataTransfer.effectAllowed = 'move';
            ev.dataTransfer.setData('application/x-tm-task-id', id);
            ev.dataTransfer.setData('application/x-tm-task', JSON.stringify({
                id,
                title: title || id,
                durationMin: (Number.isFinite(durationMin) && durationMin > 0) ? Math.round(durationMin) : 60,
                calendarId: calendarId || 'default',
            }));
            ev.dataTransfer.setData('text/plain', id);
        } catch (e) {}
    };

    window.tmDragTaskEnd = function() {
        state.draggingTaskId = '';
        try { __tmClearDocTabDropTarget(); } catch (e) {}
    };

    window.tmRowClick = function(ev, taskId) {
        const id = String(taskId || '').trim();
        if (!id) return;
        const t = ev?.target;
        if (t?.closest?.('button,input,select,textarea,a,.tm-task-content-clickable,.tm-tree-toggle,.tm-col-resize')) return;
        const task = state.flatTasks?.[id];
        if (!task) return;
        const filteredSet = new Set((state.filteredTasks || []).map(x => x.id));
        const hasVisibleChild = (task.children || []).some(c => filteredSet.has(c.id));
        if (!hasVisibleChild) return;
        tmToggleCollapse(id, ev);
    };

    window.tmToggleDocTabs = function(ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        try { ev?.preventDefault?.(); } catch (e) {}
        state.docTabsHidden = !state.docTabsHidden;
        try { Storage.set('tm_doc_tabs_hidden', !!state.docTabsHidden); } catch (e) {}
        const el = state.modal?.querySelector?.('.tm-doc-tabs');
        if (el) {
            try {
                if (state.docTabsHidden) el.classList.add('tm-doc-tabs--hidden');
                else el.classList.remove('tm-doc-tabs--hidden');
            } catch (e) {}
            return;
        }
        render();
    };

    // 修改渲染函数以显示规则信息
    function render() {
        try { __tmEnsureDocTabTouchDelegation(); } catch (e) {}
        const kind0 = String(state.uiAnimKind || '').trim();
        const isViewSwitchAnim = (kind0 === 'from-right' || kind0 === 'from-left')
            && (Date.now() - (Number(state.uiAnimTs) || 0) < 380);
        const isTimelineView = state.viewMode === 'timeline';
        const useSoftSwap = isViewSwitchAnim;
        let prevModalEl = null;
        const prevModalSnapshot = state.modal instanceof Element ? state.modal : null;
        const prevWasTimeline = !!(prevModalSnapshot && prevModalSnapshot.querySelector && prevModalSnapshot.querySelector('#tmTimelineLeftBody'));
        const prevWasCalendar = !!(prevModalSnapshot && prevModalSnapshot.querySelector && prevModalSnapshot.querySelector('#tmCalendarRoot'));
        const prevWasKanban = !!(prevModalSnapshot && prevModalSnapshot.querySelector && prevModalSnapshot.querySelector('.tm-body.tm-body--kanban'));
        const prevWasWhiteboard = !!(prevModalSnapshot && prevModalSnapshot.querySelector && prevModalSnapshot.querySelector('.tm-body.tm-body--whiteboard'));
        // 保存滚动位置
        let savedScrollTop = 0;
        let savedScrollLeft = 0;
        let savedTimelineScrollTop = 0;
        let savedTimelineScrollLeft = 0;
        let savedCalendarScrollTop = 0;
        let savedCalendarScrollLeft = 0;
        let savedKanbanScrollLeft = 0;
        let savedKanbanColScrollTopByStatus = {};
        let savedWhiteboardSidebarScrollTop = 0;
        if (prevModalSnapshot) {
            prevModalEl = prevModalSnapshot;
            const timelineLeftBody = prevModalSnapshot.querySelector('#tmTimelineLeftBody');
            const ganttBody = prevModalSnapshot.querySelector('#tmGanttBody');
            if (timelineLeftBody) {
                savedTimelineScrollTop = timelineLeftBody.scrollTop;
                if (ganttBody) savedTimelineScrollLeft = ganttBody.scrollLeft;
            } else if (prevWasKanban) {
                const kbBody = prevModalSnapshot.querySelector('.tm-body.tm-body--kanban');
                if (kbBody) savedKanbanScrollLeft = Number(kbBody.scrollLeft) || 0;
                const map = {};
                try {
                    prevModalSnapshot.querySelectorAll('.tm-kanban-col[data-status]').forEach((col) => {
                        const status = String(col?.getAttribute?.('data-status') || '').trim();
                        if (!status) return;
                        const body = col.querySelector('.tm-kanban-col-body');
                        map[status] = Number(body?.scrollTop) || 0;
                    });
                } catch (e) {}
                savedKanbanColScrollTopByStatus = map;
            } else if (prevWasWhiteboard) {
                const sidebar = prevModalSnapshot.querySelector('.tm-whiteboard-sidebar');
                if (sidebar) savedWhiteboardSidebarScrollTop = Number(sidebar.scrollTop) || 0;
            } else if (prevWasCalendar) {
                try {
                    const root = prevModalSnapshot.querySelector('#tmCalendarRoot');
                    const preferred = root?.querySelector?.('.fc-timegrid-body .fc-scroller') || null;
                    const list = Array.from(root?.querySelectorAll?.('.fc-scroller') || []);
                    const scroller = (preferred && preferred.scrollHeight > preferred.clientHeight + 1)
                        ? preferred
                        : (list.find((el) => el && el.scrollHeight > el.clientHeight + 1) || preferred || list[0] || null);
                    if (scroller) {
                        savedCalendarScrollTop = scroller.scrollTop;
                        savedCalendarScrollLeft = scroller.scrollLeft;
                    }
                } catch (e) {}
            } else {
                const body = prevModalSnapshot.querySelector('.tm-body');
                if (body) {
                    savedScrollTop = body.scrollTop;
                    savedScrollLeft = body.scrollLeft;
                }
            }
        }
        try {
            state.viewScroll = state.viewScroll && typeof state.viewScroll === 'object' ? state.viewScroll : {};
            if (prevModalSnapshot) {
                if (prevWasTimeline) state.viewScroll.timeline = { top: Number(savedTimelineScrollTop) || 0, left: Number(savedTimelineScrollLeft) || 0 };
                else if (prevWasKanban) state.viewScroll.kanban = { left: Number(savedKanbanScrollLeft) || 0, cols: savedKanbanColScrollTopByStatus || {} };
                else if (prevWasWhiteboard) state.viewScroll.whiteboard = { sidebarTop: Number(savedWhiteboardSidebarScrollTop) || 0 };
                else if (prevWasCalendar) state.viewScroll.calendar = { top: Number(savedCalendarScrollTop) || 0, left: Number(savedCalendarScrollLeft) || 0 };
                else state.viewScroll.list = { top: Number(savedScrollTop) || 0, left: Number(savedScrollLeft) || 0 };
            }
        } catch (e) {}

        if (prevModalSnapshot) {
            try {
                if (prevModalSnapshot.querySelector && prevModalSnapshot.querySelector('#tmCalendarRoot')) {
                    globalThis.__tmCalendar?.unmount?.();
                }
            } catch (e) {}
            if (!useSoftSwap) {
                try { prevModalSnapshot.remove(); } catch (e) {}
                prevModalEl = null;
            } else {
                try { prevModalSnapshot.style.pointerEvents = 'none'; } catch (e) {}
            }
        }
        
        // 应用字体大小
        document.documentElement.style.setProperty('--tm-font-size', (__tmGetFontSize()) + 'px');
        try { __tmApplyRowHeightVars(); } catch (e) {}
        try { __tmApplyAppearanceThemeVars(); } catch (e) {}

        const { totalTasks, doneTasks, queryTime } = state.stats;
        const todoTasks = totalTasks - doneTasks;
        const filteredCount = state.filteredTasks.length;
        
        const currentRule = state.currentRule ? 
            state.filterRules.find(r => r.id === state.currentRule) : null;

        const globalNewTaskDocId = String(SettingsStore.data.newTaskDocId || '').trim();
        const currentGroupId = SettingsStore.data.currentGroupId || 'all';
        const docsForTabs = __tmSortDocEntriesByPinned(state.taskTree || [], currentGroupId);
        const visibleDocs = docsForTabs
            .filter(doc => __tmDocHasUndoneTasks(doc))
            .filter(doc => !globalNewTaskDocId || doc.id !== globalNewTaskDocId);
            
        // 获取文档分组信息
        const docGroups = SettingsStore.data.docGroups || [];
        const currentGroup = docGroups.find(g => g.id === currentGroupId);
        const groupName = currentGroupId === 'all' ? '全部文档' : (currentGroup ? currentGroup.name : '未知分组');
        const isMobile = __tmIsMobileDevice();
        const isLandscape = !!(isMobile && (() => { try { return !!window.matchMedia?.('(orientation: landscape)')?.matches; } catch (e) { return false; } })());
        const isDesktopNarrow = !!(!isMobile && (() => { try { return !!window.matchMedia?.('(max-width: 768px)')?.matches; } catch (e) { return false; } })());
        const kind = String(state.uiAnimKind || '').trim();
        const bodyAnimClass = (Date.now() - (Number(state.uiAnimTs) || 0) < 300)
            ? (kind === 'from-right' ? ' tm-body-anim--from-right' : kind === 'from-left' ? ' tm-body-anim--from-left' : ' tm-body-anim')
            : '';
        
        state.modal = document.createElement('div');
        state.modal.className = 'tm-modal' + (__tmMountEl ? ' tm-modal--tab' : '') + (isMobile ? ' tm-modal--mobile' : '');
        if (useSoftSwap && prevModalEl) {
            try { state.modal.style.pointerEvents = 'none'; } catch (e) {}
        }
        
        // 构建规则选择选项
        const ruleOptions = state.filterRules
            .filter(rule => rule.enabled)
            .map(rule => `<option value="${rule.id}" ${state.currentRule === rule.id ? 'selected' : ''}>
                ${esc(rule.name)}
            </option>`)
            .join('');

        const __tmRenderListBodyHtml = () => `
                <div class="tm-body${bodyAnimClass}">
                    <table class="tm-table" id="tmTaskTable">
                        <thead>
                            <tr>
                                ${(() => {
                                    const colOrder = SettingsStore.data.columnOrder || ['pinned', 'content', 'status', 'score', 'doc', 'h2', 'priority', 'startDate', 'completionTime', 'duration', 'spent', 'remark'];
                                    const widths = SettingsStore.data.columnWidths || {};
                                    const headers = {
                                        pinned: `<th data-col="pinned" style="width: ${widths.pinned || 48}px; min-width: ${widths.pinned || 48}px; max-width: ${widths.pinned || 48}px; text-align: center; white-space: nowrap; overflow: hidden;">📌<span class="tm-col-resize" onmousedown="startColResize(event, 'pinned')"></span></th>`,
                                        content: `<th data-col="content" style="width: ${widths.content || 360}px; min-width: ${widths.content || 360}px; max-width: ${widths.content || 360}px; white-space: nowrap; overflow: hidden;">任务内容<span class="tm-col-resize" onmousedown="startColResize(event, 'content')"></span></th>`,
                                        score: `<th data-col="score" style="width: ${widths.score || 96}px; min-width: ${widths.score || 96}px; max-width: ${widths.score || 96}px; text-align: center; white-space: nowrap; overflow: hidden;">优先级<span class="tm-col-resize" onmousedown="startColResize(event, 'score')"></span></th>`,
                                        doc: `<th data-col="doc" style="width: ${widths.doc || 180}px; min-width: ${widths.doc || 180}px; max-width: ${widths.doc || 180}px; white-space: nowrap; overflow: hidden;">文档<span class="tm-col-resize" onmousedown="startColResize(event, 'doc')"></span></th>`,
                                        h2: (() => {
                                            const level = SettingsStore.data.taskHeadingLevel || 'h2';
                                            const labels = { h1: '一级标题', h2: '二级标题', h3: '三级标题', h4: '四级标题', h5: '五级标题', h6: '六级标题' };
                                            const label = labels[level] || '标题';
                                            return `<th data-col="h2" style="width: ${widths.h2 || 180}px; min-width: ${widths.h2 || 180}px; max-width: ${widths.h2 || 180}px; white-space: nowrap; overflow: hidden;">${label}<span class="tm-col-resize" onmousedown="startColResize(event, 'h2')"></span></th>`;
                                        })(),
                                        priority: `<th data-col="priority" style="width: ${widths.priority || 96}px; min-width: ${widths.priority || 96}px; max-width: ${widths.priority || 96}px; text-align: center; white-space: nowrap; overflow: hidden;">重要性<span class="tm-col-resize" onmousedown="startColResize(event, 'priority')"></span></th>`,
                                        startDate: `<th data-col="startDate" style="width: ${widths.startDate || 90}px; min-width: ${widths.startDate || 90}px; max-width: ${widths.startDate || 90}px; white-space: nowrap; overflow: hidden;">开始日期<span class="tm-col-resize" onmousedown="startColResize(event, 'startDate')"></span></th>`,
                                        completionTime: `<th data-col="completionTime" style="width: ${widths.completionTime || 170}px; min-width: ${widths.completionTime || 170}px; max-width: ${widths.completionTime || 170}px; white-space: nowrap; overflow: hidden;">完成日期<span class="tm-col-resize" onmousedown="startColResize(event, 'completionTime')"></span></th>`,
                                        duration: `<th data-col="duration" style="width: ${widths.duration || 96}px; min-width: ${widths.duration || 96}px; max-width: ${widths.duration || 96}px; white-space: nowrap; overflow: hidden;">时长<span class="tm-col-resize" onmousedown="startColResize(event, 'duration')"></span></th>`,
                                        spent: `<th data-col="spent" style="width: ${widths.spent || 96}px; min-width: ${widths.spent || 96}px; max-width: ${widths.spent || 96}px; white-space: nowrap; overflow: hidden;">耗时<span class="tm-col-resize" onmousedown="startColResize(event, 'spent')"></span></th>`,
                                        remark: `<th data-col="remark" style="width: ${widths.remark || 240}px; min-width: ${widths.remark || 240}px; max-width: ${widths.remark || 240}px; white-space: nowrap; overflow: hidden;">备注<span class="tm-col-resize" onmousedown="startColResize(event, 'remark')"></span></th>`,
                                        status: `<th data-col="status" style="width: ${widths.status || 96}px; min-width: ${widths.status || 96}px; max-width: ${widths.status || 96}px; text-align: center; white-space: nowrap; overflow: hidden;">状态<span class="tm-col-resize" onmousedown="startColResize(event, 'status')"></span></th>`
                                    };
                                    return colOrder.map(col => headers[col] || '').join('');
                                })()}
                            </tr>
                        </thead>
                        <tbody>
                            ${renderTaskList()}
                        </tbody>
                    </table>
                </div>
            `;

        const __tmRenderTimelineBodyHtml = (rowModel) => {
            const widths = SettingsStore.data.columnWidths || {};
            const isGloballyLocked = GlobalLock.isLocked();
            const leftWidth0 = Number(SettingsStore.data.timelineLeftWidth);
            const timelineContentWidth0 = Number(SettingsStore.data.timelineContentWidth);
            const timelineContentWidth = Number.isFinite(timelineContentWidth0) ? Math.max(10, Math.min(800, Math.round(timelineContentWidth0))) : (Number(widths.content) || 360);
            const timelineStartW = Math.max(10, Math.min(240, Math.round(Number(widths.startDate) || 90)));
            const timelineEndW = Math.max(10, Math.min(360, Math.round(Number(widths.completionTime) || 170)));
            const leftTableWidth = Math.round(timelineContentWidth + timelineStartW + timelineEndW + 2);
            const computedAuto = leftTableWidth;
            const leftWidth = (Number.isFinite(leftWidth0) && leftWidth0 > 0)
                ? Math.max(360, Math.min(900, Math.round(leftWidth0)))
                : Math.max(360, Math.min(900, computedAuto));
            const isDark = __tmIsDarkMode();
            const progressBarColor = isDark
                ? __tmNormalizeHexColor(SettingsStore.data.progressBarColorDark, '#81c784')
                : __tmNormalizeHexColor(SettingsStore.data.progressBarColorLight, '#4caf50');
            const enableGroupBg = !!SettingsStore.data.enableGroupTaskBgByGroupColor;
            let currentGroupBg = '';

            const renderGroupRow = (row) => {
                const isCollapsed = !!row?.collapsed;
                const toggle = `<span class="tm-group-toggle" onclick="tmToggleGroupCollapse('${row.key}', event)" style="cursor:pointer;margin-right:8px;display:inline-block;width:12px;">${isCollapsed ? '▸' : '▾'}</span>`;
                if (row.kind === 'doc') {
                    const labelColor = String(row.labelColor || 'var(--tm-group-doc-label-color)');
                    return `<tr class="tm-group-row tm-timeline-row" data-group-key="${esc(row.key)}"><td colspan="3" onclick="tmToggleGroupCollapse('${row.key}', event)" style="cursor:pointer;font-weight:bold;color:var(--tm-text-color);"><div class="tm-group-sticky">${toggle}<span class="tm-group-label" style="color:${labelColor};">📄 ${esc(row.label || '')}</span><span class="tm-badge tm-badge--count">${Number(row.count) || 0}</span></div></td></tr>`;
                }
                // 按任务名分组：分组行使用🧩 emoji
                if (row.kind === 'task') {
                    const labelColor = String(row.labelColor || 'var(--tm-primary-color)');
                    // 任务名分组：分组行不显示背景色，和文档分组保持一致
                    return `<tr class="tm-group-row tm-timeline-row" data-group-key="${esc(row.key)}"><td colspan="3" onclick="tmToggleGroupCollapse('${row.key}', event)" style="cursor:pointer;font-weight:bold;color:var(--tm-text-color);"><div class="tm-group-sticky">${toggle}<span class="tm-group-label" style="color:${labelColor};">🧩 ${esc(row.label || '')}</span><span class="tm-badge tm-badge--count">${Number(row.count) || 0}</span></div></td></tr>`;
                }
                if (row.kind === 'time') {
                    const labelColor = String(row.labelColor || 'var(--tm-text-color)');
                    const durationSum = String(row.durationSum || '').trim();
                    return `<tr class="tm-group-row tm-timeline-row" data-group-key="${esc(row.key)}"><td colspan="3" onclick="tmToggleGroupCollapse('${row.key}', event)" style="cursor:pointer;font-weight:bold;color:var(--tm-text-color);"><div class="tm-group-sticky">${toggle}<span class="tm-group-label" style="color:${labelColor};">${esc(row.label || '')}</span><span class="tm-badge tm-badge--count">${Number(row.count) || 0}</span>${durationSum ? `<span class="tm-badge tm-badge--duration"><span class="tm-badge__icon">📊</span>${esc(durationSum)}</span>` : ''}</div></td></tr>`;
                }
                if (row.kind === 'h2') {
                    return `<tr class="tm-group-row tm-timeline-row" data-group-kind="h2" data-group-key="${esc(row.key)}"><td colspan="3" onclick="tmToggleGroupCollapse('${row.key}', event)" style="cursor:pointer;font-weight:bold;color:var(--tm-secondary-text);"><div class="tm-group-sticky" style="padding-left:2ch;">${toggle}<span class="tm-group-label">🧩 ${esc(row.label || '')}</span><span class="tm-badge tm-badge--count">${Number(row.count) || 0}</span></div></td></tr>`;
                }
                if (row.kind === 'quadrant') {
                    const durationSum = String(row.durationSum || '').trim();
                    const colorMap = { red: 'var(--tm-quadrant-red)', yellow: 'var(--tm-quadrant-yellow)', blue: 'var(--tm-quadrant-blue)', green: 'var(--tm-quadrant-green)' };
                    const color = colorMap[String(row.color || '')] || 'var(--tm-text-color)';
                    return `<tr class="tm-group-row tm-timeline-row" data-group-key="${esc(row.key)}"><td colspan="3" onclick="tmToggleGroupCollapse('${row.key}', event)" style="cursor:pointer;font-weight:bold;color:${color};"><div class="tm-group-sticky">${toggle}${esc(row.label || '')}<span class="tm-badge tm-badge--count">${Number(row.count) || 0}</span>${durationSum ? `<span class="tm-badge tm-badge--duration"><span class="tm-badge__icon">📊</span>${esc(durationSum)}</span>` : ''}</div></td></tr>`;
                }
                return `<tr class="tm-group-row tm-timeline-row" data-group-key="${esc(row.key)}"><td colspan="3" onclick="tmToggleGroupCollapse('${row.key}', event)" style="cursor:pointer;font-weight:bold;color:var(--tm-text-color);"><div class="tm-group-sticky">${toggle}${esc(row.label || '')}</div></td></tr>`;
            };

            const renderTaskRow = (row) => {
                const task = state.flatTasks[row.id];
                if (!task) return '';
                const indent = (Math.max(0, Number(row.depth) || 0)) * 12;
                const toggle = row.hasChildren
                    ? `<span class="tm-tree-toggle" onclick="tmToggleCollapse('${task.id}', event)">${row.collapsed ? '▸' : '▾'}</span>`
                    : `<span class="tm-tree-spacer"></span>`;
                const focusId = SettingsStore.data.enableTomatoIntegration ? String(state.timerFocusTaskId || '').trim() : '';
                const rowClass = focusId ? (focusId === String(task.id) ? 'tm-timer-focus' : 'tm-timer-dim') : '';

                const allChildren = task.children || [];
                const totalChildren = allChildren.length;
                const completedChildren = allChildren.filter(c => c.done).length;
                const progressPercent = totalChildren > 0 ? Math.round((completedChildren / totalChildren) * 100) : 0;
                const isDoneSubtask = !!task.done && (Math.max(0, Number(row.depth) || 0) > 0);
                const groupBg = enableGroupBg ? currentGroupBg : '';
                const doneSubtaskBg = (!enableGroupBg && isDoneSubtask) ? __tmWithAlpha(progressBarColor, isDark ? 0.22 : 0.14) : '';
                const baseBg = groupBg || doneSubtaskBg;
                const progressBgStyle = (row.hasChildren && progressPercent > 0)
                    ? (enableGroupBg && groupBg
                        ? `background-image:linear-gradient(90deg, ${progressBarColor} ${progressPercent}%, transparent ${progressPercent}%);background-repeat:no-repeat;background-size:100% 3px;background-position:left bottom;`
                        : `background-image:linear-gradient(90deg, ${progressBarColor} ${progressPercent}%, transparent ${progressPercent}%);background-repeat:no-repeat;`)
                    : '';
                const contentCellBgStyle = `${baseBg ? `background-color:${baseBg};` : ''}${progressBgStyle ? `${progressBgStyle};` : ''}`;
                const otherCellBgStyle = groupBg ? `background-color:${groupBg};` : '';

                return `
                    <tr class="tm-timeline-row ${rowClass}" data-id="${task.id}" data-depth="${row.depth}" onclick="tmRowClick(event, '${task.id}')" oncontextmenu="tmShowTaskContextMenu(event, '${task.id}')">
                        <td style="width: ${timelineContentWidth}px; min-width: ${timelineContentWidth}px; max-width: ${timelineContentWidth}px; ${contentCellBgStyle}">
                            <div class="tm-task-cell" style="padding-left:${indent}px">
                                ${toggle}
                                <input class="tm-task-checkbox ${isGloballyLocked ? 'tm-operating' : ''}"
                                       type="checkbox" ${task.done ? 'checked' : ''}
                                       ${isGloballyLocked ? 'disabled' : ''}
                                       onchange="tmSetDone('${task.id}', this.checked, event)">
                                <span class="tm-task-text ${task.done ? 'tm-task-done' : ''}" data-level="${row.depth}" title="${esc(task.content || '')}">
                                    <span class="tm-task-content-clickable" onclick="tmJumpToTask('${task.id}', event)" title="${esc(task.content || '')}">${esc(task.content || '')}</span>
                                </span>
                            </div>
                        </td>
                        <td class="tm-cell-editable" style="width:${timelineStartW}px; min-width:${timelineStartW}px; max-width:${timelineStartW}px; ${otherCellBgStyle}" onclick="tmBeginCellEdit('${task.id}','startDate',this,event)">${__tmFormatTaskTime(task.startDate)}</td>
                        <td class="tm-cell-editable" style="width:${timelineEndW}px; min-width:${timelineEndW}px; max-width:${timelineEndW}px; ${otherCellBgStyle}" onclick="tmBeginCellEdit('${task.id}','completionTime',this,event)">${__tmFormatTaskTime(task.completionTime)}</td>
                    </tr>
                `;
            };

            const leftRows = [];
            for (const r of (Array.isArray(rowModel) ? rowModel : [])) {
                if (r?.type === 'group') {
                    let labelColor = '';
                    if (r.kind === 'doc') labelColor = String(r.labelColor || 'var(--tm-group-doc-label-color)');
                    else if (r.kind === 'task') labelColor = String(r.labelColor || 'var(--tm-primary-color)');
                    else if (r.kind === 'time') labelColor = String(r.labelColor || 'var(--tm-text-color)');
                    else if (r.kind === 'h2') labelColor = 'var(--tm-secondary-text)';
                    else if (r.kind === 'quadrant') {
                        const colorMap = { red: 'var(--tm-quadrant-red)', yellow: 'var(--tm-quadrant-yellow)', blue: 'var(--tm-quadrant-blue)', green: 'var(--tm-quadrant-green)' };
                        labelColor = colorMap[String(r.color || '')] || 'var(--tm-text-color)';
                    } else {
                        labelColor = 'var(--tm-text-color)';
                    }
                    // 任务名分组使用文档颜色作为背景
                    if (r.kind === 'task' && r.groupDocColor) {
                        currentGroupBg = enableGroupBg ? __tmGroupBgFromLabelColor(r.groupDocColor, isDark) : '';
                    } else {
                        currentGroupBg = enableGroupBg ? __tmGroupBgFromLabelColor(labelColor, isDark) : '';
                    }
                    leftRows.push(renderGroupRow(r));
                    continue;
                }
                if (r?.type === 'task') {
                    // 按任务名分组时，每个任务使用自己文档的颜色
                    let taskDocColor = '';
                    if (state.groupByTaskName) {
                        const task = state.flatTasks[r.id];
                        if (task?.root_id) {
                            taskDocColor = __tmGetDocColorHex(task.root_id, isDark) || '';
                        }
                        if (taskDocColor && enableGroupBg) {
                            currentGroupBg = __tmGroupBgFromLabelColor(taskDocColor, isDark);
                        } else {
                            currentGroupBg = '';
                        }
                    }
                    leftRows.push(renderTaskRow(r));
                    continue;
                }
            }
            const leftRowsHtml = leftRows.join('');

            return `
                <div class="tm-body tm-body--timeline${bodyAnimClass}">
                    <div class="tm-timeline-split">
                        <div class="tm-timeline-left" style="width:${leftWidth}px">
                            <div class="tm-timeline-left-body" id="tmTimelineLeftBody">
                                <table class="tm-table tm-timeline-table-left" id="tmTimelineLeftTable" style="width:${leftTableWidth}px;min-width:${leftTableWidth}px;max-width:${leftTableWidth}px;">
                                    <colgroup>
                                        <col id="tmTimelineColContent" style="width:${timelineContentWidth}px">
                                        <col id="tmTimelineColStart" style="width:${timelineStartW}px">
                                        <col id="tmTimelineColEnd" style="width:${timelineEndW}px">
                                    </colgroup>
                                    <thead>
                                        <tr>
                                            <th style="width:${timelineContentWidth}px; min-width:${timelineContentWidth}px; max-width:${timelineContentWidth}px;">任务内容<span class="tm-col-resize" onmousedown="tmStartTimelineContentResize(event)"></span></th>
                                            <th style="width:${timelineStartW}px; min-width:${timelineStartW}px; max-width:${timelineStartW}px;">开始日期</th>
                                            <th style="width:${timelineEndW}px; min-width:${timelineEndW}px; max-width:${timelineEndW}px;">完成日期</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${leftRowsHtml || `<tr><td colspan="3" style="text-align:center; padding:40px; color:var(--tm-secondary-text);">暂无任务</td></tr>`}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div class="tm-timeline-splitter" onmousedown="tmStartTimelineSplitResize(event)" title="拖拽调整宽度"></div>
                        <div class="tm-timeline-right">
                            <div class="tm-timeline-right-header"><div id="tmGanttHeader"></div></div>
                            <div class="tm-timeline-right-body" id="tmGanttBody"></div>
                        </div>
                    </div>
                </div>
            `;
        };

        const __tmRenderKanbanBodyHtml = () => {
            const isGloballyLocked = GlobalLock.isLocked();
            const isAllTabsView = !(state.activeDocId && state.activeDocId !== 'all');
            const isCompact = !!SettingsStore.data.kanbanCompactMode;
            const baseKanbanW0 = Number(SettingsStore.data.kanbanColumnWidth);
            const baseKanbanW = Number.isFinite(baseKanbanW0) ? Math.max(220, Math.min(520, Math.round(baseKanbanW0))) : 320;
            const kanbanColW = isCompact ? Math.max(220, baseKanbanW - 40) : baseKanbanW;
            const showDoneCol = !!SettingsStore.data.kanbanShowDoneColumn;
            const currentGroupId = String(SettingsStore.data.currentGroupId || 'all').trim() || 'all';
            const statusOptionsRaw = Array.isArray(SettingsStore.data.customStatusOptions) ? SettingsStore.data.customStatusOptions : [];
            const statusOptions = statusOptionsRaw
                .map(o => ({ id: String(o?.id || '').trim(), name: String(o?.name || '').trim(), color: String(o?.color || '').trim() }))
                .filter(o => o.id);
            const todoOpt = statusOptions.find(o => o.id === 'todo') || { id: 'todo', name: '待办', color: '#757575' };
            const cols = showDoneCol
                ? [todoOpt, ...statusOptions.filter(o => o.id !== 'todo'), { id: '__done__', name: '已完成', color: '#9e9e9e' }]
                : [todoOpt, ...statusOptions.filter(o => o.id !== 'todo')];

            const docNameById = new Map();
            (Array.isArray(state.taskTree) ? state.taskTree : []).forEach(d => {
                const id = String(d?.id || '').trim();
                if (id) docNameById.set(id, String(d?.name || '').trim());
            });
            (Array.isArray(state.allDocuments) ? state.allDocuments : []).forEach(d => {
                const id = String(d?.id || '').trim();
                if (id && !docNameById.has(id)) docNameById.set(id, String(d?.name || '').trim());
            });

            const filtered = Array.isArray(state.filteredTasks) ? state.filteredTasks : [];
            const filteredIdList = filtered.map(t => String(t?.id || '').trim()).filter(Boolean);
            const filteredIdSet = new Set(filteredIdList);
            const indexById = new Map(filteredIdList.map((id, i) => [id, i]));
            const escSq = (s) => String(s || '').replace(/\\/g, '\\\\').replace(/'/g, "\\'");
            const isDark = __tmIsDarkMode();
            const timeBaseColor = isDark
                ? __tmNormalizeHexColor(SettingsStore.data.timeGroupBaseColorDark, '#6ba5ff')
                : __tmNormalizeHexColor(SettingsStore.data.timeGroupBaseColorLight, '#1a73e8');
            const timeOverdueColor = isDark
                ? __tmNormalizeHexColor(SettingsStore.data.timeGroupOverdueColorDark, '#ff6b6b')
                : __tmNormalizeHexColor(SettingsStore.data.timeGroupOverdueColorLight, '#d93025');
            const getTimeGroupLabelColor = (groupInfo) => {
                const key = String(groupInfo?.key || '');
                const sortValue = Number(groupInfo?.sortValue);
                if (key === 'pending' || !Number.isFinite(sortValue)) return 'var(--tm-secondary-text)';
                if (sortValue < 0) return timeOverdueColor || 'var(--tm-danger-color)';
                const minA = isDark ? 0.52 : 0.42;
                const step = isDark ? 0.085 : 0.11;
                const alpha = __tmClamp(1 - sortValue * step, minA, 1);
                return __tmWithAlpha(timeBaseColor || 'var(--tm-primary-color)', alpha);
            };
            const getTimeGroup = (task) => {
                const timeStr = String(task?.completionTime || task?.startDate || '').trim();
                if (!timeStr) return { key: 'pending', label: '待定', sortValue: Infinity };
                const taskDate = new Date(timeStr);
                if (isNaN(taskDate.getTime())) return { key: 'pending', label: '待定', sortValue: Infinity };
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const target = new Date(taskDate.getFullYear(), taskDate.getMonth(), taskDate.getDate());
                const diffDays = Math.ceil((target - today) / (1000 * 60 * 60 * 24));
                if (diffDays < 0) return { key: 'overdue', label: '已过期', sortValue: diffDays };
                if (diffDays === 0) return { key: 'today', label: '今天', sortValue: 0 };
                if (diffDays === 1) return { key: 'tomorrow', label: '明天', sortValue: 1 };
                if (diffDays <= 7) return { key: 'week', label: '本周', sortValue: diffDays };
                if (diffDays <= 14) return { key: 'nextweek', label: '下周', sortValue: diffDays };
                return { key: 'later', label: `${diffDays}天后`, sortValue: diffDays };
            };
            const getImportanceLevel = (task) => {
                const priority = String(task?.priority || '').toLowerCase();
                if (priority === 'a' || priority === '高' || priority === 'high') return 'high';
                if (priority === 'b' || priority === '中' || priority === 'medium') return 'medium';
                if (priority === 'c' || priority === '低' || priority === 'low') return 'low';
                return 'none';
            };
            const getTimeRange = (task) => {
                const timeStr = String(task?.completionTime || '').trim();
                if (!timeStr) return 'nodate';
                const taskDate = new Date(timeStr);
                if (isNaN(taskDate.getTime())) return 'nodate';
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const target = new Date(taskDate.getFullYear(), taskDate.getMonth(), taskDate.getDate());
                const diffDays = Math.ceil((target - today) / (1000 * 60 * 60 * 24));
                if (diffDays < 0) return 'overdue';
                if (diffDays <= 7) return 'within7days';
                if (diffDays <= 15) return 'within15days';
                if (diffDays <= 30) return 'within30days';
                return 'beyond30days';
            };
            const getTaskDays = (task) => {
                const timeStr = String(task?.completionTime || '').trim();
                if (!timeStr) return Infinity;
                const taskDate = new Date(timeStr);
                if (isNaN(taskDate.getTime())) return Infinity;
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const target = new Date(taskDate.getFullYear(), taskDate.getMonth(), taskDate.getDate());
                return Math.ceil((target - today) / (1000 * 60 * 60 * 24));
            };
            const quadrantRules = (SettingsStore.data.quadrantConfig && Array.isArray(SettingsStore.data.quadrantConfig.rules))
                ? SettingsStore.data.quadrantConfig.rules
                : [];
            const quadrantOrder = ['urgent-important', 'not-urgent-important', 'urgent-not-important', 'not-urgent-not-important'];
            const quadrantColorMap = {
                red: 'var(--tm-quadrant-red)',
                yellow: 'var(--tm-quadrant-yellow)',
                blue: 'var(--tm-quadrant-blue)',
                green: 'var(--tm-quadrant-green)'
            };
            const resolveQuadrantRule = (task) => {
                const importance = getImportanceLevel(task);
                const timeRange = getTimeRange(task);
                const taskDays = getTaskDays(task);
                for (const rule of quadrantRules) {
                    const imp = Array.isArray(rule?.importance) ? rule.importance : [];
                    const trs = Array.isArray(rule?.timeRanges) ? rule.timeRanges : [];
                    if (!imp.includes(importance)) continue;
                    let ok = trs.includes(timeRange);
                    if (!ok) {
                        for (const range of trs) {
                            const s = String(range || '');
                            if (!s.startsWith('beyond') || s === 'beyond30days') continue;
                            const days = parseInt(s.replace('beyond', '').replace('days', ''), 10);
                            if (!isNaN(days) && taskDays > days) {
                                ok = true;
                                break;
                            }
                        }
                    }
                    if (ok) return rule;
                }
                return null;
            };
            const docsInOrder = __tmSortDocEntriesByPinned(state.taskTree || [], currentGroupId).map(d => String(d?.id || '').trim()).filter(Boolean);
            const docRank = new Map(docsInOrder.map((id, idx) => [id, idx]));

            const tasksByStatus = new Map(cols.map(c => [c.id, []]));
            filtered.forEach(task => {
                const key = task?.done ? '__done__' : (String(task?.customStatus || '').trim() || 'todo');
                if (!showDoneCol && key === '__done__') return;
                if (!tasksByStatus.has(key)) tasksByStatus.set(key, []);
                tasksByStatus.get(key).push(task);
            });

            const renderCard = (task, depthInCol, isSub, isChildRoot, parentTxt, childrenHtml, toggleHtml, isParent) => {
                const id = String(task?.id || '').trim();
                if (!id) return '';
                const content = String(task?.content || '').trim();
                const docName = docNameById.get(String(task?.root_id || '').trim()) || '';
                const st = String(task?.customStatus || '').trim() || 'todo';
                const opt = statusOptions.find(o => o.id === st) || (st === 'todo' ? todoOpt : { id: st, name: st, color: '#757575' });
                const pr = String(task?.priority || '').toLowerCase();
                const prMeta = pr === 'high'
                    ? { label: '高', color: '#ea4335' }
                    : pr === 'medium'
                        ? { label: '中', color: '#f9ab00' }
                        : pr === 'low'
                            ? { label: '低', color: '#34a853' }
                            : { label: '无', color: '#9aa0a6' };
                const timeTxt = String(task?.completionTime || '').trim() || String(task?.startDate || '').trim();
                const dateTxt = timeTxt ? __tmFormatTaskTime(timeTxt) : '';
                const allChildren = Array.isArray(task?.children) ? task.children : [];
                const totalChildren = allChildren.length;
                const completedChildren = totalChildren > 0 ? allChildren.filter(c => c && c.done).length : 0;
                const remainingChildren = Math.max(0, totalChildren - completedChildren);
                const childTxt = totalChildren > 0 ? `${remainingChildren}/${totalChildren}` : '';
                const statusChip = task?.done
                    ? `<span class="tm-kanban-chip tm-kanban-chip--muted" style="cursor:default;">完成</span>`
                    : `<span class="tm-kanban-chip" style="background-color:${esc(opt.color || '#757575')};color:#fff;" onclick="tmKanbanOpenStatusSelect('${id}', this, event)">${esc(opt.name || '')}</span>`;

                return `
                    <div class="tm-kanban-card${isSub ? ' tm-kanban-card--sub' : ''}${isChildRoot ? ' tm-kanban-card--childroot' : ''}${isParent ? ' tm-kanban-card--parent' : ''}" data-id="${id}" draggable="true" ondragstart="tmKanbanDragStart(event, '${id}')" ondragend="tmKanbanDragEnd(event, '${id}')" oncontextmenu="tmShowTaskContextMenu(event, '${id}')" style="${isSub ? '' : ''}">
                        <div class="tm-kanban-card-top">
                            <div class="tm-kanban-card-head">
                                ${toggleHtml || ''}
                                <input class="tm-task-checkbox ${isGloballyLocked ? 'tm-operating' : ''}"
                                       type="checkbox" ${task?.done ? 'checked' : ''}
                                       ${isGloballyLocked ? 'disabled' : ''}
                                       onchange="tmSetDone('${id}', this.checked, event)">
                                <span class="tm-kanban-card-title-inline tm-task-content-clickable" onclick="tmJumpToTask('${id}', event)" title="${esc((content || '(无内容)'))}">${esc((content || '(无内容)'))}</span>
                            </div>
                            <button class="tm-kanban-more" onclick="tmOpenTaskDetail('${id}', event)">⋯</button>
                        </div>
                        ${parentTxt ? `<div class="tm-kanban-parent-line" style="font-size:12px;color:var(--tm-secondary-text);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin-bottom:6px;" title="${esc(parentTxt)}"><span>父任务：</span><span style="font-weight:800;color:var(--tm-text-color);">${esc(parentTxt)}</span></div>` : ''}
                        <div class="tm-kanban-card-meta">
                            ${statusChip}
                            <span class="tm-kanban-chip" style="background-color:${esc(prMeta.color)};color:#fff;" onclick="tmPickPriority('${id}', this, event)">${esc(prMeta.label)}</span>
                            <span class="tm-kanban-chip tm-kanban-chip--muted" onclick="tmKanbanPickDate('${id}', event)" title="点击选择日期">📅 ${esc(dateTxt || '日期')}</span>
                        </div>
                        ${(isAllTabsView && docName) ? `<div style="font-size:12px;color:var(--tm-secondary-text);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">📄 ${esc(docName)}</div>` : ''}
                        ${childrenHtml ? `<div class="tm-kanban-subtasks">${childrenHtml}</div>` : ''}
                    </div>
                `;
            };

            const colsHtml = cols.map(c => {
                const list0 = tasksByStatus.get(c.id) || [];
                const map = new Map();
                list0.forEach(t => {
                    const id = String(t?.id || '').trim();
                    if (id) map.set(id, t);
                });
                const childrenByParent = new Map();
                list0.forEach(t => {
                    const id = String(t?.id || '').trim();
                    const pid = String(t?.parentTaskId || '').trim();
                    if (!id || !pid) return;
                    if (!map.has(pid)) return;
                    if (!childrenByParent.has(pid)) childrenByParent.set(pid, []);
                    childrenByParent.get(pid).push(t);
                });
                const roots = list0.filter(t => {
                    const pid = String(t?.parentTaskId || '').trim();
                    return !pid || !map.has(pid);
                });
                const getIdx = (t) => indexById.get(String(t?.id || '').trim()) ?? 999999;
                const sortByIdx = (a, b) => getIdx(a) - getIdx(b);
                roots.sort(sortByIdx);
                childrenByParent.forEach(arr => arr.sort(sortByIdx));

                const renderTree = (task, depthInCol) => {
                    const id = String(task?.id || '').trim();
                    const pid = String(task?.parentTaskId || '').trim();
                    const parentInCol = !!(pid && map.has(pid));
                    const parent = pid ? state.flatTasks[pid] : null;
                    const parentTxt = (!parentInCol && parent) ? String(parent.content || '').trim() : '';
                    const childList = childrenByParent.get(id) || [];
                    const collapsed = childList.length ? __tmKanbanGetCollapsedSet().has(id) : false;
                    const toggleHtml = childList.length
                        ? `<button class="tm-kanban-toggle" onclick="tmKanbanToggleCollapse('${id}', event)" title="${collapsed ? '展开子任务' : '折叠子任务'}">${collapsed ? '▸' : '▾'}</button>`
                        : '';
                    const childrenHtml = (!collapsed && childList.length) ? childList.map(ch => renderTree(ch, depthInCol + 1)).join('') : '';
                    return renderCard(
                        task,
                        depthInCol,
                        depthInCol > 0,
                        depthInCol === 0 && !!pid,
                        parentTxt,
                        childrenHtml,
                        toggleHtml,
                        depthInCol === 0 && childList.length > 0
                    );
                };

                const renderGroupTitle = (groupKey, titleHtml, count, color, opt = {}) => {
                    const isCollapsed = state.collapsedGroups?.has(groupKey);
                    const indentCh = Number(opt?.indentCh);
                    const leftIndent = Number.isFinite(indentCh) && indentCh > 0 ? `${indentCh}ch` : '0';
                    return `
                        <div class="tm-kanban-group-title" onclick="tmToggleGroupCollapse('${escSq(groupKey)}', event)" style="${color ? `color:${color};` : ''}">
                            <span style="display:inline-flex;align-items:center;min-width:0;padding-left:${leftIndent};">
                                <span class="tm-group-toggle" style="cursor:pointer;display:inline-block;width:12px;">${isCollapsed ? '▸' : '▾'}</span>
                                <span>${titleHtml}</span>
                            </span>
                            <span class="tm-badge tm-badge--count">${Number(count) || 0}</span>
                        </div>
                    `;
                };

                const renderGroupedByDoc = () => {
                    const rootByDoc = new Map();
                    const countByDoc = new Map();
                    list0.forEach(t => {
                        const did = String(t?.root_id || '').trim() || '__unknown__';
                        countByDoc.set(did, (countByDoc.get(did) || 0) + 1);
                    });
                    roots.forEach(t => {
                        const did = String(t?.root_id || '').trim() || '__unknown__';
                        if (!rootByDoc.has(did)) rootByDoc.set(did, []);
                        rootByDoc.get(did).push(t);
                    });
                    const docIds = Array.from(rootByDoc.keys());
                    docIds.sort((a, b) => {
                        const ar = docRank.has(a) ? docRank.get(a) : 999999;
                        const br = docRank.has(b) ? docRank.get(b) : 999999;
                        if (ar !== br) return ar - br;
                        const a0 = rootByDoc.get(a)?.[0];
                        const b0 = rootByDoc.get(b)?.[0];
                        return getIdx(a0) - getIdx(b0);
                    });
                    return docIds.map((docId) => {
                        const items = rootByDoc.get(docId) || [];
                        const groupKey = `kanban_${c.id}_doc_${docId}`;
                        const isCollapsed = state.collapsedGroups?.has(groupKey);
                        const docName = docNameById.get(docId) || '未知文档';
                        const labelColor = docId === '__unknown__' ? 'var(--tm-secondary-text)' : (__tmGetDocColorHex(docId, isDark) || 'var(--tm-group-doc-label-color)');
                        const title = `<span style="color:${labelColor};">📄 ${esc(docName)}</span>`;
                        let body = '';
                        if (!isCollapsed) {
                            const enableH2 = !!SettingsStore.data.docH2SubgroupEnabled;
                            if (!enableH2) {
                                body = `<div class="tm-kanban-group-items">${items.map(t => renderTree(t, 0)).join('')}</div>`;
                            } else {
                                const headingLevel = String(SettingsStore.data.taskHeadingLevel || 'h2').trim() || 'h2';
                                const headingLabelMap = { h1: '一级标题', h2: '二级标题', h3: '三级标题', h4: '四级标题', h5: '五级标题', h6: '六级标题' };
                                const noHeadingLabel = `无${headingLabelMap[headingLevel] || '标题'}`;
                                const buckets = __tmBuildDocHeadingBuckets(items, noHeadingLabel);
                                const grouped = new Map();
                                items.forEach((task) => {
                                    const b = __tmGetDocHeadingBucket(task, noHeadingLabel);
                                    if (!grouped.has(b.key)) grouped.set(b.key, []);
                                    grouped.get(b.key).push(task);
                                });
                                const h2Html = buckets.map((bucket) => {
                                    const bucketItems = grouped.get(bucket.key) || [];
                                    if (!bucketItems.length) return '';
                                    const h2Key = `kanban_${c.id}_doc_${docId}__h2_${encodeURIComponent(String(bucket.key || 'label:__none__'))}`;
                                    const h2Collapsed = state.collapsedGroups?.has(h2Key);
                                    const h2Title = `<span style="color:var(--tm-secondary-text);">🧩 ${esc(String(bucket.label || ''))}</span>`;
                                    const h2Body = h2Collapsed ? '' : `<div class="tm-kanban-group-items">${bucketItems.map(t => renderTree(t, 0)).join('')}</div>`;
                                    return `<div class="tm-kanban-group">${renderGroupTitle(h2Key, h2Title, bucketItems.length, '', { indentCh: 2 })}${h2Body}</div>`;
                                }).join('');
                                body = `<div class="tm-kanban-group-items">${h2Html}</div>`;
                            }
                        }
                        return `<div class="tm-kanban-group">${renderGroupTitle(groupKey, title, countByDoc.get(docId) || items.length)}${body}</div>`;
                    }).join('');
                };

                const renderGroupedByTime = () => {
                    const gm = new Map();
                    roots.forEach(t => {
                        const info = getTimeGroup(t);
                        const key = String(info.key || 'pending');
                        if (!gm.has(key)) gm.set(key, { ...info, items: [] });
                        gm.get(key).items.push(t);
                    });
                    const groups = Array.from(gm.values()).sort((a, b) => (Number(a.sortValue) || Infinity) - (Number(b.sortValue) || Infinity));
                    return groups.map((g) => {
                        const groupKey = `kanban_${c.id}_time_${g.key}`;
                        const isCollapsed = state.collapsedGroups?.has(groupKey);
                        const color = getTimeGroupLabelColor(g);
                        const title = `<span style="color:${color};">${esc(g.label || '')}</span>`;
                        const body = isCollapsed ? '' : `<div class="tm-kanban-group-items">${g.items.map(t => renderTree(t, 0)).join('')}</div>`;
                        return `<div class="tm-kanban-group">${renderGroupTitle(groupKey, title, g.items.length)}${body}</div>`;
                    }).join('');
                };

                const renderGroupedByQuadrant = () => {
                    const gm = new Map();
                    quadrantRules.forEach(r => {
                        const id = String(r?.id || '').trim();
                        if (!id) return;
                        gm.set(id, { rule: r, items: [] });
                    });
                    const unmatchedKey = '__unmatched__';
                    gm.set(unmatchedKey, { rule: { id: unmatchedKey, name: '未匹配四象限', color: '' }, items: [] });
                    roots.forEach(t => {
                        const rule = resolveQuadrantRule(t);
                        const key = String(rule?.id || unmatchedKey);
                        if (!gm.has(key)) gm.set(key, { rule: rule || { id: key, name: key, color: '' }, items: [] });
                        gm.get(key).items.push(t);
                    });
                    const orderKeys = [...quadrantOrder, ...Array.from(gm.keys()).filter(k => !quadrantOrder.includes(k) && k !== unmatchedKey), unmatchedKey];
                    return orderKeys
                        .filter(k => gm.has(k) && (gm.get(k).items || []).length > 0)
                        .map((k) => {
                            const g = gm.get(k);
                            const rule = g.rule || {};
                            const groupKey = `kanban_${c.id}_quadrant_${String(rule.id || k)}`;
                            const isCollapsed = state.collapsedGroups?.has(groupKey);
                            const color = quadrantColorMap[String(rule.color || '')] || 'var(--tm-text-color)';
                            const title = `<span style="color:${color};">${esc(String(rule.name || k))}</span>`;
                            const body = isCollapsed ? '' : `<div class="tm-kanban-group-items">${(g.items || []).map(t => renderTree(t, 0)).join('')}</div>`;
                            return `<div class="tm-kanban-group">${renderGroupTitle(groupKey, title, (g.items || []).length, color)}${body}</div>`;
                        })
                        .join('');
                };

                let listHtml = '';
                if (state.quadrantEnabled) {
                    listHtml = renderGroupedByQuadrant();
                } else if (state.groupByDocName) {
                    listHtml = renderGroupedByDoc();
                } else if (state.groupByTaskName) {
                    // 按任务名分组
                    const gm = new Map();
                    roots.forEach(t => {
                        const content = String(t?.content || '').trim();
                        if (!content) return;
                        if (!gm.has(content)) gm.set(content, { content, items: [] });
                        gm.get(content).items.push(t);
                    });
                    const groups = Array.from(gm.values()).sort((a, b) => String(a.content || '').localeCompare(String(b.content || ''), 'zh-CN'));
                    listHtml = groups.map((g) => {
                        const safeContent = String(g.content || '').replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, '_');
                        const groupKey = `kanban_${c.id}_task_${safeContent}`;
                        const isCollapsed = state.collapsedGroups?.has(groupKey);
                        // 计算该分组中所有任务的文档颜色
                        const docIds = [...new Set(g.items.map(t => t.root_id).filter(Boolean))];
                        let groupDocColor = '';
                        if (docIds.length === 1) {
                            groupDocColor = docIds[0] === '__unknown__' ? '' : (__tmGetDocColorHex(docIds[0], isDark) || '');
                        }
                        const color = groupDocColor || 'var(--tm-primary-color)';
                        const title = `<span style="color:${color};">📝 ${esc(g.content || '')}</span>`;
                        const body = isCollapsed ? '' : `<div class="tm-kanban-group-items">${g.items.map(t => renderTree(t, 0)).join('')}</div>`;
                        return `<div class="tm-kanban-group">${renderGroupTitle(groupKey, title, g.items.length, color)}${body}</div>`;
                    }).join('');
                } else if (state.groupByTime) {
                    listHtml = renderGroupedByTime();
                } else {
                    listHtml = roots.length ? roots.map(t => renderTree(t, 0)).join('') : '';
                }
                const count = list0.length;
                const title = c.id === '__done__' ? '✅ 已完成' : c.id === 'todo' ? `🗂️ ${c.name}` : c.name;
                return `
                    <div class="tm-kanban-col" data-status="${esc(c.id)}" style="width:${kanbanColW}px;min-width:${kanbanColW}px;max-width:${kanbanColW}px;">
                        <div class="tm-kanban-col-header">
                            <div class="tm-kanban-col-title tm-kanban-col-title--pill" style="background-color:${esc(c.color || '#757575')};color:#fff;" title="${esc(c.name)}">${esc(title)}</div>
                            <span class="tm-badge tm-badge--count">${count}</span>
                        </div>
                        <div class="tm-kanban-col-body" ondragover="tmKanbanDragOver(event)" ondragleave="tmKanbanDragLeave(event)" ondrop="tmKanbanDrop(event)">
                            ${listHtml || `<div style="color:var(--tm-secondary-text);font-size:12px;padding:8px 4px;">空</div>`}
                        </div>
                    </div>
                `;
            }).join('');

            return `
                <div class="tm-body tm-body--kanban${bodyAnimClass}${isCompact ? ' tm-body--kanban-compact' : ''}" ondragover="tmKanbanAutoScroll(event)">
                    <div class="tm-kanban${isCompact ? ' tm-kanban--compact' : ''}">
                        ${colsHtml}
                    </div>
                </div>
            `;
        };

        const __tmRenderCalendarBodyHtml = () => {
            return `
                <div class="tm-body tm-body--calendar${bodyAnimClass}" style="display:flex;flex-direction:column;min-height:0;">
                    <div id="tmCalendarRoot" style="flex:1;min-height:0;"></div>
                </div>
            `;
        };

        const __tmRenderWhiteboardBodyHtml = () => {
            const filtered = Array.isArray(state.filteredTasks) ? state.filteredTasks : [];
            try { __tmUpsertWhiteboardTaskSnapshots(filtered); } catch (e) {}
            const orderMap = new Map(filtered.map((t, i) => [String(t?.id || '').trim(), i]));
            const getOrder = (taskId) => orderMap.get(String(taskId || '').trim()) ?? 999999;
            const escSq = (s) => String(s || '').replace(/\\/g, '\\\\').replace(/'/g, "\\'");
            const showDoneTasks = !!SettingsStore.data.whiteboardShowDone;
            const statusOptionsRaw = Array.isArray(SettingsStore.data.customStatusOptions) ? SettingsStore.data.customStatusOptions : [];
            const statusOptions = statusOptionsRaw
                .map(o => ({ id: String(o?.id || '').trim(), name: String(o?.name || '').trim(), color: String(o?.color || '').trim() }))
                .filter(o => o.id);
            const todoOpt = statusOptions.find(o => o.id === 'todo') || { id: 'todo', name: '待办', color: '#757575' };
            const currentGroupId = String(SettingsStore.data.currentGroupId || 'all').trim() || 'all';
            const docsInOrder0 = __tmSortDocEntriesByPinned(state.taskTree || [], currentGroupId).map(d => String(d?.id || '').trim()).filter(Boolean);
            const docNameById = new Map((state.taskTree || []).map(d => [String(d?.id || '').trim(), String(d?.name || '').trim() || '未命名文档']));
            const snapMap = __tmGetWhiteboardCardSnapshotMap();
            // 仅使用当前分组已加载文档，避免把其他分组/历史快照文档混入“全部页签”白板
            const docsInOrder = docsInOrder0;
            const detachedMap = __tmGetDetachedChildrenMap();
            const headingLevel = String(SettingsStore.data.taskHeadingLevel || 'h2').trim() || 'h2';
            const headingLabelMap = { h1: '一级标题', h2: '二级标题', h3: '三级标题', h4: '四级标题', h5: '五级标题', h6: '六级标题' };
            const noHeadingLabel = `无${headingLabelMap[headingLevel] || '标题'}`;
            const notes = Array.isArray(SettingsStore.data.whiteboardNotes) ? SettingsStore.data.whiteboardNotes : [];
            const noteColorOptions = ['#1f2937', '#2f6fed', '#16a34a', '#d97706', '#b91c1c', '#7c3aed'];
            const view = __tmGetWhiteboardView();
            const posMap = { ...__tmGetWhiteboardNodePosMap() };
            const placedMap = { ...__tmGetWhiteboardPlacedTaskMap() };
            let posDirty = false;
            let placedDirty = false;
            const isDetachedTask = (taskId) => {
                const v = detachedMap[String(taskId || '').trim()];
                return !!(v && typeof v === 'object' && v.detached === true);
            };

            const selectedDocIds = (state.activeDocId && state.activeDocId !== 'all')
                ? [String(state.activeDocId)]
                : docsInOrder;
            const isAllTabsView = !(state.activeDocId && state.activeDocId !== 'all');
            const docIdSet = new Set(selectedDocIds);
            const byDoc = new Map();
            const pushDocTask = (taskLike) => {
                if (!taskLike || typeof taskLike !== 'object') return;
                const docId = String(taskLike?.root_id || taskLike?.docId || '').trim();
                const id = String(taskLike?.id || '').trim();
                if (!docId || !id || !docIdSet.has(docId)) return;
                if (!showDoneTasks && !!taskLike?.done) return;
                if (!byDoc.has(docId)) byDoc.set(docId, []);
                const list = byDoc.get(docId);
                if (list.some(x => String(x?.id || '').trim() === id)) return;
                list.push(taskLike);
            };
            filtered.forEach((task) => {
                pushDocTask(task);
            });
            Object.keys(snapMap || {}).forEach((id) => {
                const snap = snapMap[id];
                if (!snap || typeof snap !== 'object') return;
                const docId = String(snap.docId || '').trim();
                if (!docId || !docIdSet.has(docId)) return;
                if (state.flatTasks?.[id]) return;
                const snapHeadingLevel = String(snap.headingLevel || '').trim();
                const useSnapHeading = snapHeadingLevel ? (snapHeadingLevel === headingLevel) : (headingLevel === 'h2');
                pushDocTask({
                    id: String(id || '').trim(),
                    content: String(snap.content || '').trim() || '(无内容)',
                    root_id: docId,
                    docId,
                    parentTaskId: String(snap.parentTaskId || '').trim(),
                    h2: useSnapHeading ? String(snap.h2 || '').trim() : '',
                    h2Id: useSnapHeading ? String(snap.h2Id || '').trim() : '',
                    h2Path: useSnapHeading ? String(snap.h2Path || '').trim() : '',
                    h2Sort: useSnapHeading ? Number(snap.h2Sort) : Number.NaN,
                    h2Created: useSnapHeading ? String(snap.h2Created || '').trim() : '',
                    h2Rank: useSnapHeading ? Number(snap.h2Rank) : Number.NaN,
                    startDate: String(snap.startDate || '').trim(),
                    completionTime: String(snap.completionTime || '').trim(),
                    done: !!snap.done,
                    __tmGhost: true,
                });
            });
            Object.keys(placedMap).forEach((taskId) => {
                const id = String(taskId || '').trim();
                if (!id || !placedMap[id]) return;
                if (state.flatTasks?.[id]) {
                    pushDocTask(state.flatTasks[id]);
                    return;
                }
                const snap = snapMap[id];
                if (!snap || typeof snap !== 'object') return;
                const snapHeadingLevel = String(snap.headingLevel || '').trim();
                const useSnapHeading = snapHeadingLevel ? (snapHeadingLevel === headingLevel) : (headingLevel === 'h2');
                pushDocTask({
                    id,
                    content: String(snap.content || '').trim() || '(无内容)',
                    root_id: String(snap.docId || '').trim(),
                    docId: String(snap.docId || '').trim(),
                    parentTaskId: String(snap.parentTaskId || '').trim(),
                    h2: useSnapHeading ? String(snap.h2 || '').trim() : '',
                    h2Id: useSnapHeading ? String(snap.h2Id || '').trim() : '',
                    h2Path: useSnapHeading ? String(snap.h2Path || '').trim() : '',
                    h2Sort: useSnapHeading ? Number(snap.h2Sort) : Number.NaN,
                    h2Created: useSnapHeading ? String(snap.h2Created || '').trim() : '',
                    h2Rank: useSnapHeading ? Number(snap.h2Rank) : Number.NaN,
                    startDate: String(snap.startDate || '').trim(),
                    completionTime: String(snap.completionTime || '').trim(),
                    done: !!snap.done,
                    __tmGhost: true,
                });
            });
            Object.keys(placedMap).forEach((id) => {
                const tid = String(id || '').trim();
                const hasTask = !!(tid && (state.flatTasks?.[tid] || snapMap?.[tid]));
                if (!tid || !hasTask) {
                    delete placedMap[id];
                    placedDirty = true;
                }
            });
            if (state.whiteboardSelectedTaskId) {
                const selId = String(state.whiteboardSelectedTaskId || '').trim();
                // 子任务通常不会单独标记为 placed，不应因此丢失选中；仅在任务不存在时清理选中态
                if (selId && !state.flatTasks?.[selId] && !snapMap?.[selId]) {
                    state.whiteboardSelectedTaskId = '';
                }
            }
            // 不在这里按完成状态强制清空选中，避免点击已完成卡片后选中态立即丢失。
            // 仅当任务真实不存在时（见上方分支）才清理选中态。

            const ensureNodePos = (task, docId, idx) => {
                const id = String(task?.id || '').trim();
                const did = String(docId || '').trim();
                if (!id || !did) return { x: 24, y: 56 };
                const existing = posMap[id];
                if (existing && typeof existing === 'object' && String(existing.docId || '').trim() === did) {
                    const ex = Number(existing.x);
                    const ey = Number(existing.y);
                    if (Number.isFinite(ex) && Number.isFinite(ey)) return { x: ex, y: ey };
                }
                const x = 24 + (Number(idx) % 10) * 300;
                const y = 56 + Math.floor(Number(idx) / 10) * 220;
                posMap[id] = { docId: did, x, y, updatedAt: String(Date.now()) };
                posDirty = true;
                return { x, y };
            };

            const allView = !(state.activeDocId && state.activeDocId !== 'all');
            const docsHtml = selectedDocIds.map((docIdRaw) => {
                const docId = String(docIdRaw || '').trim();
                if (!docId) return '';
                const docTasks0 = (byDoc.get(docId) || []).slice().sort((a, b) => getOrder(a?.id) - getOrder(b?.id));
                const seenDocTask = new Set();
                const docTasks = docTasks0.filter((t) => {
                    const id = String(t?.id || '').trim();
                    if (!id || seenDocTask.has(id)) return false;
                    seenDocTask.add(id);
                    return true;
                });
                Object.keys(placedMap).forEach((taskId) => {
                    const tid = String(taskId || '').trim();
                    if (!tid || !placedMap[tid]) return;
                    const pos = posMap?.[tid];
                    const posDocId = String(pos?.docId || '').trim();
                    if (!posDocId || posDocId !== docId) return;
                    if (seenDocTask.has(tid)) return;
                    const taskObj = state.flatTasks?.[tid] || (snapMap?.[tid] ? {
                        id: tid,
                        content: String(snapMap[tid]?.content || '').trim() || '(无内容)',
                        root_id: String(snapMap[tid]?.docId || '').trim(),
                        docId: String(snapMap[tid]?.docId || '').trim(),
                        parentTaskId: String(snapMap[tid]?.parentTaskId || '').trim(),
                        h2: String(snapMap[tid]?.h2 || '').trim(),
                        startDate: String(snapMap[tid]?.startDate || '').trim(),
                        completionTime: String(snapMap[tid]?.completionTime || '').trim(),
                        done: !!snapMap[tid]?.done,
                        __tmGhost: true,
                    } : null);
                    if (!taskObj) return;
                    seenDocTask.add(tid);
                    docTasks.push(taskObj);
                });
                const taskById = new Map(docTasks.map(t => [String(t?.id || '').trim(), t]).filter(([k]) => !!k));
                const childMap = new Map();
                docTasks.forEach((t) => {
                    const id = String(t?.id || '').trim();
                    const pid = String(t?.parentTaskId || '').trim();
                    if (!id || !pid || !taskById.has(pid) || isDetachedTask(id)) return;
                    if (!childMap.has(pid)) childMap.set(pid, []);
                    childMap.get(pid).push(id);
                });
                childMap.forEach((arr) => arr.sort((a, b) => getOrder(a) - getOrder(b)));
                const rootIds = docTasks
                    .map(t => String(t?.id || '').trim())
                    .filter((id) => {
                        if (!id || !placedMap[id]) return false;
                        const t = taskById.get(id);
                        if (!t) return false;
                        const pid = String(t?.parentTaskId || '').trim();
                        if (isDetachedTask(id)) return true;
                        return !pid || !taskById.has(pid) || !placedMap[pid];
                    })
                    .sort((a, b) => getOrder(a) - getOrder(b));
                const rootSet = new Set(rootIds);
                const links = __tmGetAllTaskLinks({ docId, includeAuto: true });
                const indeg = new Map(rootIds.map(id => [id, 0]));
                const adj = new Map(rootIds.map(id => [id, []]));
                const seenEdge = new Set();
                links.forEach((ln) => {
                    const from = String(ln?.from || '').trim();
                    const to = String(ln?.to || '').trim();
                    if (!rootSet.has(from) || !rootSet.has(to) || from === to) return;
                    const key = `${from}->${to}`;
                    if (seenEdge.has(key)) return;
                    seenEdge.add(key);
                    adj.get(from).push(to);
                    indeg.set(to, (indeg.get(to) || 0) + 1);
                });
                const queue = rootIds.filter(id => (indeg.get(id) || 0) === 0).sort((a, b) => getOrder(a) - getOrder(b));
                const orderedRoots = [];
                while (queue.length) {
                    const id = queue.shift();
                    if (!id) continue;
                    if (orderedRoots.includes(id)) continue;
                    orderedRoots.push(id);
                    (adj.get(id) || []).forEach((to) => {
                        const n = (indeg.get(to) || 0) - 1;
                        indeg.set(to, n);
                        if (n === 0) {
                            queue.push(to);
                            queue.sort((a, b) => getOrder(a) - getOrder(b));
                        }
                    });
                }
                rootIds
                    .filter(id => !orderedRoots.includes(id))
                    .sort((a, b) => getOrder(a) - getOrder(b))
                    .forEach(id => orderedRoots.push(id));

                orderedRoots.forEach((id, idx) => {
                    const t = taskById.get(id);
                    ensureNodePos(t, docId, idx);
                });
                const docNotes = notes.filter(n => String(n?.docId || '').trim() === docId);
                const framePlan = (() => {
                    if (!allView) return { offsetX: 0, offsetY: 0, w: 0, h: 0, empty: false };
                    const CARD_W = 320;
                    const CARD_H = 220;
                    const NOTE_W = 280;
                    const NOTE_H = 120;
                    const PAD = 32;
                    let minX = Infinity;
                    let minY = Infinity;
                    let maxX = -Infinity;
                    let maxY = -Infinity;
                    orderedRoots.forEach((rid) => {
                        const p = posMap[rid];
                        if (!p || String(p?.docId || '').trim() !== docId) return;
                        const x = Number(p.x);
                        const y = Number(p.y);
                        if (!Number.isFinite(x) || !Number.isFinite(y)) return;
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x + CARD_W);
                        maxY = Math.max(maxY, y + CARD_H);
                    });
                    docNotes.forEach((n, idx) => {
                        const x = Number.isFinite(Number(n?.x)) ? Number(n.x) : 24;
                        const y = Number.isFinite(Number(n?.y)) ? Number(n.y) : (24 + idx * 42);
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x + NOTE_W);
                        maxY = Math.max(maxY, y + NOTE_H);
                    });
                    if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) {
                        return { offsetX: 0, offsetY: 0, w: 1000, h: 1000, empty: true };
                    }
                    // Always normalize doc-local coordinates to its own frame,
                    // so historical large absolute positions won't inflate frame size.
                    const offsetX = PAD - minX;
                    const offsetY = PAD - minY;
                    const spanW = Math.max(0, maxX - minX);
                    const spanH = Math.max(0, maxY - minY);
                    const w = Math.max(520, Math.ceil(spanW + PAD * 2));
                    const h = Math.max(220, Math.ceil(spanH + PAD * 2));
                    return { offsetX, offsetY, w, h, empty: false };
                })();

                const renderTaskNode = (id, depth = 0) => {
                    const task = taskById.get(String(id || '').trim());
                    if (!task) return '';
                    const tid = String(task.id || '').trim();
                    const children = (childMap.get(tid) || []).filter((cid) => {
                        const c = String(cid || '').trim();
                        return !!c && taskById.has(c) && !isDetachedTask(c);
                    });
                    const isGhost = !!task.__tmGhost;
                    const selected = String(state.whiteboardSelectedTaskId || '').trim() === tid;
                    const dateTxt = __tmFormatTaskTime(String(task?.completionTime || task?.startDate || '').trim());
                    const opBtn = !isGhost
                        ? `<button class="tm-kanban-more" onclick="tmOpenTaskDetail('${escSq(tid)}', event)" title="任务详情">⋯</button>`
                        : '';
                    const collapsed = children.length ? __tmKanbanGetCollapsedSet().has(tid) : false;
                    const linkStats = __tmGetTaskLinkStats(tid, { docId, includeAuto: false });
                    const hasTaskLinks = (Number(linkStats?.incoming || 0) + Number(linkStats?.outgoing || 0)) > 0;
                    const toggleHtml = children.length
                        ? `<button class="tm-kanban-toggle" onclick="tmWhiteboardToggleTaskCollapse('${escSq(tid)}', event)" title="${collapsed ? '展开子任务' : '折叠子任务'}">${collapsed ? '▸' : '▾'}</button>`
                        : '';
                    const collapseProxyDot = (collapsed && children.length)
                        ? `<span class="tm-task-link-dot tm-whiteboard-collapse-proxy-dot" title="折叠子任务连线汇聚点"></span>`
                        : '';
                    const childrenHtml = children.length
                        ? (collapsed ? '' : `<div class="tm-whiteboard-subtasks">${children.map(cid => renderTaskNode(cid, depth + 1)).join('')}</div>`)
                        : '';
                    const parentCls = children.length ? ' tm-whiteboard-node--parent' : '';
                    const linkCls = hasTaskLinks ? ' tm-whiteboard-node--has-links' : '';
                    const cls = depth === 0
                        ? `tm-whiteboard-card tm-whiteboard-node tm-whiteboard-node--root${parentCls}${linkCls}${selected ? ' tm-whiteboard-card--selected' : ''}${isGhost ? ' tm-whiteboard-card--ghost' : ''}`
                        : `tm-whiteboard-subcard tm-whiteboard-node tm-whiteboard-node--sub${parentCls}${linkCls}${selected ? ' tm-whiteboard-card--selected' : ''}`;
                    const rootPos = depth === 0 ? (posMap[tid] || { x: 24, y: 56 }) : null;
                    const rootStyle = depth === 0
                        ? (() => {
                            const px = Math.round((Number(rootPos.x) || 24) + (allView ? framePlan.offsetX : 0));
                            const py = Math.round((Number(rootPos.y) || 56) + (allView ? framePlan.offsetY : 0));
                            return ` data-x="${px}" data-y="${py}" style="left:${px}px;top:${py}px;"`;
                        })()
                        : '';
                    const nodeMouse = ` onmousedown="tmWhiteboardCardMouseDown(event, '${escSq(tid)}', '${escSq(docId)}')"`;
                    const selectClick = ` onclick="tmWhiteboardSelectTask('${escSq(tid)}', event)"`;
                    const deleteTitle = isGhost ? '移除快照卡片并彻底移除记录（不进入侧边栏）' : '移除卡片并回到侧栏';
                    const parentId = __tmResolveWhiteboardTaskParentId(tid);
                    const parentTask = parentId ? (state.flatTasks?.[parentId] || (snapMap?.[parentId] ? { content: String(snapMap[parentId]?.content || '') } : null)) : null;
                    const parentText = String(parentTask?.content || '').trim();
                    const detachedOrDetachedLike = !!parentId && (
                        isDetachedTask(tid)
                        || (!!placedMap[tid] && !!placedMap[parentId] && rootSet.has(tid))
                    );
                    const canMoveBack = selected && !!parentId && detachedOrDetachedLike;
                    const toolsHtml = selected ? `
                        <div class="tm-whiteboard-card-tools">
                            <button class="tm-btn tm-btn-danger" style="padding:2px 8px;font-size:12px;" onclick="tmWhiteboardDeleteCard('${escSq(tid)}', '${escSq(docId)}', event)" title="${esc(deleteTitle)}">移除</button>
                            ${canMoveBack ? `<button class="tm-btn tm-btn-info" style="padding:2px 8px;font-size:12px;" onclick="tmWhiteboardMoveBackToParent('${escSq(tid)}', '${escSq(docId)}', event)" title="移回父任务">移回父任务</button>` : ''}
                        </div>
                    ` : '';
                    const ghostTip = isGhost ? `<span class="tm-kanban-chip tm-kanban-chip--muted" style="cursor:default;">快照</span>` : '';
                    const st = String(task?.customStatus || '').trim() || 'todo';
                    const opt = statusOptions.find(o => o.id === st) || (st === 'todo' ? todoOpt : { id: st, name: st, color: '#757575' });
                    const pr = String(task?.priority || '').toLowerCase();
                    const prMeta = pr === 'high'
                        ? { label: '高', color: '#ea4335' }
                        : pr === 'medium'
                            ? { label: '中', color: '#f9ab00' }
                            : pr === 'low'
                                ? { label: '低', color: '#34a853' }
                                : { label: '无', color: '#9aa0a6' };
                    const editableMeta = !isGhost;
                    const statusChip = task?.done
                        ? `<span class="tm-kanban-chip tm-kanban-chip--muted" style="cursor:default;">完成</span>`
                        : `<span class="tm-kanban-chip" style="background-color:${esc(opt.color || '#757575')};color:#fff;cursor:${editableMeta ? 'pointer' : 'default'};" ${editableMeta ? `onclick="tmWhiteboardEditStatus('${escSq(tid)}', this, event)"` : ''}>${esc(opt.name || '')}</span>`;
                    return `
                        <div class="${cls}" data-task-id="${esc(tid)}" data-doc-id="${esc(docId)}"${rootStyle}${nodeMouse}${selectClick} oncontextmenu="tmShowTaskContextMenu(event, '${escSq(tid)}')">
                            ${toolsHtml}
                            <span class="tm-task-link-dot tm-task-link-dot--in${state.whiteboardLinkFromTaskId === tid ? ' tm-task-link-dot--active' : ''}" draggable="true" onmousedown="tmTaskLinkDotPressStart(event, '${escSq(tid)}', '${escSq(docId)}')" ondragstart="tmTaskLinkDotDragStart(event, '${escSq(tid)}', '${escSq(docId)}')" ondragend="tmTaskLinkDotDragEnd(event)" ondragover="tmTaskLinkDotDragOver(event, '${escSq(tid)}', '${escSq(docId)}')" ondrop="tmTaskLinkDotDrop(event, '${escSq(tid)}', '${escSq(docId)}')" title="连接输入点"></span>
                            <span class="tm-task-link-dot tm-task-link-dot--out${state.whiteboardLinkFromTaskId === tid ? ' tm-task-link-dot--active' : ''}" draggable="true" onmousedown="tmTaskLinkDotPressStart(event, '${escSq(tid)}', '${escSq(docId)}')" ondragstart="tmTaskLinkDotDragStart(event, '${escSq(tid)}', '${escSq(docId)}')" ondragend="tmTaskLinkDotDragEnd(event)" ondragover="tmTaskLinkDotDragOver(event, '${escSq(tid)}', '${escSq(docId)}')" ondrop="tmTaskLinkDotDrop(event, '${escSq(tid)}', '${escSq(docId)}')" title="连接输出点"></span>
                            ${collapseProxyDot}
                            <div class="tm-whiteboard-card-head">
                                ${toggleHtml}
                                <input class="tm-task-checkbox ${GlobalLock.isLocked() ? 'tm-operating' : ''}" type="checkbox" ${task?.done ? 'checked' : ''} ${(GlobalLock.isLocked() || isGhost) ? 'disabled' : ''} ${isGhost ? 'title="快照任务，当前不可直接勾选"' : ''} onmousedown="event.stopPropagation()" onclick="event.stopPropagation()" onchange="tmSetDone('${escSq(tid)}', this.checked, event)">
                                <div class="tm-whiteboard-card-title ${task?.done ? 'tm-task-done' : ''}">
                                    <span class="tm-task-content-clickable" onclick="tmJumpToTask('${escSq(tid)}', event)" title="${esc(String(task?.content || '').trim() || '(无内容)')}">${esc(String(task?.content || '').trim() || '(无内容)')}</span>
                                </div>
                                ${opBtn}
                            </div>
                            ${(detachedOrDetachedLike && parentText) ? `<div style="font-size:12px;color:var(--tm-secondary-text);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin-bottom:4px;" title="${esc(parentText)}"><span>父任务：</span><span style="font-weight:800;color:var(--tm-text-color);">${esc(parentText)}</span></div>` : ''}
                            <div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
                                ${statusChip}
                                <span class="tm-kanban-chip" style="background-color:${esc(prMeta.color)};color:#fff;cursor:${editableMeta ? 'pointer' : 'default'};" ${editableMeta ? `onclick="tmWhiteboardEditPriority('${escSq(tid)}', this, event)"` : ''}>${esc(prMeta.label)}</span>
                                <span class="tm-kanban-chip tm-kanban-chip--muted" style="cursor:${editableMeta ? 'pointer' : 'default'};" ${editableMeta ? `onclick="tmWhiteboardEditDate('${escSq(tid)}', event)"` : ''} title="${editableMeta ? '点击选择日期' : ''}">📅 ${esc(dateTxt || '日期')}</span>
                                ${ghostTip}
                            </div>
                            ${childrenHtml}
                        </div>
                    `;
                };

                const cardsHtml = orderedRoots.map((rid) => renderTaskNode(rid, 0)).join('');
                let maxX = 0;
                let maxY = 0;
                orderedRoots.forEach((rid) => {
                    const p = posMap[rid];
                    if (!p || String(p?.docId || '').trim() !== docId) return;
                    const x = Number(p.x);
                    const y = Number(p.y);
                    if (Number.isFinite(x)) maxX = Math.max(maxX, x);
                    if (Number.isFinite(y)) maxY = Math.max(maxY, y);
                });
                const frameSize = __tmGetWhiteboardDocFrameSize(docId);
                const hasManualSize = false;
                const autoBoardH = allView ? framePlan.h : (maxY + 230);
                const autoBoardW = allView ? framePlan.w : (maxX + 340);
                let boardH = hasManualSize
                    ? Math.max(220, Number(frameSize?.h) || 0)
                    : (allView ? Math.max(220, autoBoardH) : Math.max(300, autoBoardH));
                let boardW = hasManualSize
                    ? Math.max(520, Number(frameSize?.w) || 0)
                    : (allView ? Math.max(520, autoBoardW) : Math.max(1000, autoBoardW));
                const noCardsAndNotes = !!framePlan.empty;
                if (allView && noCardsAndNotes) {
                    boardW = 500;
                    boardH = 100;
                }
                // 单文档白板不应受文档框尺寸限制：统一扩展为大画布，避免形成“方框限制区域”
                if (!allView) {
                    boardW = Math.max(boardW, 12000);
                    boardH = Math.max(boardH, 8000);
                }
                const cardEmptyHtml = cardsHtml || `<div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:var(--tm-secondary-text);font-size:14px;">无任务</div>`;
                if (!allView) {
                    return `
                        <section class="tm-whiteboard-doc" data-doc-id="${esc(docId)}" style="border:none;background:transparent;">
                            <div class="tm-whiteboard-doc-body" data-doc-id="${esc(docId)}" style="height:${Math.round(boardH)}px;width:${Math.round(boardW)}px;" ondragover="tmWhiteboardBoardDragOver(event)" ondrop="tmWhiteboardBoardDrop(event, '${escSq(docId)}')">
                                <svg class="tm-whiteboard-edges" aria-hidden="true"></svg>
                                ${docNotes.map((n, idx) => {
                                    const nid = String(n?.id || '').trim();
                                    const nx0 = Number.isFinite(Number(n?.x)) ? Number(n.x) : 24;
                                    const ny0 = Number.isFinite(Number(n?.y)) ? Number(n.y) : (24 + idx * 42);
                                    const nx = Math.round(nx0 + (allView ? framePlan.offsetX : 0));
                                    const ny = Math.round(ny0 + (allView ? framePlan.offsetY : 0));
                                    const selected = String(state.whiteboardSelectedNoteId || '').trim() === nid;
                                    const noteColor = __tmNormalizeWhiteboardNoteColor(n?.color) || '';
                                    const noteFont = __tmNormalizeWhiteboardNoteFontSize(n?.fontSize);
                                    const noteBold = __tmNormalizeWhiteboardNoteBold(n?.bold);
                                    const noteWidth = __tmNormalizeWhiteboardNoteWidth(n?.width);
                                    const noteStyle = `${noteColor ? `color:${noteColor};` : ''}font-size:${noteFont}px;font-weight:${noteBold ? '700' : '400'};${noteWidth > 0 ? `width:${noteWidth}px;white-space:pre-wrap;overflow-wrap:anywhere;` : 'white-space:pre;overflow-wrap:normal;'}`;
                                    const toolsHtml = selected
                                        ? `<div class="tm-whiteboard-note-tools">
                                            <button class="tm-btn ${noteBold ? 'tm-btn-primary' : 'tm-btn-secondary'}" style="padding:2px 8px;font-size:12px;font-weight:700;" onclick="tmWhiteboardToggleNoteBold('${escSq(nid)}', event)" title="加粗">B</button>
                                            <button class="tm-btn tm-btn-info" style="padding:2px 6px;font-size:12px;" onclick="tmWhiteboardAdjustNoteFontSize('${escSq(nid)}', -1, event)" title="减小字号">A-</button>
                                            <button class="tm-btn tm-btn-info" style="padding:2px 6px;font-size:12px;" onclick="tmWhiteboardAdjustNoteFontSize('${escSq(nid)}', 1, event)" title="增大字号">A+</button>
                                            ${noteColorOptions.map((c) => `<button class="tm-btn" style="padding:0;width:14px;height:14px;min-width:14px;border-radius:50%;background:${c};border:${noteColor === c ? '2px solid var(--tm-primary-color)' : '1px solid var(--tm-border-color)'};" onclick="tmWhiteboardSetNoteColor('${escSq(nid)}', '${escSq(c)}', event)" title="文字颜色"></button>`).join('')}
                                            <button class="tm-btn tm-btn-danger" style="padding:2px 8px;font-size:12px;" onclick="tmWhiteboardDeleteNote('${escSq(nid)}', event)" title="移除文本">移除</button>
                                        </div>`
                                        : '';
                                    const resizeHtml = selected ? `<span class="tm-whiteboard-note-resize" onmousedown="tmWhiteboardNoteResizeStart(event, '${escSq(nid)}', '${escSq(docId)}')" title="拖拽调节字号"></span><span class="tm-whiteboard-note-width-resize" onmousedown="tmWhiteboardNoteResizeWidthStart(event, '${escSq(nid)}', '${escSq(docId)}')" title="拖拽调节文本框宽度"></span>` : '';
                                    return `<div class="tm-whiteboard-note${selected ? ' tm-whiteboard-note--selected' : ''}" data-note-id="${esc(nid)}" data-doc-id="${esc(docId)}" style="position:absolute;left:${nx}px;top:${ny}px;z-index:4;${noteStyle}" onclick="tmWhiteboardNoteClick('${escSq(nid)}', event)" onmousedown="tmWhiteboardNoteMouseDown(event, '${escSq(nid)}', '${escSq(docId)}')" ondblclick="tmWhiteboardEditNote('${escSq(nid)}', '${escSq(docId)}', event)" title="拖动便签位置，双击编辑">${toolsHtml}${esc(String(n?.text || '').trim())}${resizeHtml}</div>`;
                                }).join('')}
                                ${cardEmptyHtml}
                            </div>
                        </section>
                    `;
                }
                return `
                    <section class="tm-whiteboard-doc" data-doc-id="${esc(docId)}" style="width:${Math.round(boardW)}px;min-width:${Math.round(boardW)}px;">
                        <header class="tm-whiteboard-doc-head" onclick="tmSwitchDoc('${escSq(docId)}')" title="切换到该文档页签" style="cursor:pointer;">
                            <span>📄 ${esc(docNameById.get(docId) || '未知文档')}</span>
                            <span class="tm-badge tm-badge--count">${docTasks.length}</span>
                        </header>
                        <div class="tm-whiteboard-doc-body" data-doc-id="${esc(docId)}" data-frame-offset-x="${allView ? Math.round(framePlan.offsetX) : 0}" data-frame-offset-y="${allView ? Math.round(framePlan.offsetY) : 0}" style="height:${Math.round(boardH)}px;min-height:${Math.round(boardH)}px;width:${Math.round(boardW)}px;min-width:${Math.round(boardW)}px;" ondragover="tmWhiteboardBoardDragOver(event)" ondrop="tmWhiteboardBoardDrop(event, '${escSq(docId)}')">
                            <svg class="tm-whiteboard-edges" aria-hidden="true"></svg>
                            ${docNotes.map((n, idx) => {
                                const nid = String(n?.id || '').trim();
                                const nx0 = Number.isFinite(Number(n?.x)) ? Number(n.x) : 24;
                                const ny0 = Number.isFinite(Number(n?.y)) ? Number(n.y) : (24 + idx * 42);
                                const nx = Math.round(nx0 + (allView ? framePlan.offsetX : 0));
                                const ny = Math.round(ny0 + (allView ? framePlan.offsetY : 0));
                                const selected = String(state.whiteboardSelectedNoteId || '').trim() === nid;
                                const noteColor = __tmNormalizeWhiteboardNoteColor(n?.color) || '';
                                const noteFont = __tmNormalizeWhiteboardNoteFontSize(n?.fontSize);
                                const noteBold = __tmNormalizeWhiteboardNoteBold(n?.bold);
                                const noteWidth = __tmNormalizeWhiteboardNoteWidth(n?.width);
                                const noteStyle = `${noteColor ? `color:${noteColor};` : ''}font-size:${noteFont}px;font-weight:${noteBold ? '700' : '400'};${noteWidth > 0 ? `width:${noteWidth}px;white-space:pre-wrap;overflow-wrap:anywhere;` : 'white-space:pre;overflow-wrap:normal;'}`;
                                const toolsHtml = selected
                                    ? `<div class="tm-whiteboard-note-tools">
                                        <button class="tm-btn ${noteBold ? 'tm-btn-primary' : 'tm-btn-secondary'}" style="padding:2px 8px;font-size:12px;font-weight:700;" onclick="tmWhiteboardToggleNoteBold('${escSq(nid)}', event)" title="加粗">B</button>
                                        <button class="tm-btn tm-btn-info" style="padding:2px 6px;font-size:12px;" onclick="tmWhiteboardAdjustNoteFontSize('${escSq(nid)}', -1, event)" title="减小字号">A-</button>
                                        <button class="tm-btn tm-btn-info" style="padding:2px 6px;font-size:12px;" onclick="tmWhiteboardAdjustNoteFontSize('${escSq(nid)}', 1, event)" title="增大字号">A+</button>
                                        ${noteColorOptions.map((c) => `<button class="tm-btn" style="padding:0;width:14px;height:14px;min-width:14px;border-radius:50%;background:${c};border:${noteColor === c ? '2px solid var(--tm-primary-color)' : '1px solid var(--tm-border-color)'};" onclick="tmWhiteboardSetNoteColor('${escSq(nid)}', '${escSq(c)}', event)" title="文字颜色"></button>`).join('')}
                                        <button class="tm-btn tm-btn-danger" style="padding:2px 8px;font-size:12px;" onclick="tmWhiteboardDeleteNote('${escSq(nid)}', event)" title="移除文本">移除</button>
                                    </div>`
                                    : '';
                                const resizeHtml = selected ? `<span class="tm-whiteboard-note-resize" onmousedown="tmWhiteboardNoteResizeStart(event, '${escSq(nid)}', '${escSq(docId)}')" title="拖拽调节字号"></span><span class="tm-whiteboard-note-width-resize" onmousedown="tmWhiteboardNoteResizeWidthStart(event, '${escSq(nid)}', '${escSq(docId)}')" title="拖拽调节文本框宽度"></span>` : '';
                                return `<div class="tm-whiteboard-note${selected ? ' tm-whiteboard-note--selected' : ''}" data-note-id="${esc(nid)}" data-doc-id="${esc(docId)}" style="position:absolute;left:${nx}px;top:${ny}px;z-index:4;${noteStyle}" onclick="tmWhiteboardNoteClick('${escSq(nid)}', event)" onmousedown="tmWhiteboardNoteMouseDown(event, '${escSq(nid)}', '${escSq(docId)}')" ondblclick="tmWhiteboardEditNote('${escSq(nid)}', '${escSq(docId)}', event)" title="拖动便签位置，双击编辑">${toolsHtml}${esc(String(n?.text || '').trim())}${resizeHtml}</div>`;
                            }).join('')}
                            ${cardEmptyHtml}
                        </div>
                    </section>
                `;
            }).join('');

            const poolSourceDocIds = allView
                ? selectedDocIds.filter((id) => /inbox/i.test(String(docNameById.get(String(id || '').trim()) || ''))
                    || /收件箱|收集箱|收件/.test(String(docNameById.get(String(id || '').trim()) || ''))
                )
                : selectedDocIds;
            const poolSelectedSet = new Set((Array.isArray(state.whiteboardPoolSelectedTaskIds) ? state.whiteboardPoolSelectedTaskIds : []).map((x) => String(x || '').trim()).filter(Boolean));
            const poolHtml = poolSourceDocIds.map((docIdRaw) => {
                const docId = String(docIdRaw || '').trim();
                if (!docId) return '';
                const docTasks0 = (byDoc.get(docId) || []).slice().sort((a, b) => getOrder(a?.id) - getOrder(b?.id));
                const map = new Map();
                docTasks0.forEach((t) => {
                    const id = String(t?.id || '').trim();
                    if (!id || map.has(id)) return;
                    map.set(id, t);
                });
                const hasPlacedAncestor = (taskId) => {
                    let cur = String(taskId || '').trim();
                    const seen = new Set();
                    while (cur && !seen.has(cur)) {
                        seen.add(cur);
                        const t = map.get(cur);
                        const pid = String(t?.parentTaskId || '').trim();
                        if (!pid) return false;
                        if (placedMap[pid]) return true;
                        cur = pid;
                    }
                    return false;
                };
                const listMap = new Map();
                const addToList = (t, locked = false) => {
                    const id = String(t?.id || '').trim();
                    if (!id) return;
                    if (!showDoneTasks && !!t?.done) return;
                    const prev = listMap.get(id);
                    if (prev) {
                        if (!prev.__tmPoolLocked && locked) return;
                        if (prev.__tmPoolLocked && !locked) {
                            const next = { ...(prev || {}), __tmPoolLocked: false };
                            listMap.set(id, next);
                        }
                        return;
                    }
                    listMap.set(id, { ...(t || {}), __tmPoolLocked: !!locked });
                };
                Array.from(map.values()).forEach((t) => {
                    const id = String(t?.id || '').trim();
                    if (!id) return;
                    const placed = !!placedMap[id];
                    const detached = isDetachedTask(id);
                    const hiddenByPlacedAncestor = hasPlacedAncestor(id);
                    if (!placed && !hiddenByPlacedAncestor) {
                        addToList(t, false);
                        return;
                    }
                    if (!placed && hiddenByPlacedAncestor) {
                        // 父任务在白板时，只有“已移出父任务(detached)”的子任务才应回到侧栏显示。
                        if (!detached) return;
                        addToList(t, false);
                        let cur = id;
                        const seen = new Set();
                        while (cur && !seen.has(cur)) {
                            seen.add(cur);
                            const tt = map.get(cur);
                            const pid = String(tt?.parentTaskId || '').trim();
                            if (!pid) break;
                            const pt = map.get(pid);
                            if (pt && placedMap[pid]) addToList(pt, true);
                            cur = pid;
                        }
                    }
                });
                const list = Array.from(listMap.values());
                if (!list.length) return '';
                const groups = new Map();
                list.forEach((t) => {
                    const b = __tmGetDocHeadingBucket(t, noHeadingLabel);
                    if (!groups.has(b.key)) groups.set(b.key, { label: b.label, items: [] });
                    groups.get(b.key).items.push(t);
                });
                const groupKeys0 = __tmBuildDocHeadingBuckets(list, noHeadingLabel).map((b) => b.key);
                const groupKeys = groupKeys0.concat(
                    Array.from(groups.keys()).filter((k) => !groupKeys0.includes(k))
                );
                return `
                    <section class="tm-whiteboard-pool-doc">
                        <header class="tm-whiteboard-pool-doc-head">📄 ${esc(docNameById.get(docId) || '未知文档')} · ${list.length}</header>
                        <div class="tm-whiteboard-pool-list">
                            ${groupKeys.map((gk) => {
                                const g = groups.get(gk) || { label: noHeadingLabel, items: [] };
                                const items = (Array.isArray(g.items) ? g.items : []).slice().sort((a, b) => getOrder(a?.id) - getOrder(b?.id));
                                const groupLabel = String(g.label || noHeadingLabel);
                                const h2DragTaskIds = items
                                    .map((t) => String(t?.id || '').trim())
                                    .filter((tid) => {
                                        if (!tid) return false;
                                        const tt = map.get(tid) || null;
                                        if (tt && tt.__tmPoolLocked) return false;
                                        return true;
                                    });
                                const groupTaskMap = new Map();
                                items.forEach((t) => {
                                    const id = String(t?.id || '').trim();
                                    if (!id || groupTaskMap.has(id)) return;
                                    groupTaskMap.set(id, t);
                                });
                                const groupChildrenMap = new Map();
                                items.forEach((t) => {
                                    const id = String(t?.id || '').trim();
                                    const pid = String(t?.parentTaskId || '').trim();
                                    if (!id || !pid || !groupTaskMap.has(pid)) return;
                                    if (!groupChildrenMap.has(pid)) groupChildrenMap.set(pid, []);
                                    groupChildrenMap.get(pid).push(id);
                                });
                                groupChildrenMap.forEach((arr) => arr.sort((a, b) => getOrder(a) - getOrder(b)));
                                const groupRootIds = Array.from(groupTaskMap.keys())
                                    .filter((id) => {
                                        const t = groupTaskMap.get(id);
                                        if (!t) return false;
                                        const pid = String(t?.parentTaskId || '').trim();
                                        return !pid || !groupTaskMap.has(pid);
                                    })
                                    .sort((a, b) => getOrder(a) - getOrder(b));
                                const renderPoolTaskNode = (taskId, depth = 0) => {
                                    const t = groupTaskMap.get(String(taskId || '').trim());
                                    if (!t) return '';
                                    const tid = String(t?.id || '').trim();
                                    if (!tid) return '';
                                    const childIds = (groupChildrenMap.get(tid) || []).filter((cid) => groupTaskMap.has(cid));
                                    const collapsed = childIds.length ? __tmKanbanGetCollapsedSet().has(tid) : false;
                                    const toggleHtml = childIds.length
                                        ? `<button class="tm-whiteboard-pool-toggle" onclick="tmWhiteboardToggleTaskCollapse('${escSq(tid)}', event)" onmousedown="event.stopPropagation()" title="${collapsed ? '展开子任务' : '折叠子任务'}">${collapsed ? '▸' : '▾'}</button>`
                                        : '<span style="display:inline-block;width:14px;height:14px;"></span>';
                                    const indent = Math.max(0, Math.min(10, Number(depth) || 0)) * 16;
                                    const doneCls = t?.done ? ' tm-whiteboard-pool-item--done' : '';
                                    const parentCls = childIds.length ? ' tm-whiteboard-pool-item--parent' : '';
                                    const topCls = depth === 0 ? ' tm-whiteboard-pool-item--top' : '';
                                    const lockedCls = t?.__tmPoolLocked ? ' tm-whiteboard-pool-item--locked' : '';
                                    const selectedCls = poolSelectedSet.has(tid) ? ' tm-whiteboard-pool-item--selected' : '';
                                    const draggableAttr = t?.__tmPoolLocked ? 'false' : 'true';
                                    const dragStartAttr = t?.__tmPoolLocked ? '' : ` ondragstart="tmWhiteboardPoolDragStart(event, '${escSq(tid)}', '${escSq(docId)}')"`;
                                    const dragEndAttr = t?.__tmPoolLocked ? '' : ' ondragend="tmWhiteboardPoolDragEnd(event)"';
                                    const mouseDownAttr = ` onmousedown="tmWhiteboardPoolItemMouseDown(event, '${escSq(tid)}', '${escSq(docId)}', ${t?.__tmPoolLocked ? 'true' : 'false'})"`;
                                    const itemTitle = t?.__tmPoolLocked ? '父任务已在白板中，不可重复拖入' : '拖动到白板';
                                    const kidsHtml = (!collapsed && childIds.length)
                                        ? childIds.map((cid) => renderPoolTaskNode(cid, depth + 1)).join('')
                                        : '';
                                    return `
                                        <div class="tm-whiteboard-pool-node" style="padding-left:${indent}px;">
                                            <div class="tm-whiteboard-pool-item${doneCls}${parentCls}${topCls}${lockedCls}${selectedCls}" data-task-id="${esc(tid)}" draggable="${draggableAttr}"${mouseDownAttr}${dragStartAttr}${dragEndAttr} title="${itemTitle}">
                                                ${toggleHtml}
                                                <input class="tm-task-checkbox" type="checkbox" ${t?.done ? 'checked' : ''} onchange="tmSetDone('${escSq(tid)}', this.checked, event)" onmousedown="event.stopPropagation()" title="完成状态">
                                                <span class="tm-whiteboard-pool-item-title"><span class="tm-task-content-clickable" onclick="tmJumpToTask('${escSq(tid)}', event)" title="${esc(String(t?.content || '').trim() || '(无内容)')}">${esc(String(t?.content || '').trim() || '(无内容)')}</span></span>
                                            </div>
                                            ${kidsHtml}
                                        </div>
                                    `;
                };
                                return `
                                    <div class="tm-whiteboard-pool-h2"
                                        draggable="${h2DragTaskIds.length ? 'true' : 'false'}"
                                        data-doc-id="${esc(docId)}"
                                        data-h2="${esc(groupLabel)}"
                                        data-task-ids="${esc(h2DragTaskIds.join(','))}"
                                        ${h2DragTaskIds.length ? `ondragstart="tmWhiteboardPoolH2DragStart(event, '${escSq(docId)}', '${escSq(groupLabel)}')" ondragend="tmWhiteboardPoolDragEnd(event)"` : ''}
                                        title="${h2DragTaskIds.length ? '拖动该二级标题及其任务到白板' : ''}">🧩 ${esc(groupLabel)} · ${items.length}</div>
                                    ${groupRootIds.map((rid) => renderPoolTaskNode(rid, 0)).join('')}
                                `;
                            }).join('')}
                        </div>
                    </section>
                `;
            }).join('');

            if (posDirty) {
                SettingsStore.data.whiteboardNodePos = posMap;
                try { SettingsStore.syncToLocal(); } catch (e) {}
            }
            if (placedDirty) {
                SettingsStore.data.whiteboardPlacedTaskIds = placedMap;
                try { SettingsStore.syncToLocal(); } catch (e) {}
            }

            const whiteboardTool = String(SettingsStore.data.whiteboardTool || 'pan').trim();
            const viewportPanClass = whiteboardTool === 'pan' ? ' tm-whiteboard-viewport--tool-pan' : '';
            const sidebarCollapsed = !!SettingsStore.data.whiteboardSidebarCollapsed;
            const sidebarWidth = Math.max(220, Math.min(520, Math.round(Number(SettingsStore.data.whiteboardSidebarWidth) || 300)));
            const layoutClass = sidebarCollapsed ? ' tm-whiteboard-layout--sidebar-collapsed' : '';
            const sidebarToggleLabel = sidebarCollapsed ? '展开侧栏' : '折叠侧栏';
            const sidebarToggleGlyph = sidebarCollapsed ? '☰' : '⟨';
            return `
                <div class="tm-body tm-body--whiteboard${bodyAnimClass}" id="tmWhiteboardBody">
                    <div class="tm-whiteboard-layout${layoutClass}" style="--tm-wb-sidebar-width:${sidebarWidth}px;">
                        <aside class="tm-whiteboard-sidebar">
                            <div class="tm-whiteboard-sidebar-title-row">
                                <div class="tm-whiteboard-sidebar-title">任务池</div>
                                <label class="tm-whiteboard-sidebar-switch" title="显示已完成任务">
                                    <input type="checkbox" ${showDoneTasks ? 'checked' : ''} onchange="tmWhiteboardToggleShowDone(this.checked)">
                                    <span>已完成</span>
                                </label>
                            </div>
                            ${poolHtml || `<div style="color:var(--tm-secondary-text);font-size:12px;">当前没有可拖出的任务</div>`}
                        </aside>
                        <div class="tm-whiteboard-sidebar-resizer" onmousedown="tmStartWhiteboardSidebarResize(event)" title="拖拽调整侧栏宽度"></div>
                        <div class="tm-whiteboard-main">
                            <button class="tm-btn tm-btn-info tm-whiteboard-sidebar-toggle" onclick="tmWhiteboardToggleSidebar(event)" title="${sidebarToggleLabel}">${sidebarToggleGlyph}</button>
                            <div id="tmWhiteboardViewport" class="tm-whiteboard-viewport${viewportPanClass}" onpointerdown="tmWhiteboardViewportMouseDown(event)" ontouchstart="tmWhiteboardViewportTouchStart(event)" ontouchmove="tmWhiteboardViewportTouchMove(event)" ontouchend="tmWhiteboardViewportTouchEnd(event)" ontouchcancel="tmWhiteboardViewportTouchEnd(event)" onclick="tmWhiteboardBoardClick(event)" ondblclick="tmWhiteboardBoardDblClick(event)" onwheel="tmWhiteboardViewportWheel(event)" ondragover="tmWhiteboardBoardDragOver(event)" ondrop="tmWhiteboardBoardDrop(event)">
                                <div id="tmWhiteboardWorld" class="tm-whiteboard-world" style="transform:translate(${view.x}px, ${view.y}px) scale(${view.zoom});">
                                    <div class="tm-whiteboard">
                                        ${docsHtml || `<div style="padding:18px;color:var(--tm-secondary-text);">暂无任务可用于白板视图</div>`}
                                    </div>
                                </div>
                                <div class="tm-whiteboard-bottom-toolbar">
                                    <button class="tm-btn ${whiteboardTool === 'pan' ? 'tm-btn-primary' : 'tm-btn-info'}" onclick="tmWhiteboardSetTool('pan')" style="padding: 4px 10px;" title="平移模式">平移</button>
                                    <button class="tm-btn ${whiteboardTool === 'select' ? 'tm-btn-primary' : 'tm-btn-info'}" onclick="tmWhiteboardSetTool('select')" style="padding: 4px 10px;" title="多选模式">多选</button>
                                    <button class="tm-btn ${whiteboardTool === 'text' ? 'tm-btn-primary' : 'tm-btn-info'}" onclick="tmWhiteboardSetTool('text')" style="padding: 4px 10px;" title="文字模式">文字</button>
                                    <button class="tm-btn tm-btn-info" onclick="tmWhiteboardZoomOut()" style="padding: 4px 10px;" title="缩小画布">－</button>
                                    <button class="tm-btn tm-btn-info" onclick="tmWhiteboardZoomIn()" style="padding: 4px 10px;" title="放大画布">＋</button>
                                    <button class="tm-btn tm-btn-info" onclick="tmWhiteboardResetView()" style="padding: 4px 10px;" title="重置视图">重置</button>
                                    <button class="tm-btn tm-btn-info" onclick="tmWhiteboardClearLinks()" style="padding: 4px 10px;" title="清空手动连线">清空连线</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        };

        const __tmTimelineRowModel = state.viewMode === 'timeline' ? __tmBuildTaskRowModel() : null;
        const mainBodyHtml = state.viewMode === 'calendar'
            ? __tmRenderCalendarBodyHtml()
            : state.viewMode === 'whiteboard'
                ? __tmRenderWhiteboardBodyHtml()
            : state.viewMode === 'timeline'
                ? __tmRenderTimelineBodyHtml(__tmTimelineRowModel)
                : state.viewMode === 'kanban'
                    ? __tmRenderKanbanBodyHtml()
                    : __tmRenderListBodyHtml();
        const showCalendarSideDock = __tmShouldShowCalendarSideDock() && !isMobile;
        const calendarSideDockWidth = Math.max(260, Math.min(760, Math.round(Number(SettingsStore.data.calendarSideDockWidth) || 340)));
        const bodyWithSideDockHtml = showCalendarSideDock
            ? `
                <div class="tm-main-body-with-cal-dock">
                    ${mainBodyHtml}
                    <div class="tm-calendar-side-dock-resizer" onmousedown="tmStartCalendarSideDockResize(event)" title="拖拽调整侧栏宽度"></div>
                    <aside class="tm-calendar-side-dock" style="width:${calendarSideDockWidth}px;min-width:${calendarSideDockWidth}px;">
                        <div id="tmCalendarSideDockPanel"></div>
                    </aside>
                </div>
            `
            : mainBodyHtml;
        
        state.modal.innerHTML = `
            <div class="tm-box${showCalendarSideDock ? ' tm-box--with-cal-dock' : ''}">
                <div class="tm-filter-rule-bar" style="padding: 8px 12px;">
                    <div style="display:flex;align-items:center;gap:10px;flex-wrap:nowrap;justify-content:space-between;min-width:0;">
                        <div style="display:flex;align-items:center;gap:10px;">
                            <div class="tm-title" onclick="tmToggleDocTabs(event)" style="font-size: 16px; font-weight: 700; white-space: nowrap;">📋 任务管理器</div>
                            <button class="tm-btn tm-btn-success" onclick="tmAdd()" style="padding: 0 10px; height: 30px; display: inline-flex; align-items: center; justify-content: center;">+</button>
                            ${isMobile ? `<button class="tm-btn tm-btn-info" onclick="tmRefresh()" style="padding: 0 10px; height: 30px; display: inline-flex; align-items: center; justify-content: center;">🔄️</button>` : ''}
                            ${isMobile && state.viewMode === 'calendar' ? `<button class="tm-btn tm-btn-info" onclick="tmCalendarToggleSidebar()" style="padding: 0 10px; height: 30px; display: inline-flex; align-items: center; justify-content: center;" title="侧边栏">📅</button>` : ''}
                            ${(state.viewMode === 'timeline' && ((isMobile && isLandscape) || isDesktopNarrow)) ? `
                                <button class="tm-btn tm-btn-info" onclick="tmGanttZoomOut()" style="padding: 0 8px; height: 30px; display: inline-flex; align-items: center; justify-content: center;" title="缩小">－</button>
                                <button class="tm-btn tm-btn-info" onclick="tmGanttZoomIn()" style="padding: 0 8px; height: 30px; display: inline-flex; align-items: center; justify-content: center;" title="放大">＋</button>
                                <button class="tm-btn tm-btn-info" onclick="tmGanttFit()" style="padding: 0 8px; height: 30px; display: inline-flex; align-items: center; justify-content: center;" title="适配范围">🗺️</button>
                                <button class="tm-btn tm-btn-info" onclick="tmGanttToday()" style="padding: 0 8px; height: 30px; display: inline-flex; align-items: center; justify-content: center;" title="定位今天">📅</button>
                            ` : ''}
                        </div>

                        <!-- 桌面端工具栏 -->
                        <div class="tm-desktop-toolbar tm-header-selectors" style="display:${isMobile ? 'none' : 'flex'};align-items:center;gap:8px;flex:1;min-width:0;">
                            <div class="tm-rule-selector" style="margin-left: 6px;">
                                <span class="tm-rule-label">文档:</span>
                                <select class="tm-rule-select" onchange="tmSwitchDocGroup(this.value)" aria-label="分组" title="分组">
                                    <option value="all" ${currentGroupId === 'all' ? 'selected' : ''}>全部文档</option>
                                    ${docGroups.map(g => `<option value="${g.id}" ${currentGroupId === g.id ? 'selected' : ''}>${esc(g.name)}</option>`).join('')}
                                </select>
                            </div>

                            <div class="tm-rule-selector">
                                <span class="tm-rule-label">规则:</span>
                                <select class="tm-rule-select" onchange="applyFilterRule(this.value)" aria-label="规则" title="规则">
                                    <option value="">全部</option>
                                    ${ruleOptions}
                                </select>
                            </div>
                            ${currentRule ? `
                                <div class="tm-rule-display">
                                    <span class="tm-rule-stats">${filteredCount} 个任务</span>
                                </div>
                            ` : ''}
                            <div style="flex: 1 1 auto;"></div>
                            
                            <div class="tm-rule-selector">
                                <span class="tm-rule-label">分组:</span>
                                <select class="tm-rule-select" onchange="tmSwitchGroupMode(this.value)" aria-label="模式" title="模式">
                                    <option value="none" ${(!state.groupByDocName && !state.groupByTaskName && !state.groupByTime && !state.quadrantEnabled) ? 'selected' : ''}>不分组</option>
                                    <option value="doc" ${state.groupByDocName ? 'selected' : ''}>按文档</option>
                                    <option value="time" ${state.groupByTime ? 'selected' : ''}>按时间</option>
                                    <option value="quadrant" ${state.quadrantEnabled ? 'selected' : ''}>四象限</option>
                                    ${SettingsStore.data.groupByTaskName ? `<option value="task" ${state.groupByTaskName ? 'selected' : ''}>按任务名</option>` : ''}
                                </select>
                            </div>

                        </div>
                        
                        <!-- 移动端菜单按钮 -->
                            <div class="tm-mobile-menu-btn" style="display:${isMobile ? 'block' : 'none'};margin-left:auto;">
                            <div style="display:flex;align-items:center;gap:10px;">
                                <button class="tm-btn tm-btn-info" onclick="tmToggleMobileMenu(event)" ontouchend="tmToggleMobileMenu(event)" style="padding: 0 10px; height: 30px; display: inline-flex; align-items: center; justify-content: center;">
                                    <span style="font-size: 16px; transform: translateY(1px); line-height: 1;">☰</span>
                                    <span style="margin-left: 4px;">菜单</span>
                                </button>
                                ${isMobile ? `<button class="tm-btn tm-btn-gray" onclick="tmClose(event)" ontouchend="tmClose(event)" style="padding: 0 10px; height: 30px; display: inline-flex; align-items: center; justify-content: center;"><span style="transform: translateY(1px); line-height: 1;">✖</span></button>` : ''}
                            </div>
                        </div>
                    </div>
                    
                    <!-- 桌面端搜索栏 -->
                    <div class="tm-search-box tm-desktop-toolbar" style="display:${isMobile ? 'none' : 'flex'}; flex-wrap: wrap;">
                        <div class="tm-view-segmented" role="tablist" aria-label="视图">
                            <button class="tm-view-seg-item ${state.viewMode === 'list' ? 'tm-view-seg-item--active' : ''}" onclick="tmSwitchViewMode('list')" role="tab" aria-selected="${state.viewMode === 'list' ? 'true' : 'false'}" title="表格">表格</button>
                            <button class="tm-view-seg-item ${state.viewMode === 'timeline' ? 'tm-view-seg-item--active' : ''}" onclick="tmSwitchViewMode('timeline')" role="tab" aria-selected="${state.viewMode === 'timeline' ? 'true' : 'false'}" title="时间轴">时间轴</button>
                            <button class="tm-view-seg-item ${state.viewMode === 'whiteboard' ? 'tm-view-seg-item--active' : ''}" onclick="tmSwitchViewMode('whiteboard')" role="tab" aria-selected="${state.viewMode === 'whiteboard' ? 'true' : 'false'}" title="白板">白板</button>
                            <button class="tm-view-seg-item ${state.viewMode === 'kanban' ? 'tm-view-seg-item--active' : ''}" onclick="tmSwitchViewMode('kanban')" role="tab" aria-selected="${state.viewMode === 'kanban' ? 'true' : 'false'}" title="看板">看板</button>
                            <button class="tm-view-seg-item ${state.viewMode === 'calendar' ? 'tm-view-seg-item--active' : ''}" onclick="tmSwitchViewMode('calendar')" role="tab" aria-selected="${state.viewMode === 'calendar' ? 'true' : 'false'}" title="日历">日历</button>
                        </div>
                        ${state.viewMode === 'timeline' ? `
                            <button class="tm-btn tm-btn-info" onclick="tmGanttZoomOut()" style="padding: 4px 10px;" title="缩小">－</button>
                            <button class="tm-btn tm-btn-info" onclick="tmGanttZoomIn()" style="padding: 4px 10px;" title="放大">＋</button>
                            <button class="tm-btn tm-btn-info" onclick="tmGanttFit()" style="padding: 4px 10px;" title="适配范围">🗺️</button>
                            <button class="tm-btn tm-btn-info" onclick="tmGanttToday()" style="padding: 4px 10px;" title="定位今天">📅</button>
                        ` : ''}
                        <button class="tm-btn tm-btn-info" onclick="tmRefresh()" style="padding: 4px 10px;" title="刷新">🔄️</button>
                        <button class="tm-btn tm-btn-info" onclick="showSettings()" style="padding: 4px 10px;">⚙️ 设置</button>
                        ${!isMobile ? `
                            <button class="tm-btn tm-btn-info tm-desktop-menu-btn" onclick="tmToggleDesktopMenu(event)" style="padding: 4px 10px; display: flex; align-items: center; gap: 4px;">
                                <span>☰</span> 菜单
                            </button>
                        ` : ''}
                    </div>

                        <!-- 移动端下拉菜单 -->
                        <div id="tmMobileMenu" style="display:none; position:absolute; right:0; top:45px; width:max-content; max-width:calc(100vw - 20px); min-width:0; box-sizing:border-box; padding:10px; border:1px solid var(--tm-border-color); border-radius:6px; background:var(--tm-header-bg); z-index:10001; box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
                            <div style="display:flex; flex-direction:column; gap:10px;">
                                <div class="tm-mobile-only-item" style="display:flex; flex-direction:column; gap:6px; align-items:stretch;">
                                    <span style="color:var(--tm-text-color);">视图:</span>
                                    <div style="overflow-x:auto; -webkit-overflow-scrolling:touch;">
                                        <div class="tm-view-segmented" role="tablist" aria-label="视图" style="height:28px; min-width:max-content;">
                                            <button class="tm-view-seg-item ${state.viewMode === 'list' ? 'tm-view-seg-item--active' : ''}" onclick="tmSwitchViewMode('list')" role="tab" aria-selected="${state.viewMode === 'list' ? 'true' : 'false'}" style="line-height:28px; padding:0 10px;">表格</button>
                                            <button class="tm-view-seg-item ${state.viewMode === 'timeline' ? 'tm-view-seg-item--active' : ''}" onclick="tmSwitchViewMode('timeline')" role="tab" aria-selected="${state.viewMode === 'timeline' ? 'true' : 'false'}" style="line-height:28px; padding:0 10px;">时间轴</button>
                                            <button class="tm-view-seg-item ${state.viewMode === 'whiteboard' ? 'tm-view-seg-item--active' : ''}" onclick="tmSwitchViewMode('whiteboard')" role="tab" aria-selected="${state.viewMode === 'whiteboard' ? 'true' : 'false'}" style="line-height:28px; padding:0 10px;">白板</button>
                                            <button class="tm-view-seg-item ${state.viewMode === 'kanban' ? 'tm-view-seg-item--active' : ''}" onclick="tmSwitchViewMode('kanban')" role="tab" aria-selected="${state.viewMode === 'kanban' ? 'true' : 'false'}" style="line-height:28px; padding:0 10px;">看板</button>
                                            <button class="tm-view-seg-item ${state.viewMode === 'calendar' ? 'tm-view-seg-item--active' : ''}" onclick="tmSwitchViewMode('calendar')" role="tab" aria-selected="${state.viewMode === 'calendar' ? 'true' : 'false'}" style="line-height:28px; padding:0 10px;">日历</button>
                                        </div>
                                    </div>
                                </div>
                                <div class="tm-mobile-only-item" style="display:flex; gap:10px; align-items:center;">
                                    <span style="color:var(--tm-text-color);width:60px;">文档:</span>
                                    <select class="tm-rule-select" style="flex:1;" onchange="tmSwitchDocGroup(this.value)">
                                        <option value="all" ${currentGroupId === 'all' ? 'selected' : ''}>全部文档</option>
                                        ${docGroups.map(g => `<option value="${g.id}" ${currentGroupId === g.id ? 'selected' : ''}>${esc(g.name)}</option>`).join('')}
                                    </select>
                                </div>
                                <div class="tm-mobile-only-item" style="display:flex; gap:10px; align-items:center;">
                                    <span style="color:var(--tm-text-color);width:60px;">规则:</span>
                                    <select class="tm-rule-select" style="flex:1;" onchange="applyFilterRule(this.value)">
                                        <option value="">全部</option>
                                        ${ruleOptions}
                                    </select>
                                </div>
                                <div class="tm-mobile-only-item" style="display:flex; gap:10px; align-items:center;">
                                    <span style="color:var(--tm-text-color);width:60px;">分组:</span>
                                    <select class="tm-rule-select" style="flex:1;" onchange="tmSwitchGroupMode(this.value)">
                                        <option value="none" ${(!state.groupByDocName && !state.groupByTaskName && !state.groupByTime && !state.quadrantEnabled) ? 'selected' : ''}>不分组</option>
                                        <option value="doc" ${state.groupByDocName ? 'selected' : ''}>按文档</option>
                                        <option value="time" ${state.groupByTime ? 'selected' : ''}>按时间</option>
                                        <option value="quadrant" ${state.quadrantEnabled ? 'selected' : ''}>四象限</option>
                                        ${SettingsStore.data.groupByTaskName ? `<option value="task" ${state.groupByTaskName ? 'selected' : ''}>按任务名</option>` : ''}
                                    </select>
                                </div>
                                <div style="display:flex; gap:10px; align-items:center;">
                                    <button class="tm-btn tm-btn-info" onclick="tmShowSearchModal()" style="flex:1; padding: 6px;">
                                        🔍 搜索 ${state.searchKeyword ? `(${state.searchKeyword})` : ''}
                                    </button>
                                </div>
                                <div class="tm-mobile-only-item" style="display:flex; gap:10px; align-items:center;">
                                    <button class="tm-btn tm-btn-info" onclick="tmShowSummaryModal(); tmHideMobileMenu();" style="flex:1; padding: 6px;">
                                        📝 摘要
                                    </button>
                                </div>
                                <div class="tm-mobile-only-item" style="display:flex; gap:10px; align-items:center;">
                                    <button class="tm-btn tm-btn-info" onclick="tmToggleCalendarSideDock(); tmHideMobileMenu();" style="flex:1; padding: 6px;">
                                        ${SettingsStore.data.calendarSideDockEnabled ? '☑' : '☐'} 日历侧边栏
                                    </button>
                                </div>
                                <div class="tm-mobile-only-item" style="display:flex; gap:10px; align-items:center;">
                                    <button class="tm-btn tm-btn-info" onclick="tmToggleWhiteboardSequenceMode(); tmHideMobileMenu();" style="flex:1; padding: 6px;">
                                        ${SettingsStore.data.whiteboardSequenceMode ? '☑' : '☐'} 白板顺序模式
                                    </button>
                                </div>
                                <div class="tm-mobile-only-item" style="display:flex; gap:10px;">
                                     <button class="tm-btn tm-btn-info" onclick="showSettings()" style="flex:1; padding: 6px;">⚙️ 设置</button>
                                </div>
                                <div class="tm-mobile-only-item" style="display:flex; gap:10px;">
                                     <button class="tm-btn tm-btn-info" onclick="tmCollapseAllTasks()" style="flex:1; padding: 6px;">▸ 折叠</button>
                                     <button class="tm-btn tm-btn-info" onclick="tmExpandAllTasks()" style="flex:1; padding: 6px;">▾ 展开</button>
                                </div>
                                ${currentRule ? `<div class="tm-mobile-only-item" style="color:var(--tm-secondary-text);font-size:12px;">当前规则: ${esc(currentRule.name)} (${filteredCount}任务)</div>` : ''}
                            </div>
                        </div>
                    </div>
                    
                    <style>
                        /* 默认隐藏移动端专属项（因为桌面端工具栏已经有了） */
                        .tm-mobile-only-item {
                            display: none !important;
                        }
                        
                        /* 移动端下显示 */
                        @media (max-width: 768px) {
                            .tm-mobile-only-item {
                                display: flex !important;
                            }
                        }
                    </style>

                <div class="tm-doc-tabs ${state.docTabsHidden ? 'tm-doc-tabs--hidden' : ''}">
                    <div style="display:flex; gap:8px; overflow-x:auto; flex:1; align-items:center; padding: ${isMobile ? '4px 12px 4px 12px' : '4px 0 4px 0'};">
                        <div class="tm-doc-tab ${state.activeDocId === 'all' ? 'active' : ''}" onclick="tmSwitchDoc('all')">全部</div>
                        ${(() => {
                            const id = String(SettingsStore.data.newTaskDocId || '').trim();
                            if (!id || id === '__dailyNote__') return '';
                            const docName = state.taskTree.find(d => d.id === id)?.name
                                || state.allDocuments.find(d => d.id === id)?.name
                                || '未命名文档';
                            const isActive = state.activeDocId === id;
                            const c = __tmGetDocColorHex(id, __tmIsDarkMode());
                            return `<div class="tm-doc-tab ${isActive ? 'active' : ''}" data-tm-doc-id="${esc(id)}" style="--tm-doc-color:${esc(c)}" oncontextmenu="tmShowDocTabContextMenu(event, '${id}')" onclick="tmSwitchDoc('${id}')" title="全局新建文档">📥 ${esc(docName)}</div>`;
                        })()}
                        ${visibleDocs.map(doc => {
                            const isActive = state.activeDocId === doc.id;
                            const c = __tmGetDocColorHex(doc.id, __tmIsDarkMode());
                            const pid = `tm-doc-prog-${doc.id}`;
                            // 预设宽度（如果缓存有值，直接渲染，减少闪烁）
                            const cachedPercent = __tmDocProgressCache?.get(doc.id) || 0;
                            // 调度异步更新
                            setTimeout(() => __tmUpdateDocTabProgress(doc.id, pid, c), 0);
                            return `<div class="tm-doc-tab ${isActive ? 'active' : ''}" 
                                data-tm-doc-id="${esc(doc.id)}" 
                                style="--tm-doc-color:${esc(c)}" 
                                oncontextmenu="tmShowDocTabContextMenu(event, '${doc.id}')" 
                                ondragenter="tmDocTabDragEnter(event)" 
                                ondragleave="tmDocTabDragLeave(event)" 
                                ondragover="tmDocTabDragOver(event)" 
                                ondrop="tmDocTabDrop(event, '${doc.id}')" 
                                onclick="tmSwitchDoc('${doc.id}')">
                                <div class="tm-doc-tab-bg" id="${pid}" style="width:${cachedPercent}%"></div>
                                <div class="tm-doc-tab-text">${esc(doc.name)}</div>
                            </div>`;
                        }).join('')}
                    </div>
                    <div style="border-left:1px solid var(--tm-border-color); padding-left:8px; margin-left:8px; display:none; gap:8px;">
                         ${!isMobile ? `` : ''}
                    </div>
                </div>
                
                <style>
                    .tm-title {
                        cursor: pointer;
                        user-select: none;
                    }
                    .tm-doc-tabs {
                        display: flex;
                        align-items: center;
                        flex-shrink: 0;
                        padding: 0 15px;
                        border-bottom: 1px solid var(--tm-border-color);
                        background: var(--tm-header-bg);
                        max-height: 56px;
                        overflow: hidden;
                        transition: max-height 0.18s ease, opacity 0.18s ease, border-color 0.18s ease, padding-top 0.18s ease, padding-bottom 0.18s ease;
                        opacity: 1;
                    }
                    .tm-box--with-cal-dock .tm-doc-tabs {
                        flex: 0 0 auto;
                        max-height: 56px;
                        overflow: hidden;
                    }
                    .tm-doc-tabs.tm-doc-tabs--hidden {
                        max-height: 0;
                        opacity: 0;
                        border-bottom-color: transparent;
                        padding-top: 0;
                        padding-bottom: 0;
                        pointer-events: none;
                    }
                    .tm-doc-tabs > div::-webkit-scrollbar {
                        height: 4px;
                    }
                    .tm-doc-tabs > div::-webkit-scrollbar-thumb {
                        background: var(--tm-border-color);
                        border-radius: 2px;
                    }
                    .tm-doc-tabs > div {
                        min-width: 0;
                        -webkit-overflow-scrolling: touch;
                    }
                    .tm-doc-tab {
                        padding: 2px 8px;
                        border-radius: 6px;
                        background: var(--tm-bg-color);
                        color: var(--tm-text-color);
                        font-size: 13px;
                        cursor: pointer;
                        white-space: nowrap;
                        flex: 0 0 auto;
                        border: 1px solid var(--tm-border-color);
                        transition: transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease, background 0.12s ease;
                        user-select: none;
                        height: 24px;
                        line-height: 16px;
                        display: flex;
                        align-items: center;
                        position: relative;
                        overflow: hidden;
                    }
                    .tm-doc-tab-bg {
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 0%;
                        height: 100%;
                        background: var(--tm-doc-color, transparent);
                        opacity: 0.2;
                        transition: width 0.3s ease;
                        z-index: 0;
                        pointer-events: none;
                    }
                    .tm-doc-tab-text {
                        position: relative;
                        z-index: 1;
                    }
                    .tm-doc-tab::after {
                        content: '';
                        position: absolute;
                        left: 0;
                        right: 0;
                        bottom: -1px;
                        height: 4px;
                        border-radius: 0;
                        background: var(--tm-doc-color, transparent);
                        opacity: 0.95;
                        z-index: 2;
                    }
                    .tm-doc-tab:hover {
                        background: var(--tm-hover-bg);
                        border-color: var(--tm-text-color);
                    }
                    .tm-doc-tab.active {
                        background: var(--tm-bg-color);
                        color: var(--tm-text-color);
                        border-color: var(--tm-primary-color);
                        box-shadow: inset 0 0 0 1px var(--tm-primary-color), 0 0 0 1px color-mix(in srgb, var(--tm-primary-color) 18%, transparent);
                    }
                    .tm-doc-tab.active .tm-doc-tab-bg {
                        opacity: 0.38;
                    }
                    .tm-doc-tab.is-drop-target {
                        transform: scale(1.06);
                        border-color: var(--tm-primary-color);
                        box-shadow: 0 6px 16px rgba(0,0,0,0.15);
                        z-index: 10;
                        transform-origin: center;
                    }
                    
                    @media (max-width: 768px) {
                        .tm-desktop-toolbar {
                            display: none !important;
                        }
                        .tm-mobile-menu-btn {
                            display: block !important;
                        }
                        .tm-filter-rule-bar {
                            flex-wrap: wrap;
                        }
                        .tm-doc-tabs {
                            padding: 8px 0;
                            width: 100%;
                            box-sizing: border-box;
                        }
                        .tm-doc-tab {
                            font-size: 12px;
                            padding: 2px 8px;
                            height: 24px;
                            border-radius: 6px;
                        }
                    }

                    @media (max-width: 1024px) {
                        .tm-header-selectors {
                            display: none !important;
                        }
                        .tm-mobile-menu-btn {
                            display: block !important;
                        }
                        .tm-mobile-only-item {
                            display: flex !important;
                        }
                        .tm-desktop-menu-btn {
                            display: none !important;
                        }
                    }
                    .tm-main-body-with-cal-dock {
                        flex: 1 1 auto;
                        min-height: 0;
                        min-width: 0;
                        display: flex;
                        align-items: stretch;
                    }
                    .tm-main-body-with-cal-dock > .tm-body {
                        flex: 1 1 auto;
                        min-height: 0;
                        min-width: 0;
                    }
                    .tm-calendar-side-dock {
                        border-left: 1px solid var(--tm-border-color);
                        background: var(--tm-bg-color);
                        overflow: hidden;
                        display: flex;
                        flex-direction: column;
                    }
                    .tm-calendar-side-dock-resizer {
                        width: 6px;
                        cursor: col-resize;
                        background: transparent;
                        position: relative;
                        flex: 0 0 6px;
                    }
                    .tm-calendar-side-dock-resizer::after {
                        content: '';
                        position: absolute;
                        top: 0;
                        bottom: 0;
                        left: 2px;
                        width: 1px;
                        background: var(--tm-border-color);
                        opacity: .65;
                    }
                    .tm-calendar-side-dock-resizer:hover::after {
                        background: var(--tm-primary-color);
                        opacity: 1;
                    }
                    .tm-calendar-dock-head {
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        gap: 8px;
                        padding: 8px 10px;
                        border-bottom: 1px solid var(--tm-border-color);
                    }
                    .tm-calendar-dock-title {
                        font-size: 13px;
                        font-weight: 600;
                    }
                    .tm-calendar-dock-nav {
                        display: inline-flex;
                        gap: 4px;
                    }
                    .tm-calendar-dock-date {
                        padding: 6px 10px;
                        font-size: 12px;
                        color: var(--tm-secondary-text);
                        border-bottom: 1px solid var(--tm-border-color);
                    }
                    .tm-calendar-dock-empty {
                        font-size: 12px;
                        color: var(--tm-secondary-text);
                    }
                    #tmCalendarSideDockTimeline {
                        flex: 1 1 auto;
                        min-height: 0;
                        overflow: hidden;
                    }
                    #tmCalendarSideDockTimeline .fc {
                        height: 100%;
                    }
                    #tmCalendarSideDockTimeline .fc-view-harness {
                        min-height: 0 !important;
                    }
                    #tmCalendarSideDockPanel {
                        height: 100%;
                        min-height: 0;
                        display: flex;
                        flex-direction: column;
                    }
                </style>
                
                ${bodyWithSideDockHtml}
            </div>
        `;
        
        try { if (state.viewMode === 'kanban') __tmBindKanbanPan(state.modal); } catch (e) {}
        __tmGetMountRoot().appendChild(state.modal);
        try {
            if (state.viewMode === 'calendar') {
                const el = state.modal.querySelector('#tmCalendarRoot');
                if (el) {
                    if (!SettingsStore.data.calendarEnabled) {
                        el.innerHTML = `<div style="padding:12px;color:var(--tm-secondary-text);">日历视图已关闭，可在设置 → 日历中开启。</div>`;
                    } else if (globalThis.__tmCalendar && typeof globalThis.__tmCalendar.mount === 'function') {
                        const ok = globalThis.__tmCalendar.mount(el, { settingsStore: SettingsStore });
                        if (!ok) {
                            el.innerHTML = `<div style="padding:12px;color:var(--tm-secondary-text);">日历初始化失败，请确认 FullCalendar 已加载。</div>`;
                        }
                    } else {
                        el.innerHTML = `<div style="padding:12px;color:var(--tm-secondary-text);">日历模块未加载。</div>`;
                    }
                }
            }
            if (state.viewMode === 'whiteboard') {
                __tmApplyWhiteboardTransform();
                __tmScheduleWhiteboardEdgeRedraw();
            }
            if (showCalendarSideDock) {
                __tmCalendarDockMount();
            } else if (globalThis.__tmCalendar && typeof globalThis.__tmCalendar.unmountSideDayTimeline === 'function') {
                try { globalThis.__tmCalendar.unmountSideDayTimeline(); } catch (e) {}
            }
        } catch (e) {}

        // 恢复滚动位置
        try {
            const isTimeline = state.viewMode === 'timeline';
            const isKanban = state.viewMode === 'kanban';
            const isWhiteboard = state.viewMode === 'whiteboard';
            const pickNum = (v, fallback = 0) => (typeof v === 'number' && Number.isFinite(v) ? v : fallback);
            const listTop = pickNum(state.viewScroll?.list?.top, 0);
            const listLeft = pickNum(state.viewScroll?.list?.left, 0);
            const timelineTop = pickNum(state.viewScroll?.timeline?.top, 0);
            const timelineLeft = pickNum(state.viewScroll?.timeline?.left, 0);
            const calendarTop = pickNum(state.viewScroll?.calendar?.top, 0);
            const calendarLeft = pickNum(state.viewScroll?.calendar?.left, 0);
            const kanbanLeft = pickNum(state.viewScroll?.kanban?.left, 0);
            const kanbanCols = (state.viewScroll?.kanban?.cols && typeof state.viewScroll.kanban.cols === 'object')
                ? state.viewScroll.kanban.cols
                : {};
            const wbSidebarTop = pickNum(state.viewScroll?.whiteboard?.sidebarTop, 0);
            const desiredTop = prevWasTimeline ? timelineTop : listTop;
            const desiredLeft = isTimeline ? timelineLeft : listLeft;
            
            if (isTimeline) {
                const leftBody = state.modal.querySelector('#tmTimelineLeftBody');
                const ganttBody = state.modal.querySelector('#tmGanttBody');
                const ganttHeader = state.modal.querySelector('#tmGanttHeader');
                
                if (leftBody) leftBody.scrollTop = desiredTop;
                if (ganttBody) {
                    ganttBody.scrollTop = desiredTop;
                    ganttBody.scrollLeft = desiredLeft;
                }
                
                // 渲染 Gantt
                const rowModel = Array.isArray(__tmTimelineRowModel) ? __tmTimelineRowModel : __tmBuildTaskRowModel();
                const view = globalThis.__TaskHorizonGanttView;
                if (view && typeof view.render === 'function' && ganttHeader && ganttBody) {
                    view.render({
                        headerEl: ganttHeader,
                        bodyEl: ganttBody,
                        rowModel,
                        getTaskById: (id) => state.flatTasks[String(id)],
                        viewState: state.ganttView,
                        onUpdateTaskDates: async (taskId, patch) => {
                            const id = String(taskId || '').trim();
                            if (!id) return;
                            const task = state.flatTasks[id];
                            if (!task) return;
                            const startDate = String(patch?.startDate || '').trim();
                            const completionTime = String(patch?.completionTime || '').trim();
                            const nextStart = startDate ? __tmNormalizeDateOnly(startDate) : '';
                            const nextEnd = completionTime ? __tmNormalizeDateOnly(completionTime) : '';
                            task.startDate = nextStart;
                            task.completionTime = nextEnd;
                            try {
                                await __tmPersistMetaAndAttrsAsync(id, { startDate: nextStart, completionTime: nextEnd });
                            } catch (e) {
                                hint(`❌ 更新失败: ${e.message}`, 'error');
                            }
                            __tmScheduleRender({ withFilters: true });
                        },
                        onUpdateTaskMeta: async (taskId, patch) => {
                            const id = String(taskId || '').trim();
                            if (!id || !patch || typeof patch !== 'object') return;
                            const task = state.flatTasks[id];
                            if (!task) return;
                            const hasMilestone = Object.prototype.hasOwnProperty.call(patch, 'milestone');
                            if (!hasMilestone) return;
                            const val = !!patch.milestone;
                            task.milestone = val;
                            try {
                                await __tmPersistMetaAndAttrsAsync(id, { milestone: val ? '1' : '' });
                            } catch (e) {
                                hint(`❌ 更新失败: ${e.message}`, 'error');
                            }
                            __tmScheduleRender({ withFilters: true });
                        },
                    });
                }
                
                const syncHeaderX = () => {
                    if (!ganttBody || !ganttHeader) return;
                    const inner = ganttHeader.querySelector('.tm-gantt-header-inner');
                    if (!inner) return;
                    inner.style.transform = `translateX(${-ganttBody.scrollLeft}px)`;
                };
                syncHeaderX();
                
                // 强制左侧对齐（如果需要）
                const forcedLeft = Number(state.ganttView?.__forceScrollLeft);
                if (Number.isFinite(forcedLeft)) {
                     if (ganttBody) ganttBody.scrollLeft = forcedLeft;
                     delete state.ganttView.__forceScrollLeft;
                }
                
                requestAnimationFrame(() => requestAnimationFrame(() => {
                    try { if (leftBody) leftBody.scrollTop = desiredTop; } catch (e) {}
                    try { if (ganttBody) ganttBody.scrollTop = desiredTop; } catch (e) {}
                    try { syncHeaderX(); } catch (e) {}
                    try { __tmRunFlipAnimation(state.modal); } catch (e) {}
                    
                    if (useSoftSwap) {
                         try { state.modal.style.opacity = '1'; } catch (e) {}
                         try { state.modal.style.pointerEvents = ''; } catch (e) {}
                         if (prevModalEl) {
                             try { prevModalEl.style.visibility = 'hidden'; } catch (e2) {}
                             setTimeout(() => { try { prevModalEl.remove(); } catch (e2) {} }, 140);
                         }
                    }
                }));

                const syncRowHeights = () => {
                    if (!leftBody || !ganttBody) return;
                    if (Date.now() - (Number(state.__tmFlipTs) || 0) < 320) return;
                    const leftRows = leftBody.querySelectorAll('tbody tr');
                    const rightRows = ganttBody.querySelectorAll('.tm-gantt-row');
                    const n = Math.min(leftRows.length, rightRows.length);
                    if (n <= 0) return;
                    for (let i = 0; i < n; i++) {
                        const rr = rightRows[i];
                        rr.style.height = '';
                        rr.style.minHeight = '';
                        rr.style.maxHeight = '';
                        const bar = rr.querySelector?.('.tm-gantt-bar');
                        if (bar) {
                            bar.style.top = '50%';
                            bar.style.transform = 'translateY(-50%)';
                        }
                    }
                };
                try {
                    requestAnimationFrame(() => requestAnimationFrame(() => {
                        syncRowHeights();
                        setTimeout(syncRowHeights, 60);
                        setTimeout(syncRowHeights, 260);
                        setTimeout(syncRowHeights, 420);
                    }));
                } catch (e) {}

                requestAnimationFrame(() => requestAnimationFrame(() => {
                    if (!Number.isFinite(Number(SettingsStore.data.timelineLeftWidth)) || Number(SettingsStore.data.timelineLeftWidth) <= 0) {
                        const leftTable = state.modal?.querySelector?.('#tmTimelineLeftTable');
                        const w = leftTable?.getBoundingClientRect?.().width;
                        if (Number.isFinite(w) && w > 0) {
                            SettingsStore.data.timelineLeftWidth = Math.max(360, Math.min(900, Math.round(w)));
                            try { SettingsStore.save(); } catch (e) {}
                        }
                    }
                }));

                if (leftBody && ganttBody) {
                    const onGroupClick = (ev) => {
                        const el = ev?.target instanceof Element ? ev.target.closest('.tm-gantt-row--group') : null;
                        if (!el) return;
                        const key = String(el.getAttribute('data-group-key') || '').trim();
                        if (!key) return;
                        tmToggleGroupCollapse(key, ev);
                    };
                    const onGanttWheel = (ev) => {
                        if (!ev?.shiftKey) return;
                        const canScrollX = (ganttBody.scrollWidth - ganttBody.clientWidth) > 2;
                        if (!canScrollX) return;
                        let delta = 0;
                        const dx = Number(ev.deltaX) || 0;
                        const dy = Number(ev.deltaY) || 0;
                        delta = Math.abs(dx) >= Math.abs(dy) ? dx : dy;
                        if (!Number.isFinite(delta) || delta === 0) return;
                        if (ev.deltaMode === 1) delta *= 16;
                        else if (ev.deltaMode === 2) delta *= ganttBody.clientWidth;
                        ganttBody.scrollLeft = ganttBody.scrollLeft + delta;
                        try { ev.preventDefault(); } catch (e) {}
                        try { ev.stopPropagation(); } catch (e) {}
                    };
                    let syncing = false;
                    const syncFromLeft = () => {
                        if (syncing) return;
                        syncing = true;
                        requestAnimationFrame(() => {
                            try { ganttBody.scrollTop = leftBody.scrollTop; } catch (e) {}
                            syncing = false;
                        });
                    };
                    const syncFromRight = () => {
                        if (syncing) return;
                        syncing = true;
                        requestAnimationFrame(() => {
                            try { leftBody.scrollTop = ganttBody.scrollTop; } catch (e) {}
                            syncing = false;
                        });
                    };
                    leftBody.addEventListener('scroll', syncFromLeft, { passive: true });
                    ganttBody.addEventListener('scroll', () => {
                        syncHeaderX();
                        syncFromRight();
                    }, { passive: true });
                    ganttBody.addEventListener('wheel', onGanttWheel, { passive: false });
                    if (ganttHeader) ganttHeader.addEventListener('wheel', onGanttWheel, { passive: false });
                    ganttBody.addEventListener('click', onGroupClick, true);
                } else if (ganttBody) {
                    ganttBody.addEventListener('scroll', syncHeaderX, { passive: true });
                    const onGanttWheel = (ev) => {
                        if (!ev?.shiftKey) return;
                        const canScrollX = (ganttBody.scrollWidth - ganttBody.clientWidth) > 2;
                        if (!canScrollX) return;
                        let delta = 0;
                        const dx = Number(ev.deltaX) || 0;
                        const dy = Number(ev.deltaY) || 0;
                        delta = Math.abs(dx) >= Math.abs(dy) ? dx : dy;
                        if (!Number.isFinite(delta) || delta === 0) return;
                        if (ev.deltaMode === 1) delta *= 16;
                        else if (ev.deltaMode === 2) delta *= ganttBody.clientWidth;
                        ganttBody.scrollLeft = ganttBody.scrollLeft + delta;
                        try { ev.preventDefault(); } catch (e) {}
                        try { ev.stopPropagation(); } catch (e) {}
                    };
                    ganttBody.addEventListener('wheel', onGanttWheel, { passive: false });
                    if (ganttHeader) ganttHeader.addEventListener('wheel', onGanttWheel, { passive: false });
                }
            } else {
                const isCalendar = state.viewMode === 'calendar';
                if (isCalendar) {
                    const root = state.modal.querySelector('#tmCalendarRoot');
                    const apply = () => {
                        try {
                            if (!root || !root.querySelectorAll) return;
                            const preferred = root.querySelector('.fc-timegrid-body .fc-scroller');
                            const list = Array.from(root.querySelectorAll('.fc-scroller'));
                            const scroller = (preferred && preferred.scrollHeight > preferred.clientHeight + 1)
                                ? preferred
                                : (list.find((el) => el && el.scrollHeight > el.clientHeight + 1) || preferred || list[0] || null);
                            if (!scroller) return;
                            scroller.scrollTop = calendarTop;
                            scroller.scrollLeft = calendarLeft;
                        } catch (e) {}
                    };
                    apply();
                    requestAnimationFrame(() => requestAnimationFrame(apply));
                    setTimeout(apply, 0);
                    requestAnimationFrame(() => requestAnimationFrame(() => {
                        try { __tmRunFlipAnimation(state.modal); } catch (e) {}
                        if (useSoftSwap) {
                            try { state.modal.style.opacity = '1'; } catch (e) {}
                            try { state.modal.style.pointerEvents = ''; } catch (e) {}
                            if (prevModalEl) {
                                try { prevModalEl.style.visibility = 'hidden'; } catch (e2) {}
                                setTimeout(() => { try { prevModalEl.remove(); } catch (e2) {} }, 140);
                            }
                        }
                    }));
                } else if (isKanban) {
                    const kbBody = state.modal.querySelector('.tm-body.tm-body--kanban');
                    const apply = () => {
                        try { if (kbBody) kbBody.scrollLeft = kanbanLeft; } catch (e) {}
                        try {
                            state.modal.querySelectorAll('.tm-kanban-col[data-status]').forEach((col) => {
                                const status = String(col?.getAttribute?.('data-status') || '').trim();
                                if (!status) return;
                                const colBody = col.querySelector('.tm-kanban-col-body');
                                if (!(colBody instanceof HTMLElement)) return;
                                const top = pickNum(kanbanCols[status], 0);
                                colBody.scrollTop = top;
                            });
                        } catch (e) {}
                    };
                    apply();
                    requestAnimationFrame(() => requestAnimationFrame(apply));
                    requestAnimationFrame(() => requestAnimationFrame(() => {
                        try { __tmRunFlipAnimation(state.modal); } catch (e) {}
                        if (useSoftSwap) {
                            try { state.modal.style.opacity = '1'; } catch (e) {}
                            try { state.modal.style.pointerEvents = ''; } catch (e) {}
                            if (prevModalEl) {
                                try { prevModalEl.style.visibility = 'hidden'; } catch (e2) {}
                                setTimeout(() => { try { prevModalEl.remove(); } catch (e2) {} }, 140);
                            }
                        }
                    }));
                } else if (isWhiteboard) {
                    const sidebar = state.modal.querySelector('.tm-whiteboard-sidebar');
                    const apply = () => {
                        try { if (sidebar) sidebar.scrollTop = wbSidebarTop; } catch (e) {}
                    };
                    apply();
                    requestAnimationFrame(() => requestAnimationFrame(apply));
                    requestAnimationFrame(() => requestAnimationFrame(() => {
                        try { __tmRunFlipAnimation(state.modal); } catch (e) {}
                        try { __tmScheduleWhiteboardEdgeRedraw(); } catch (e) {}
                        if (useSoftSwap) {
                            try { state.modal.style.opacity = '1'; } catch (e) {}
                            try { state.modal.style.pointerEvents = ''; } catch (e) {}
                            if (prevModalEl) {
                                try { prevModalEl.style.visibility = 'hidden'; } catch (e2) {}
                                setTimeout(() => { try { prevModalEl.remove(); } catch (e2) {} }, 140);
                            }
                        }
                    }));
                } else {
                    // 列表模式
                    const body = state.modal.querySelector('.tm-body');
                    if (body) {
                        body.scrollTop = desiredTop;
                        body.scrollLeft = desiredLeft;
                    }
                    
                    requestAnimationFrame(() => requestAnimationFrame(() => {
                         try { if (body) body.scrollTop = desiredTop; } catch (e) {}
                         try { __tmRunFlipAnimation(state.modal); } catch (e) {}
                         if (state.viewMode === 'whiteboard') {
                             try { __tmScheduleWhiteboardEdgeRedraw(); } catch (e) {}
                         }
                         
                         if (useSoftSwap) {
                             try { state.modal.style.opacity = '1'; } catch (e) {}
                             try { state.modal.style.pointerEvents = ''; } catch (e) {}
                             if (prevModalEl) {
                                 try { prevModalEl.style.visibility = 'hidden'; } catch (e2) {}
                                 setTimeout(() => { try { prevModalEl.remove(); } catch (e2) {} }, 140);
                             }
                         }
                    }));
                }
            }
        } catch (e) {}

        if (isViewSwitchAnim) {
            try { state.uiAnimKind = ''; } catch (e) {}
        }
    }

    // 新增的规则应用函数
    window.applyFilterRule = async function(ruleId) {
        if (ruleId) {
            state.currentRule = ruleId;
            SettingsStore.data.currentRule = ruleId;
            await SettingsStore.save();
        } else {
            state.currentRule = null;
            SettingsStore.data.currentRule = null;
            await SettingsStore.save();
        }
        const prevDoneOnly = !!state.__tmQueryDoneOnly;
        const nextRule = ruleId ? state.filterRules.find(r => r.id === ruleId) : null;
        const nextDoneOnly = !!(nextRule && nextRule.conditions && nextRule.conditions.some(c => c && c.field === 'done' && c.operator === '=' && (c.value === true || String(c.value) === 'true' || c.value === '') && String(c.value) !== '__all__'));
        state.__tmQueryDoneOnly = nextDoneOnly;
        if (prevDoneOnly !== nextDoneOnly) {
            await loadSelectedDocuments();
            if (ruleId) {
                const rule = state.filterRules.find(r => r.id === ruleId);
                if (rule) {
                    hint(`✅ 已应用规则: ${rule.name}`, 'success');
                }
            }
            return;
        }
        applyFilters();
        render();

        if (ruleId) {
            const rule = state.filterRules.find(r => r.id === ruleId);
            if (rule) {
                hint(`✅ 已应用规则: ${rule.name}`, 'success');
            }
        }
    };

    window.clearFilterRule = async function() {
        const prevDoneOnly = !!state.__tmQueryDoneOnly;
        state.currentRule = null;
        SettingsStore.data.currentRule = null;
        await SettingsStore.save();
        state.__tmQueryDoneOnly = false;
        if (prevDoneOnly) {
            await loadSelectedDocuments();
            hint('✅ 已清除筛选规则', 'success');
            return;
        }
        applyFilters();
        render();
        hint('✅ 已清除筛选规则', 'success');
    };

    // 原有的其他函数保持不变...
    window.tmRefreshCalendarInPlace = async function(options = {}) {
        const opt = (options && typeof options === 'object') ? options : {};
        const silent = opt.silent === true;
        if (state.isRefreshing) return;
        state.isRefreshing = true;
        if (!silent) hint('🔄 正在刷新...', 'info');
        try {
            try { window.__tmCalendarAllTasksCache = null; } catch (e) {}
            await loadSelectedDocuments({ skipRender: true });
            let removedCount = 0;
            try {
                removedCount = Number(__tmSyncWhiteboardFrozenTasksWithLiveTasks()) || 0;
            } catch (e) {}
            if (String(state.viewMode || '').trim() === 'calendar' && globalThis.__tmCalendar && typeof globalThis.__tmCalendar.refreshInPlace === 'function') {
                try { globalThis.__tmCalendar.refreshInPlace({ hard: true }); } catch (e) {}
            } else {
                try { render(); } catch (e) {}
            }
            if (!silent) hint(removedCount > 0 ? `✅ 刷新完成，已清理冻结任务 ${removedCount} 项` : '✅ 刷新完成', 'success');
        } catch (e) {
            if (!silent) hint(`❌ 刷新失败: ${e.message}`, 'error');
        } finally {
            state.isRefreshing = false;
        }
    };

    window.tmRefresh = async function() {
        if (state.isRefreshing) return;
        if (String(state.viewMode || '').trim() === 'calendar') {
            return window.tmRefreshCalendarInPlace({ silent: false });
        }
        state.isRefreshing = true;
        hint('🔄 正在刷新...', 'info');
        try {
            await loadSelectedDocuments();
            let removedCount = 0;
            try {
                removedCount = Number(__tmSyncWhiteboardFrozenTasksWithLiveTasks()) || 0;
            } catch (e) {}
            if (removedCount > 0) {
                try { applyFilters(); } catch (e) {}
                try { if (state.modal) render(); } catch (e) {}
            }
            hint(removedCount > 0 ? `✅ 刷新完成，已清理冻结任务 ${removedCount} 项` : '✅ 刷新完成', 'success');
        } catch (e) {
            hint(`❌ 刷新失败: ${e.message}`, 'error');
        } finally {
            state.isRefreshing = false;
        }
    };

    window.tmToggleTimelineMode = function() {
        const next = state.viewMode === 'timeline' ? 'list' : 'timeline';
        state.viewMode = next;
        state.uiAnimKind = '';
        state.uiAnimTs = 0;
        try { applyFilters(); } catch (e) {}
        render();
    };

    window.tmToggleKanbanMode = function() {
        const next = state.viewMode === 'kanban' ? 'list' : 'kanban';
        state.viewMode = next;
        state.uiAnimKind = '';
        state.uiAnimTs = 0;
        try { __tmHideMobileMenu(); } catch (e) {}
        try { applyFilters(); } catch (e) {}
        render();
    };

    window.tmToggleCalendarMode = function() {
        const next = state.viewMode === 'calendar' ? 'list' : 'calendar';
        state.viewMode = next;
        state.uiAnimKind = '';
        state.uiAnimTs = 0;
        try { __tmHideMobileMenu(); } catch (e) {}
        try { applyFilters(); } catch (e) {}
        render();
    };

    window.tmToggleWhiteboardMode = function() {
        const next = state.viewMode === 'whiteboard' ? 'list' : 'whiteboard';
        state.viewMode = next;
        state.uiAnimKind = '';
        state.uiAnimTs = 0;
        try { __tmHideMobileMenu(); } catch (e) {}
        try { applyFilters(); } catch (e) {}
        render();
    };

    window.tmCalendarToggleSidebar = function() {
        try {
            if (state.viewMode !== 'calendar') return;
            if (!globalThis.__tmCalendar || typeof globalThis.__tmCalendar.toggleSidebar !== 'function') return;
            globalThis.__tmCalendar.toggleSidebar(undefined, 'calendar');
        } catch (e) {}
    };

    function __tmShouldShowCalendarSideDock() {
        const mode = String(state.viewMode || '').trim();
        if (!SettingsStore.data.calendarSideDockEnabled) return false;
        return mode === 'list' || mode === 'timeline' || mode === 'kanban' || mode === 'whiteboard';
    }

    function __tmCalendarDockGetDateKey() {
        const raw = String(state.calendarDockDate || '').trim();
        if (raw) return __tmNormalizeDateOnly(raw) || raw;
        const now = new Date();
        const pad = (n) => String(n).padStart(2, '0');
        const key = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}`;
        state.calendarDockDate = key;
        return key;
    }

    function __tmCalendarDockLabel(dateKey) {
        const ts = __tmParseTimeToTs(String(dateKey || '').trim());
        if (!ts) return String(dateKey || '');
        const d = new Date(ts);
        const week = ['日', '一', '二', '三', '四', '五', '六'];
        return `${d.getMonth() + 1}月${d.getDate()}日 周${week[d.getDay()]}`;
    }

    function __tmCalendarDockBuildPanelHtml() {
        const dateKey = __tmCalendarDockGetDateKey();
        return `
            <div class="tm-calendar-dock-head">
                <div class="tm-calendar-dock-title">日历日视图</div>
                <div class="tm-calendar-dock-nav">
                    <button class="tm-btn tm-btn-info" onclick="tmCalendarDockShiftDay(-1)" style="padding:2px 8px;">◀</button>
                    <button class="tm-btn tm-btn-info" onclick="tmCalendarDockToday()" style="padding:2px 8px;">今天</button>
                    <button class="tm-btn tm-btn-info" onclick="tmCalendarDockShiftDay(1)" style="padding:2px 8px;">▶</button>
                </div>
            </div>
            <div class="tm-calendar-dock-date">${esc(__tmCalendarDockLabel(dateKey))}</div>
            <div id="tmCalendarSideDockTimeline" style="flex:1 1 auto;min-height:0;"></div>
        `;
    }

    function __tmCalendarDockMount() {
        const root = state.modal?.querySelector?.('#tmCalendarSideDockPanel');
        if (!(root instanceof HTMLElement)) return;
        root.innerHTML = __tmCalendarDockBuildPanelHtml();
        const timelineRoot = root.querySelector('#tmCalendarSideDockTimeline');
        if (!(timelineRoot instanceof HTMLElement)) return;
        if (!globalThis.__tmCalendar || typeof globalThis.__tmCalendar.mountSideDayTimeline !== 'function') {
            timelineRoot.innerHTML = `<div style="padding:12px;color:var(--tm-secondary-text);">日历模块未加载。</div>`;
            return;
        }
        const ok = globalThis.__tmCalendar.mountSideDayTimeline(timelineRoot, {
            settingsStore: SettingsStore,
            date: __tmCalendarDockGetDateKey(),
            resolveTask: (taskId) => state.flatTasks?.[String(taskId || '').trim()] || null,
            dragHost: state.modal,
        });
        if (!ok) {
            timelineRoot.innerHTML = `<div style="padding:12px;color:var(--tm-secondary-text);">日历初始化失败。</div>`;
        }
    }

    window.tmCalendarDockShiftDay = function(delta) {
        const d = Number(delta) || 0;
        if (globalThis.__tmCalendar && typeof globalThis.__tmCalendar.shiftSideDay === 'function') {
            const ok = globalThis.__tmCalendar.shiftSideDay(d);
            if (ok && typeof globalThis.__tmCalendar.getSideDayDate === 'function') {
                state.calendarDockDate = String(globalThis.__tmCalendar.getSideDayDate() || '').trim() || __tmCalendarDockGetDateKey();
            }
        } else {
            const baseTs = __tmParseTimeToTs(__tmCalendarDockGetDateKey());
            const base = baseTs ? new Date(baseTs) : new Date();
            base.setDate(base.getDate() + d);
            const pad = (n) => String(n).padStart(2, '0');
            state.calendarDockDate = `${base.getFullYear()}-${pad(base.getMonth() + 1)}-${pad(base.getDate())}`;
        }
        const labelEl = state.modal?.querySelector?.('.tm-calendar-dock-date');
        if (labelEl) labelEl.textContent = __tmCalendarDockLabel(__tmCalendarDockGetDateKey());
    };

    window.tmCalendarDockToday = function() {
        const now = new Date();
        const pad = (n) => String(n).padStart(2, '0');
        state.calendarDockDate = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}`;
        if (globalThis.__tmCalendar && typeof globalThis.__tmCalendar.setSideDayDate === 'function') {
            globalThis.__tmCalendar.setSideDayDate(state.calendarDockDate);
        }
        const labelEl = state.modal?.querySelector?.('.tm-calendar-dock-date');
        if (labelEl) labelEl.textContent = __tmCalendarDockLabel(state.calendarDockDate);
    };

    window.tmStartCalendarSideDockResize = function(ev) {
        try { ev?.preventDefault?.(); } catch (e) {}
        const aside = state.modal?.querySelector?.('.tm-calendar-side-dock');
        if (!(aside instanceof HTMLElement)) return;
        const startX = Number(ev?.clientX) || 0;
        const startW = Math.max(260, Math.min(760, Math.round(aside.getBoundingClientRect().width || Number(SettingsStore.data.calendarSideDockWidth) || 340)));
        const onMove = (e2) => {
            const x = Number(e2?.clientX) || 0;
            const delta = startX - x;
            const nextW = Math.max(260, Math.min(760, Math.round(startW + delta)));
            aside.style.width = `${nextW}px`;
            aside.style.minWidth = `${nextW}px`;
            SettingsStore.data.calendarSideDockWidth = nextW;
            try { globalThis.__tmCalendar?.refreshInPlace?.({ hard: false }); } catch (e3) {}
        };
        const onUp = async () => {
            try { document.removeEventListener('mousemove', onMove, true); } catch (e2) {}
            try { document.removeEventListener('mouseup', onUp, true); } catch (e2) {}
            try { await SettingsStore.save(); } catch (e2) {}
        };
        try { document.addEventListener('mousemove', onMove, true); } catch (e2) {}
        try { document.addEventListener('mouseup', onUp, true); } catch (e2) {}
    };

    window.tmToggleCalendarSideDock = async function(enabled) {
        const next = (typeof enabled === 'boolean') ? enabled : !SettingsStore.data.calendarSideDockEnabled;
        SettingsStore.data.calendarSideDockEnabled = !!next;
        try { await SettingsStore.save(); } catch (e) {}
        render();
    };

    window.tmSwitchViewMode = function(mode) {
        const allow = new Set(['list', 'timeline', 'kanban', 'calendar', 'whiteboard']);
        const next = allow.has(String(mode || '').trim()) ? String(mode || '').trim() : 'list';
        if (state.viewMode === next) return;
        state.viewMode = next;
        state.uiAnimKind = '';
        state.uiAnimTs = 0;
        try { __tmHideMobileMenu(); } catch (e) {}
        try { applyFilters(); } catch (e) {}
        render();
        if (next === 'whiteboard') {
            try {
                requestAnimationFrame(() => {
                    try { window.tmWhiteboardResetView?.(); } catch (e) {}
                });
            } catch (e) {}
        }
    };

    function __tmScheduleWhiteboardEdgeRedraw() {
        if (state.viewMode !== 'whiteboard') return;
        try {
            const id0 = Number(state.whiteboardEdgeRafId) || 0;
            if (id0) cancelAnimationFrame(id0);
        } catch (e) {}
        try {
            state.whiteboardEdgeRafId = requestAnimationFrame(() => {
                state.whiteboardEdgeRafId = 0;
                __tmNormalizeWhiteboardAllViewFrames();
                __tmRenderWhiteboardEdges();
                try {
                    requestAnimationFrame(() => {
                        __tmNormalizeWhiteboardAllViewFrames();
                        __tmRenderWhiteboardEdges();
                    });
                } catch (e) {}
            });
        } catch (e) {
            __tmNormalizeWhiteboardAllViewFrames();
            __tmRenderWhiteboardEdges();
        }
    }

    function __tmScheduleWhiteboardViewSave() {
        try { if (__tmWhiteboardViewSaveTimer) clearTimeout(__tmWhiteboardViewSaveTimer); } catch (e) {}
        __tmWhiteboardViewSaveTimer = setTimeout(() => {
            __tmWhiteboardViewSaveTimer = null;
            try { SettingsStore.save(); } catch (e) {}
        }, 180);
    }

    function __tmApplyWhiteboardTransform() {
        if (state.viewMode !== 'whiteboard') return;
        const world = state.modal?.querySelector?.('#tmWhiteboardWorld');
        if (!(world instanceof HTMLElement)) return;
        const view = __tmGetWhiteboardView();
        world.style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.zoom})`;
        __tmScheduleWhiteboardEdgeRedraw();
    }

    function __tmNormalizeWhiteboardAllViewFrames() {
        if (state.viewMode !== 'whiteboard') return;
        if (state.activeDocId && state.activeDocId !== 'all') return;
        const body = state.modal?.querySelector?.('#tmWhiteboardBody');
        if (!(body instanceof Element)) return;
        const docBodies = body.querySelectorAll('.tm-whiteboard-doc-body[data-doc-id]');
        docBodies.forEach((docBody) => {
            if (!(docBody instanceof HTMLElement)) return;
            const styledHeight = Number.parseFloat(docBody.style.height) || 0;
            const styledMinHeight = Number.parseFloat(docBody.style.minHeight) || 0;
            const baseHeight = Math.max(220, styledHeight, styledMinHeight, docBody.clientHeight, 0);
            let maxBottom = 0;
            try {
                docBody.querySelectorAll('.tm-whiteboard-node,.tm-whiteboard-note').forEach((el) => {
                    if (!(el instanceof HTMLElement)) return;
                    const top = Number(el.offsetTop);
                    const h = Number(el.offsetHeight);
                    if (!Number.isFinite(top) || !Number.isFinite(h) || h <= 0) return;
                    const bottom = top + h;
                    if (Number.isFinite(bottom)) maxBottom = Math.max(maxBottom, bottom);
                });
            } catch (e) {}
            const targetHeight = Math.max(baseHeight, Math.ceil(maxBottom + 28));
            const currentHeight = Math.max(
                Number.parseFloat(docBody.style.height) || 0,
                docBody.clientHeight || 0,
                docBody.scrollHeight || 0,
            );
            if (targetHeight > currentHeight + 1) {
                docBody.style.height = `${targetHeight}px`;
                docBody.style.minHeight = `${targetHeight}px`;
            }
        });
    }

    function __tmApplyWhiteboardCardSelectionDom(taskId) {
        if (state.viewMode !== 'whiteboard') return;
        const body = state.modal?.querySelector?.('#tmWhiteboardBody');
        if (!(body instanceof Element)) return;
        const id = String(taskId || '').trim();
        try {
            body.querySelectorAll('.tm-whiteboard-node.tm-whiteboard-card--selected').forEach((el) => {
                try { el.classList.remove('tm-whiteboard-card--selected'); } catch (e) {}
            });
        } catch (e) {}
        try {
            body.querySelectorAll('.tm-whiteboard-card-tools[data-tm-wb-dyn="1"]').forEach((el) => {
                try { el.remove(); } catch (e) {}
            });
        } catch (e) {}
        if (!id) return;
        try {
            const card = body.querySelector(`.tm-whiteboard-node[data-task-id="${CSS.escape(id)}"]`);
            if (card instanceof HTMLElement) {
                card.classList.add('tm-whiteboard-card--selected');
                const allView = !(state.activeDocId && state.activeDocId !== 'all');
                if (!allView) {
                    const tid = String(card.getAttribute('data-task-id') || '').trim();
                    const did = String(card.getAttribute('data-doc-id') || '').trim();
                    if (tid && did) {
                        const isGhost = !state.flatTasks?.[tid] && !!__tmGetWhiteboardCardSnapshot(tid);
                        const deleteTitle = isGhost ? '移除快照卡片并彻底移除记录（不进入侧边栏）' : '移除卡片并回到侧栏';
                        const parentId = __tmResolveWhiteboardTaskParentId(tid);
                        const detachedOrDetachedLike = !!parentId && (
                            __tmIsWhiteboardChildDetached(tid)
                            || card.classList.contains('tm-whiteboard-node--root')
                        );
                        const canMoveBack = detachedOrDetachedLike;
                        const tools = document.createElement('div');
                        tools.className = 'tm-whiteboard-card-tools';
                        tools.setAttribute('data-tm-wb-dyn', '1');
                        tools.innerHTML = `
                            <button class="tm-btn tm-btn-danger" data-tm-wb-action="delete" style="padding:2px 8px;font-size:12px;" title="${esc(deleteTitle)}">移除</button>
                            ${canMoveBack ? `<button class="tm-btn tm-btn-info" data-tm-wb-action="moveBack" style="padding:2px 8px;font-size:12px;" title="移回父任务">移回父任务</button>` : ''}
                        `;
                        const deleteBtn = tools.querySelector('button[data-tm-wb-action="delete"]');
                        if (deleteBtn instanceof HTMLButtonElement) {
                            deleteBtn.addEventListener('click', (ev) => {
                                try { ev.stopPropagation(); } catch (e) {}
                                try { window.tmWhiteboardDeleteCard?.(tid, did, ev); } catch (e) {}
                            });
                        }
                        const moveBackBtn = tools.querySelector('button[data-tm-wb-action="moveBack"]');
                        if (moveBackBtn instanceof HTMLButtonElement) {
                            moveBackBtn.addEventListener('click', (ev) => {
                                try { ev.stopPropagation(); } catch (e) {}
                                try { window.tmWhiteboardMoveBackToParent?.(tid, did, ev); } catch (e) {}
                            });
                        }
                        try { card.prepend(tools); } catch (e) {}
                    }
                }
            }
        } catch (e) {}
    }

    function __tmResolveWhiteboardPointerInfo(ev, docIdHint = '') {
        const hint = String(docIdHint || '').trim();
        let cx = Number(ev?.clientX);
        let cy = Number(ev?.clientY);
        if (!Number.isFinite(cx) || !Number.isFinite(cy) || (Math.abs(cx) < 1 && Math.abs(cy) < 1)) {
            return null;
        }
        let docBody = null;
        try {
            const hit = document.elementFromPoint(cx, cy)?.closest?.('.tm-whiteboard-doc-body[data-doc-id]');
            if (hit instanceof HTMLElement) docBody = hit;
        } catch (e) {}
        if (!(docBody instanceof HTMLElement) && hint) {
            try {
                const fallback = state.modal?.querySelector?.(`.tm-whiteboard-doc-body[data-doc-id="${CSS.escape(hint)}"]`);
                if (fallback instanceof HTMLElement) docBody = fallback;
            } catch (e) {}
        }
        if (!(docBody instanceof HTMLElement)) return null;
        const docId = String(docBody.getAttribute('data-doc-id') || '').trim();
        if (!docId) return null;
        const zoom = Math.max(0.01, Number(__tmGetWhiteboardView()?.zoom) || 1);
        const docRect = docBody.getBoundingClientRect();
        const localX = (cx - docRect.left) / zoom;
        const localY = (cy - docRect.top) / zoom;
        if (!Number.isFinite(localX) || !Number.isFinite(localY)) return null;
        return { docId, clientX: cx, clientY: cy, localX, localY, at: Date.now() };
    }

    function __tmTrackWhiteboardPointerFromClient(clientX, clientY, docIdHint = '') {
        const cx = Number(clientX);
        const cy = Number(clientY);
        if (!Number.isFinite(cx) || !Number.isFinite(cy) || (Math.abs(cx) < 1 && Math.abs(cy) < 1)) return null;
        const hint = String(docIdHint || '').trim();
        let docBody = null;
        try {
            const hit = document.elementFromPoint(cx, cy)?.closest?.('.tm-whiteboard-doc-body[data-doc-id]');
            if (hit instanceof HTMLElement) docBody = hit;
        } catch (e) {}
        if (!(docBody instanceof HTMLElement) && hint) {
            try {
                const fallback = state.modal?.querySelector?.(`.tm-whiteboard-doc-body[data-doc-id="${CSS.escape(hint)}"]`);
                if (fallback instanceof HTMLElement) docBody = fallback;
            } catch (e) {}
        }
        if (!(docBody instanceof HTMLElement)) return null;
        const docId = String(docBody.getAttribute('data-doc-id') || '').trim();
        if (!docId) return null;
        const zoom = Math.max(0.01, Number(__tmGetWhiteboardView()?.zoom) || 1);
        const rect = docBody.getBoundingClientRect();
        const localX = (cx - rect.left) / zoom;
        const localY = (cy - rect.top) / zoom;
        if (!Number.isFinite(localX) || !Number.isFinite(localY)) return null;
        const at = Date.now();
        state.whiteboardLastBoardPointer = { clientX: cx, clientY: cy, docId, at };
        state.whiteboardLastBoardLocal = { docId, x: localX, y: localY, at };
        return state.whiteboardLastBoardLocal;
    }

    function __tmStartWhiteboardPoolGlobalTracking(docIdHint = '') {
        __tmStopWhiteboardPoolGlobalTracking();
        const hint = String(docIdHint || '').trim();
        const onDocDragOver = (ev) => {
            __tmTrackWhiteboardPointerFromClient(ev?.clientX, ev?.clientY, hint);
        };
        const onDocDrop = () => {
            __tmStopWhiteboardPoolGlobalTracking();
        };
        const onDocDragEnd = () => {
            __tmStopWhiteboardPoolGlobalTracking();
        };
        state.whiteboardPoolGlobalTracker = { onDocDragOver, onDocDrop, onDocDragEnd };
        try { document.addEventListener('dragover', onDocDragOver, true); } catch (e) {}
        try { document.addEventListener('drop', onDocDrop, true); } catch (e) {}
        try { document.addEventListener('dragend', onDocDragEnd, true); } catch (e) {}
    }

    function __tmStopWhiteboardPoolGlobalTracking() {
        const t = state.whiteboardPoolGlobalTracker;
        if (!t || typeof t !== 'object') return;
        try { document.removeEventListener('dragover', t.onDocDragOver, true); } catch (e) {}
        try { document.removeEventListener('drop', t.onDocDrop, true); } catch (e) {}
        try { document.removeEventListener('dragend', t.onDocDragEnd, true); } catch (e) {}
        state.whiteboardPoolGlobalTracker = null;
    }

    window.tmWhiteboardZoomIn = function() {
        const v = __tmGetWhiteboardView();
        __tmSetWhiteboardView({ zoom: Math.min(2.5, v.zoom * 1.1) }, { persist: false });
        __tmApplyWhiteboardTransform();
        __tmScheduleWhiteboardViewSave();
    };

    window.tmWhiteboardZoomOut = function() {
        const v = __tmGetWhiteboardView();
        __tmSetWhiteboardView({ zoom: Math.max(0.35, v.zoom / 1.1) }, { persist: false });
        __tmApplyWhiteboardTransform();
        __tmScheduleWhiteboardViewSave();
    };

    function __tmFitWhiteboardToVisibleCards() {
        const viewport = state.modal?.querySelector?.('#tmWhiteboardViewport');
        const body = state.modal?.querySelector?.('#tmWhiteboardBody');
        if (!(viewport instanceof HTMLElement) || !(body instanceof HTMLElement)) return false;
        const nodes = Array.from(body.querySelectorAll('.tm-whiteboard-card[data-task-id],.tm-whiteboard-note'));
        if (!nodes.length) return false;
        const view = __tmGetWhiteboardView();
        const vr = viewport.getBoundingClientRect();
        const toWorldRect = (el) => {
            if (!(el instanceof HTMLElement)) return null;
            const r = el.getBoundingClientRect();
            if (!Number.isFinite(r.left) || !Number.isFinite(r.top) || r.width <= 0 || r.height <= 0) return null;
            const x = (r.left - vr.left - view.x) / view.zoom;
            const y = (r.top - vr.top - view.y) / view.zoom;
            const w = r.width / view.zoom;
            const h = r.height / view.zoom;
            if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(w) || !Number.isFinite(h)) return null;
            return { x, y, w, h };
        };
        const rects = nodes.map(toWorldRect).filter(Boolean);
        if (!rects.length) return false;
        let minX = Number.POSITIVE_INFINITY;
        let minY = Number.POSITIVE_INFINITY;
        let maxX = Number.NEGATIVE_INFINITY;
        let maxY = Number.NEGATIVE_INFINITY;
        rects.forEach((r) => {
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.w);
            maxY = Math.max(maxY, r.y + r.h);
        });
        if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) return false;
        const pad = 48;
        const w = Math.max(1, maxX - minX);
        const h = Math.max(1, maxY - minY);
        const fitZoomW = (vr.width - pad * 2) / w;
        const fitZoomH = (vr.height - pad * 2) / h;
        const zoom = Math.max(0.35, Math.min(2.5, Math.min(fitZoomW, fitZoomH)));
        const cx = minX + w / 2;
        const cy = minY + h / 2;
        const x = (vr.width / 2) - (cx * zoom);
        const y = (vr.height / 2) - (cy * zoom);
        __tmSetWhiteboardView({ x, y, zoom }, { persist: false });
        __tmApplyWhiteboardTransform();
        __tmScheduleWhiteboardViewSave();
        return true;
    }

    window.tmWhiteboardResetView = function() {
        if (__tmFitWhiteboardToVisibleCards()) return;
        __tmSetWhiteboardView({ x: 64, y: 40, zoom: 1 }, { persist: false });
        __tmApplyWhiteboardTransform();
        __tmScheduleWhiteboardViewSave();
    };

    function __tmRemoveWhiteboardMultiTools() {
        const viewport = state.modal?.querySelector?.('#tmWhiteboardViewport');
        if (!(viewport instanceof HTMLElement)) return;
        try { viewport.querySelectorAll('#tmWhiteboardMultiTools').forEach((el) => el.remove()); } catch (e) {}
    }

    function __tmApplyWhiteboardMultiSelectionDom() {
        const body = state.modal?.querySelector?.('#tmWhiteboardBody');
        if (!(body instanceof Element)) return;
        const taskSet = new Set((Array.isArray(state.whiteboardMultiSelectedTaskIds) ? state.whiteboardMultiSelectedTaskIds : []).map((x) => String(x || '').trim()).filter(Boolean));
        const noteSet = new Set((Array.isArray(state.whiteboardMultiSelectedNoteIds) ? state.whiteboardMultiSelectedNoteIds : []).map((x) => String(x || '').trim()).filter(Boolean));
        const linkSet = new Set((Array.isArray(state.whiteboardMultiSelectedLinkKeys) ? state.whiteboardMultiSelectedLinkKeys : []).map((x) => String(x || '').trim()).filter(Boolean));
        try {
            body.querySelectorAll('.tm-whiteboard-multi-selected').forEach((el) => {
                try { el.classList.remove('tm-whiteboard-multi-selected'); } catch (e) {}
            });
        } catch (e) {}
        taskSet.forEach((id) => {
            try {
            const el = body.querySelector(`.tm-whiteboard-node[data-task-id="${CSS.escape(id)}"]`);
            if (el instanceof HTMLElement) el.classList.add('tm-whiteboard-multi-selected');
            } catch (e) {}
        });
        noteSet.forEach((id) => {
            try {
                const el = body.querySelector(`.tm-whiteboard-note[data-note-id="${CSS.escape(id)}"]`);
                if (el instanceof HTMLElement) el.classList.add('tm-whiteboard-multi-selected');
            } catch (e) {}
        });
        linkSet.forEach((key) => {
            const k = String(key || '').trim();
            if (!k) return;
            const idx = k.indexOf('::');
            if (idx <= 0) return;
            const did = k.slice(0, idx);
            const lid = k.slice(idx + 2);
            if (!did || !lid) return;
            try {
                const el = body.querySelector(`.tm-whiteboard-edge.tm-whiteboard-edge--manual[data-link-id="${CSS.escape(lid)}"][data-doc-id="${CSS.escape(did)}"]`);
                if (el instanceof Element) el.classList.add('tm-whiteboard-multi-selected');
            } catch (e) {}
        });
    }

    function __tmComputeWhiteboardMultiSelectionRect() {
        const viewport = state.modal?.querySelector?.('#tmWhiteboardViewport');
        const body = state.modal?.querySelector?.('#tmWhiteboardBody');
        if (!(viewport instanceof HTMLElement) || !(body instanceof Element)) return null;
        const vr = viewport.getBoundingClientRect();
        const idsTask = Array.isArray(state.whiteboardMultiSelectedTaskIds) ? state.whiteboardMultiSelectedTaskIds : [];
        const idsNote = Array.isArray(state.whiteboardMultiSelectedNoteIds) ? state.whiteboardMultiSelectedNoteIds : [];
        const idsLink = Array.isArray(state.whiteboardMultiSelectedLinkKeys) ? state.whiteboardMultiSelectedLinkKeys : [];
        const targets = [];
        idsTask.forEach((id) => {
            const tid = String(id || '').trim();
            if (!tid) return;
            try {
                const el = body.querySelector(`.tm-whiteboard-node[data-task-id="${CSS.escape(tid)}"]`);
                if (el instanceof HTMLElement) targets.push(el);
            } catch (e) {}
        });
        idsNote.forEach((id) => {
            const nid = String(id || '').trim();
            if (!nid) return;
            try {
                const el = body.querySelector(`.tm-whiteboard-note[data-note-id="${CSS.escape(nid)}"]`);
                if (el instanceof HTMLElement) targets.push(el);
            } catch (e) {}
        });
        idsLink.forEach((key) => {
            const k = String(key || '').trim();
            if (!k) return;
            const idx = k.indexOf('::');
            if (idx <= 0) return;
            const did = k.slice(0, idx);
            const lid = k.slice(idx + 2);
            if (!did || !lid) return;
            try {
                const el = body.querySelector(`.tm-whiteboard-edge.tm-whiteboard-edge--manual[data-link-id="${CSS.escape(lid)}"][data-doc-id="${CSS.escape(did)}"]`);
                if (el instanceof Element) targets.push(el);
            } catch (e) {}
        });
        if (!targets.length) return null;
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        targets.forEach((el) => {
            try {
                const r = el.getBoundingClientRect();
                minX = Math.min(minX, r.left - vr.left);
                minY = Math.min(minY, r.top - vr.top);
                maxX = Math.max(maxX, r.right - vr.left);
                maxY = Math.max(maxY, r.bottom - vr.top);
            } catch (e) {}
        });
        if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) return null;
        return { x: minX, y: minY, w: Math.max(0, maxX - minX), h: Math.max(0, maxY - minY) };
    }

    function __tmClearWhiteboardMultiSelection() {
        state.whiteboardMultiSelectedTaskIds = [];
        state.whiteboardMultiSelectedNoteIds = [];
        state.whiteboardMultiSelectedLinkKeys = [];
        __tmApplyWhiteboardMultiSelectionDom();
        __tmRemoveWhiteboardMultiTools();
    }

    function __tmRenderWhiteboardMultiTools(rect) {
        const viewport = state.modal?.querySelector?.('#tmWhiteboardViewport');
        if (!(viewport instanceof HTMLElement)) return;
        __tmRemoveWhiteboardMultiTools();
        const taskCount = Array.isArray(state.whiteboardMultiSelectedTaskIds) ? state.whiteboardMultiSelectedTaskIds.length : 0;
        const noteCount = Array.isArray(state.whiteboardMultiSelectedNoteIds) ? state.whiteboardMultiSelectedNoteIds.length : 0;
        const linkCount = Array.isArray(state.whiteboardMultiSelectedLinkKeys) ? state.whiteboardMultiSelectedLinkKeys.length : 0;
        const total = taskCount + noteCount + linkCount;
        if (total <= 0) return;
        const fallbackRect = __tmComputeWhiteboardMultiSelectionRect();
        const rr = (rect && Number.isFinite(Number(rect.x)) && Number.isFinite(Number(rect.y)))
            ? rect
            : (fallbackRect || { x: 24, y: 40, w: 120, h: 40 });
        const x = Number(rr?.x);
        const y = Number(rr?.y);
        const w = Number(rr?.w);
        const top = Number.isFinite(y) ? Math.max(12, y - 8) : 20;
        const left = Number.isFinite(x) && Number.isFinite(w) ? (x + w / 2) : 120;
        const tools = document.createElement('div');
        tools.id = 'tmWhiteboardMultiTools';
        tools.className = 'tm-whiteboard-multi-tools';
        tools.style.left = `${left}px`;
        tools.style.top = `${top}px`;
        tools.innerHTML = `
            <button class="tm-btn tm-btn-info" style="padding:2px 8px;font-size:12px;" title="按行自动连线">自动连线</button>
            <button class="tm-btn tm-btn-danger" style="padding:2px 8px;font-size:12px;" title="移除框选对象">移除(${total})</button>
        `;
        const connectBtn = tools.querySelector('button.tm-btn-info');
        if (connectBtn instanceof HTMLButtonElement) {
            connectBtn.addEventListener('click', (ev) => {
                try { ev.stopPropagation(); } catch (e) {}
                try { window.tmWhiteboardAutoConnectMultiSelected?.(ev); } catch (e) {}
            });
        }
        const btn = tools.querySelector('button.tm-btn-danger');
        if (btn instanceof HTMLButtonElement) {
            btn.addEventListener('click', (ev) => {
                try { ev.stopPropagation(); } catch (e) {}
                try { window.tmWhiteboardDeleteMultiSelected?.(ev); } catch (e) {}
            });
        }
        try { viewport.appendChild(tools); } catch (e) {}
    }

    window.tmWhiteboardViewportWheel = function(ev) {
        if (state.viewMode !== 'whiteboard') return;
        try { ev?.preventDefault?.(); } catch (e) {}
        const viewport = state.modal?.querySelector?.('#tmWhiteboardViewport');
        if (!(viewport instanceof HTMLElement)) return;
        const rect = viewport.getBoundingClientRect();
        const px = Number(ev?.clientX) - rect.left;
        const py = Number(ev?.clientY) - rect.top;
        const v = __tmGetWhiteboardView();
        const factor = Number(ev?.deltaY) > 0 ? 0.92 : 1.08;
        const nextZoom = Math.max(0.35, Math.min(2.5, v.zoom * factor));
        const wx = (px - v.x) / v.zoom;
        const wy = (py - v.y) / v.zoom;
        const nextX = px - wx * nextZoom;
        const nextY = py - wy * nextZoom;
        __tmSetWhiteboardView({ x: nextX, y: nextY, zoom: nextZoom }, { persist: false });
        __tmApplyWhiteboardTransform();
        __tmScheduleWhiteboardViewSave();
    };

    function __tmBuildWhiteboardTouchPanSession(viewport, touchLike) {
        const t = touchLike || {};
        const v = __tmGetWhiteboardView();
        return {
            mode: 'pan',
            viewport,
            startClientX: Number(t.clientX) || 0,
            startClientY: Number(t.clientY) || 0,
            startX: Number(v.x) || 0,
            startY: Number(v.y) || 0,
        };
    }

    function __tmBuildWhiteboardTouchPinchSession(viewport, touchA, touchB) {
        const t1 = touchA || {};
        const t2 = touchB || {};
        const rect = viewport.getBoundingClientRect();
        const cxClient = ((Number(t1.clientX) || 0) + (Number(t2.clientX) || 0)) / 2;
        const cyClient = ((Number(t1.clientY) || 0) + (Number(t2.clientY) || 0)) / 2;
        const dx = (Number(t2.clientX) || 0) - (Number(t1.clientX) || 0);
        const dy = (Number(t2.clientY) || 0) - (Number(t1.clientY) || 0);
        const dist = Math.max(1, Math.hypot(dx, dy));
        const v = __tmGetWhiteboardView();
        const startZoom = Math.max(0.01, Number(v.zoom) || 1);
        const cx = cxClient - rect.left;
        const cy = cyClient - rect.top;
        return {
            mode: 'pinch',
            viewport,
            startDist: dist,
            startZoom,
            anchorWx: (cx - (Number(v.x) || 0)) / startZoom,
            anchorWy: (cy - (Number(v.y) || 0)) / startZoom,
        };
    }

    window.tmWhiteboardViewportTouchStart = function(ev) {
        if (state.viewMode !== 'whiteboard') return;
        const tool = String(SettingsStore.data.whiteboardTool || 'pan').trim();
        if (tool !== 'pan') return;
        const viewport = state.modal?.querySelector?.('#tmWhiteboardViewport');
        if (!(viewport instanceof HTMLElement)) return;
        const target = ev?.target;
        if (target && target.closest && target.closest('.tm-whiteboard-sidebar,.tm-whiteboard-bottom-toolbar,.tm-btn,input,button,select,textarea,label,a,.tm-whiteboard-doc-resize,.tm-task-link-dot,.tm-task-content-clickable,.tm-task-checkbox,.tm-kanban-chip,.tm-whiteboard-card-tools,.tm-whiteboard-note-tools,.tm-whiteboard-link-tools,.tm-whiteboard-edge')) return;
        const touches = ev?.touches;
        const n = Number(touches?.length) || 0;
        if (n <= 0) return;
        try { ev?.preventDefault?.(); } catch (e) {}
        if (n >= 2) {
            state.whiteboardTouchSession = __tmBuildWhiteboardTouchPinchSession(viewport, touches[0], touches[1]);
        } else {
            state.whiteboardTouchSession = __tmBuildWhiteboardTouchPanSession(viewport, touches[0]);
        }
        try { viewport.classList.add('tm-whiteboard-viewport--panning'); } catch (e) {}
    };

    window.tmWhiteboardViewportTouchMove = function(ev) {
        if (state.viewMode !== 'whiteboard') return;
        const s = state.whiteboardTouchSession;
        if (!s || typeof s !== 'object') return;
        const viewport = state.modal?.querySelector?.('#tmWhiteboardViewport');
        if (!(viewport instanceof HTMLElement)) return;
        const touches = ev?.touches;
        const n = Number(touches?.length) || 0;
        if (n <= 0) return;
        try { ev?.preventDefault?.(); } catch (e) {}
        if (n >= 2) {
            if (s.mode !== 'pinch') {
                state.whiteboardTouchSession = __tmBuildWhiteboardTouchPinchSession(viewport, touches[0], touches[1]);
                return;
            }
            const t1 = touches[0];
            const t2 = touches[1];
            const rect = viewport.getBoundingClientRect();
            const cxClient = ((Number(t1?.clientX) || 0) + (Number(t2?.clientX) || 0)) / 2;
            const cyClient = ((Number(t1?.clientY) || 0) + (Number(t2?.clientY) || 0)) / 2;
            const cx = cxClient - rect.left;
            const cy = cyClient - rect.top;
            const dx = (Number(t2?.clientX) || 0) - (Number(t1?.clientX) || 0);
            const dy = (Number(t2?.clientY) || 0) - (Number(t1?.clientY) || 0);
            const dist = Math.max(1, Math.hypot(dx, dy));
            const ratio = dist / Math.max(1, Number(s.startDist) || 1);
            const nextZoom = Math.max(0.35, Math.min(2.5, (Number(s.startZoom) || 1) * ratio));
            const nextX = cx - (Number(s.anchorWx) || 0) * nextZoom;
            const nextY = cy - (Number(s.anchorWy) || 0) * nextZoom;
            __tmSetWhiteboardView({ x: nextX, y: nextY, zoom: nextZoom }, { persist: false });
            __tmApplyWhiteboardTransform();
            return;
        }
        const t = touches[0];
        if (s.mode !== 'pan') {
            state.whiteboardTouchSession = __tmBuildWhiteboardTouchPanSession(viewport, t);
            return;
        }
        const dx = (Number(t?.clientX) || 0) - (Number(s.startClientX) || 0);
        const dy = (Number(t?.clientY) || 0) - (Number(s.startClientY) || 0);
        __tmSetWhiteboardView({ x: (Number(s.startX) || 0) + dx, y: (Number(s.startY) || 0) + dy }, { persist: false });
        __tmApplyWhiteboardTransform();
    };

    window.tmWhiteboardViewportTouchEnd = function(ev) {
        if (state.viewMode !== 'whiteboard') return;
        const s = state.whiteboardTouchSession;
        if (!s || typeof s !== 'object') return;
        const viewport = state.modal?.querySelector?.('#tmWhiteboardViewport');
        const touches = ev?.touches;
        const n = Number(touches?.length) || 0;
        try { ev?.preventDefault?.(); } catch (e) {}
        if (n <= 0) {
            state.whiteboardTouchSession = null;
            try { viewport?.classList?.remove?.('tm-whiteboard-viewport--panning'); } catch (e) {}
            __tmScheduleWhiteboardViewSave();
            return;
        }
        if (!(viewport instanceof HTMLElement)) {
            state.whiteboardTouchSession = null;
            __tmScheduleWhiteboardViewSave();
            return;
        }
        if (n >= 2) {
            state.whiteboardTouchSession = __tmBuildWhiteboardTouchPinchSession(viewport, touches[0], touches[1]);
            return;
        }
        state.whiteboardTouchSession = __tmBuildWhiteboardTouchPanSession(viewport, touches[0]);
    };

    window.tmWhiteboardViewportMouseDown = function(ev) {
        if (state.viewMode !== 'whiteboard') return;
        const pType = String(ev?.pointerType || '').toLowerCase();
        if (pType === 'touch') return;
        if (Number(ev?.button) !== 0) return;
        const tool = String(SettingsStore.data.whiteboardTool || 'pan').trim();
        const panMode = tool === 'pan';
        const selectMode = tool === 'select';
        const target = ev?.target;
        const viewport = state.modal?.querySelector?.('#tmWhiteboardViewport');
        if (!(viewport instanceof HTMLElement)) return;
        if (target && target.closest) {
            if (panMode) {
                if (target.closest('.tm-whiteboard-sidebar,.tm-whiteboard-bottom-toolbar,.tm-btn,input,button,select,textarea,label,a,.tm-whiteboard-doc-resize,.tm-task-link-dot,.tm-task-content-clickable,.tm-task-checkbox,.tm-kanban-chip,.tm-whiteboard-card-tools,.tm-whiteboard-note-tools,.tm-whiteboard-link-tools,.tm-whiteboard-edge,.tm-whiteboard-node,.tm-whiteboard-note,.tm-whiteboard-note-editor,.tm-whiteboard-doc-head')) return;
            } else if (selectMode) {
                if (target.closest('.tm-whiteboard-node,.tm-task-link-dot,.tm-task-checkbox,.tm-btn,.tm-task-content-clickable,.tm-whiteboard-note,.tm-whiteboard-note-editor,.tm-whiteboard-edge,.tm-whiteboard-link-tools,.tm-whiteboard-pool-item,.tm-whiteboard-doc-resize,.tm-whiteboard-doc-head,input,button,select,textarea,label,a')) return;
            } else {
                return;
            }
        }

        if (selectMode) {
            const vr = viewport.getBoundingClientRect();
            const sx = Number(ev?.clientX) || 0;
            const sy = Number(ev?.clientY) || 0;
            let lastCx = sx;
            let lastCy = sy;
            let started = false;
            let rect = { x: 0, y: 0, w: 0, h: 0 };
            const pointerId = Number.isFinite(Number(ev?.pointerId)) ? Number(ev.pointerId) : null;
            const marquee = document.createElement('div');
            marquee.className = 'tm-whiteboard-marquee';
            marquee.style.left = `${sx - vr.left}px`;
            marquee.style.top = `${sy - vr.top}px`;
            marquee.style.width = '0px';
            marquee.style.height = '0px';
            try { viewport.appendChild(marquee); } catch (e) {}

            state.whiteboardSelectedTaskId = '';
            state.whiteboardSelectedNoteId = '';
            __tmApplyWhiteboardCardSelectionDom('');
            state.whiteboardSelectedLinkId = '';
            state.whiteboardSelectedLinkDocId = '';
            __tmScheduleWhiteboardEdgeRedraw();
            __tmClearWhiteboardMultiSelection();

            const computeRect = (cx, cy) => {
                const x1 = Math.min(sx, cx) - vr.left;
                const y1 = Math.min(sy, cy) - vr.top;
                const x2 = Math.max(sx, cx) - vr.left;
                const y2 = Math.max(sy, cy) - vr.top;
                return { x: x1, y: y1, w: Math.max(0, x2 - x1), h: Math.max(0, y2 - y1) };
            };
            const intersects = (a, b) => !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom);
            const centerIn = (r, rr) => {
                const cx = rr.left + rr.width / 2;
                const cy = rr.top + rr.height / 2;
                return cx >= r.left && cx <= r.right && cy >= r.top && cy <= r.bottom;
            };
            const applySelection = (r) => {
                const sel = {
                    left: vr.left + r.x,
                    top: vr.top + r.y,
                    right: vr.left + r.x + r.w,
                    bottom: vr.top + r.y + r.h,
                };
                const body = state.modal?.querySelector?.('#tmWhiteboardBody');
                const taskIds = [];
                const noteIds = [];
                const linkKeys = [];
                if (body instanceof Element) {
                    try {
                        body.querySelectorAll('.tm-whiteboard-node[data-task-id]').forEach((el) => {
                            if (!(el instanceof HTMLElement)) return;
                            const rr = el.getBoundingClientRect();
                            if (intersects(sel, rr) || centerIn(sel, rr)) {
                                const id = String(el.getAttribute('data-task-id') || '').trim();
                                if (id) taskIds.push(id);
                            }
                        });
                    } catch (e) {}
                    try {
                        body.querySelectorAll('.tm-whiteboard-note[data-note-id]').forEach((el) => {
                            if (!(el instanceof HTMLElement)) return;
                            const rr = el.getBoundingClientRect();
                            if (intersects(sel, rr) || centerIn(sel, rr)) {
                                const id = String(el.getAttribute('data-note-id') || '').trim();
                                if (id) noteIds.push(id);
                            }
                        });
                    } catch (e) {}
                    try {
                        body.querySelectorAll('.tm-whiteboard-edge.tm-whiteboard-edge--manual[data-link-id][data-doc-id]').forEach((el) => {
                            if (!(el instanceof Element)) return;
                            const rr = el.getBoundingClientRect();
                            if (intersects(sel, rr) || centerIn(sel, rr)) {
                                const lid = String(el.getAttribute('data-link-id') || '').trim();
                                const did = String(el.getAttribute('data-doc-id') || '').trim();
                                if (lid && did) linkKeys.push(`${did}::${lid}`);
                            }
                        });
                    } catch (e) {}
                }
                state.whiteboardMultiSelectedTaskIds = Array.from(new Set(taskIds));
                state.whiteboardMultiSelectedNoteIds = Array.from(new Set(noteIds));
                state.whiteboardMultiSelectedLinkKeys = Array.from(new Set(linkKeys));
                __tmApplyWhiteboardMultiSelectionDom();
            };

            const cleanup = () => {
                try { marquee.remove(); } catch (e) {}
                try { document.removeEventListener('pointermove', onMove, true); } catch (e) {}
                try { document.removeEventListener('pointerup', onUp, true); } catch (e) {}
                try { document.removeEventListener('pointercancel', onUp, true); } catch (e) {}
                if (pointerId !== null && typeof viewport.releasePointerCapture === 'function') {
                    try { viewport.releasePointerCapture(pointerId); } catch (e) {}
                }
                state.whiteboardMarqueeSession = null;
            };

            const onMove = (e2) => {
                if (pointerId !== null && Number(e2?.pointerId) !== pointerId) return;
                const cx = Number(e2?.clientX) || lastCx;
                const cy = Number(e2?.clientY) || lastCy;
                lastCx = cx;
                lastCy = cy;
                rect = computeRect(cx, cy);
                if (!started && (rect.w > 2 || rect.h > 2)) started = true;
                marquee.style.left = `${rect.x}px`;
                marquee.style.top = `${rect.y}px`;
                marquee.style.width = `${rect.w}px`;
                marquee.style.height = `${rect.h}px`;
                if (started) applySelection(rect);
                state.whiteboardMarqueeSession = { sx, sy, marquee, viewport, rect };
            };

            const onUp = (e2) => {
                if (pointerId !== null && Number(e2?.pointerId) !== pointerId) return;
                const cx = Number(e2?.clientX);
                const cy = Number(e2?.clientY);
                if (Number.isFinite(cx) && Number.isFinite(cy)) rect = computeRect(cx, cy);
                if (!started && (rect.w > 2 || rect.h > 2)) started = true;
                if (started) {
                    applySelection(rect);
                    __tmRenderWhiteboardMultiTools(__tmComputeWhiteboardMultiSelectionRect() || rect);
                    if ((rect.w > 3 || rect.h > 3)
                        || (Array.isArray(state.whiteboardMultiSelectedTaskIds) && state.whiteboardMultiSelectedTaskIds.length)
                        || (Array.isArray(state.whiteboardMultiSelectedNoteIds) && state.whiteboardMultiSelectedNoteIds.length)
                        || (Array.isArray(state.whiteboardMultiSelectedLinkKeys) && state.whiteboardMultiSelectedLinkKeys.length)) {
                        state.whiteboardSuppressClickUntil = Date.now() + 260;
                    }
                }
                cleanup();
            };

            if (pointerId !== null && typeof viewport.setPointerCapture === 'function') {
                try { viewport.setPointerCapture(pointerId); } catch (e) {}
            }
            try { document.addEventListener('pointermove', onMove, true); } catch (e) {}
            try { document.addEventListener('pointerup', onUp, true); } catch (e) {}
            try { document.addEventListener('pointercancel', onUp, true); } catch (e) {}
            try { ev?.preventDefault?.(); } catch (e) {}
            return;
        }

        if (!panMode) return;
        try {
            const old = state.whiteboardPanSession;
            if (old && typeof old.cleanup === 'function') old.cleanup();
        } catch (e) {}
        const v0 = __tmGetWhiteboardView();
        const pointerId = Number(ev?.pointerId);
        const hasPointerId = Number.isFinite(pointerId);
        state.whiteboardPanSession = {
            startClientX: Number(ev?.clientX) || 0,
            startClientY: Number(ev?.clientY) || 0,
            startX: v0.x,
            startY: v0.y,
            pointerId: hasPointerId ? pointerId : null,
        };
        try { viewport.classList.add('tm-whiteboard-viewport--panning'); } catch (e) {}
        if (hasPointerId && typeof viewport.setPointerCapture === 'function') {
            try { viewport.setPointerCapture(pointerId); } catch (e) {}
        }
        const onMove = (e2) => {
            const s = state.whiteboardPanSession;
            if (!s) return;
            const pid = Number(s.pointerId);
            if (Number.isFinite(pid)) {
                const curPid = Number(e2?.pointerId);
                if (Number.isFinite(curPid) && curPid !== pid) return;
            }
            const dx = (Number(e2?.clientX) || 0) - s.startClientX;
            const dy = (Number(e2?.clientY) || 0) - s.startClientY;
            __tmSetWhiteboardView({ x: s.startX + dx, y: s.startY + dy }, { persist: false });
            __tmApplyWhiteboardTransform();
        };
        const onUp = (e2) => {
            const s = state.whiteboardPanSession;
            if (s && Number.isFinite(Number(s.pointerId))) {
                const curPid = Number(e2?.pointerId);
                if (Number.isFinite(curPid) && curPid !== Number(s.pointerId)) return;
            }
            try { document.removeEventListener('mousemove', onMove, true); } catch (e) {}
            try { document.removeEventListener('mouseup', onUp, true); } catch (e) {}
            try { document.removeEventListener('pointermove', onMove, true); } catch (e) {}
            try { document.removeEventListener('pointerup', onUp, true); } catch (e) {}
            try { document.removeEventListener('pointercancel', onUp, true); } catch (e) {}
            try { window.removeEventListener('blur', onUp, true); } catch (e) {}
            if (Number.isFinite(pointerId) && typeof viewport.releasePointerCapture === 'function') {
                try { viewport.releasePointerCapture(pointerId); } catch (e) {}
            }
            try { viewport.classList.remove('tm-whiteboard-viewport--panning'); } catch (e) {}
            state.whiteboardPanSession = null;
            __tmScheduleWhiteboardViewSave();
        };
        state.whiteboardPanSession.cleanup = onUp;
        try { document.addEventListener('mousemove', onMove, true); } catch (e) {}
        try { document.addEventListener('mouseup', onUp, true); } catch (e) {}
        try { document.addEventListener('pointermove', onMove, true); } catch (e) {}
        try { document.addEventListener('pointerup', onUp, true); } catch (e) {}
        try { document.addEventListener('pointercancel', onUp, true); } catch (e) {}
        try { window.addEventListener('blur', onUp, true); } catch (e) {}
        try { ev?.preventDefault?.(); } catch (e) {}
    };

    window.tmWhiteboardCardMouseDown = function(ev, taskId, docId) {
        if (state.viewMode !== 'whiteboard') return;
        const tool = String(SettingsStore.data.whiteboardTool || 'pan').trim();
        if (tool !== 'pan' && tool !== 'select') return;
        if (Number(ev?.button) !== 0) return;
        const id = String(taskId || '').trim();
        const did = String(docId || '').trim();
        if (!id || !did) return;
        const target = ev?.target;
        const multiTaskIds0 = Array.isArray(state.whiteboardMultiSelectedTaskIds)
            ? state.whiteboardMultiSelectedTaskIds.map((x) => String(x || '').trim()).filter(Boolean)
            : [];
        const multiNoteIds0 = Array.isArray(state.whiteboardMultiSelectedNoteIds)
            ? state.whiteboardMultiSelectedNoteIds.map((x) => String(x || '').trim()).filter(Boolean)
            : [];
        const inMulti = multiTaskIds0.includes(id);
        const multiCount = multiTaskIds0.length + multiNoteIds0.length;
        const hitContent = !!(target && target.closest && target.closest('.tm-task-content-clickable,.tm-kanban-chip'));
        if (target && target.closest && target.closest('.tm-task-link-dot,.tm-task-checkbox,.tm-btn,input,button,select,textarea,label,a')) return;
        if (hitContent && !(multiCount > 1 && inMulti)) return;
        const multiTaskIds = Array.isArray(state.whiteboardMultiSelectedTaskIds)
            ? state.whiteboardMultiSelectedTaskIds.map((x) => String(x || '').trim()).filter(Boolean)
            : [];
        const multiNoteIds = Array.isArray(state.whiteboardMultiSelectedNoteIds)
            ? state.whiteboardMultiSelectedNoteIds.map((x) => String(x || '').trim()).filter(Boolean)
            : [];
        let groupDragItems = [];
        const wantsGroupDrag = (multiTaskIds.length + multiNoteIds.length > 1) && multiTaskIds.includes(id);
        if (wantsGroupDrag) {
            const uniqTaskIds = Array.from(new Set(multiTaskIds));
            const uniqNoteIds = Array.from(new Set(multiNoteIds));
            const taskItems = uniqTaskIds.map((tid) => {
                const cardEl = state.modal?.querySelector?.(`.tm-whiteboard-card[data-task-id="${CSS.escape(tid)}"]`);
                if (!(cardEl instanceof HTMLElement)) return null;
                if (cardEl.classList.contains('tm-whiteboard-node--sub')) return null;
                const sx = Number(cardEl.dataset?.x);
                const sy = Number(cardEl.dataset?.y);
                const x0 = Number.isFinite(sx) ? sx : Number((cardEl.style.left || '').replace('px', '')) || 0;
                const y0 = Number.isFinite(sy) ? sy : Number((cardEl.style.top || '').replace('px', '')) || 0;
                const tdid = String(cardEl.getAttribute('data-doc-id') || '').trim();
                if (!tdid) return null;
                return { kind: 'task', id: tid, did: tdid, el: cardEl, x0, y0 };
            }).filter(Boolean);
            const noteItems = uniqNoteIds.map((nid) => {
                const noteEl = state.modal?.querySelector?.(`.tm-whiteboard-note[data-note-id="${CSS.escape(nid)}"]`);
                if (!(noteEl instanceof HTMLElement)) return null;
                const x0 = Number((noteEl.style.left || '').replace('px', '')) || 0;
                const y0 = Number((noteEl.style.top || '').replace('px', '')) || 0;
                const ndid = String(noteEl.getAttribute('data-doc-id') || '').trim();
                if (!ndid) return null;
                return { kind: 'note', id: nid, did: ndid, el: noteEl, x0, y0 };
            }).filter(Boolean);
            groupDragItems = taskItems.concat(noteItems);
        }
        const useGroupDrag = groupDragItems.length > 1;
        if (!useGroupDrag) {
            __tmClearWhiteboardMultiSelection();
            state.whiteboardSelectedTaskId = id;
            state.whiteboardSelectedNoteId = '';
            __tmApplyWhiteboardCardSelectionDom(id);
        } else {
            state.whiteboardSelectedTaskId = '';
            state.whiteboardSelectedNoteId = '';
            __tmApplyWhiteboardCardSelectionDom('');
            __tmApplyWhiteboardMultiSelectionDom();
        }
        const card = ev?.currentTarget instanceof HTMLElement ? ev.currentTarget : (target?.closest?.('.tm-whiteboard-node') || null);
        if (!(card instanceof HTMLElement)) return;
        const isSubNode = card.classList.contains('tm-whiteboard-node--sub');
        const startX = Number(card.dataset?.x);
        const startY = Number(card.dataset?.y);
        const x0 = isSubNode ? 0 : (Number.isFinite(startX) ? startX : Number(card.style.left.replace('px', '')) || 0);
        const y0 = isSubNode ? 0 : (Number.isFinite(startY) ? startY : Number(card.style.top.replace('px', '')) || 0);
        const zoom = __tmGetWhiteboardView().zoom || 1;
        const sx = Number(ev?.clientX) || 0;
        const sy = Number(ev?.clientY) || 0;
        state.whiteboardNodeDrag = { id, did, x0, y0, sx, sy, card, isSubNode, detached: false, group: useGroupDrag ? groupDragItems : null };
        const onMove = (e2) => {
            const d = state.whiteboardNodeDrag;
            if (!d) return;
            if (Array.isArray(d.group) && d.group.length > 1) {
                const dx = ((Number(e2?.clientX) || 0) - d.sx) / (zoom || 1);
                const dy = ((Number(e2?.clientY) || 0) - d.sy) / (zoom || 1);
                d.group.forEach((g) => {
                    if (!g || !(g.el instanceof HTMLElement)) return;
                    const nx = Math.round(Number(g.x0 || 0) + dx);
                    const ny = Math.round(Number(g.y0 || 0) + dy);
                    g.el.style.left = `${nx}px`;
                    g.el.style.top = `${ny}px`;
                    if (g.kind === 'task') {
                        g.el.dataset.x = String(nx);
                        g.el.dataset.y = String(ny);
                        __tmSetWhiteboardNodePos(g.id, g.did, nx, ny, { persist: false, manual: true });
                        __tmSetWhiteboardTaskPlaced(g.id, true, { persist: false });
                    }
                });
                __tmScheduleWhiteboardEdgeRedraw();
                __tmRenderWhiteboardMultiTools(__tmComputeWhiteboardMultiSelectionRect());
                return;
            }
            if (d.isSubNode && !d.detached) {
                const dx0 = (Number(e2?.clientX) || 0) - d.sx;
                const dy0 = (Number(e2?.clientY) || 0) - d.sy;
                if (Math.abs(dx0) + Math.abs(dy0) < 4) return;
                const p = __tmResolveWhiteboardPointerInfo(e2, d.did)
                    || __tmResolveWhiteboardPointerInfo(ev, d.did)
                    || __tmTrackWhiteboardPointerFromClient(e2?.clientX, e2?.clientY, d.did);
                const anchorX = 18;
                const anchorY = 16;
                const nx0 = Math.round((Number(p?.localX) || 24) - anchorX);
                const ny0 = Math.round((Number(p?.localY) || 24) - anchorY);
                const dTask = state.flatTasks?.[String(d.id || '').trim()];
                const dParentId = String(dTask?.parentTaskId || '').trim();
                __tmSetWhiteboardChildDetached(d.id, true, dParentId);
                __tmSetWhiteboardTaskPlaced(d.id, true, { persist: false });
                __tmSetWhiteboardNodePos(d.id, d.did, nx0, ny0, { persist: false, manual: true });
                state.whiteboardSelectedTaskId = d.id;
                state.whiteboardNodeDrag = null;
                render();
                const nextCard = state.modal?.querySelector?.(`.tm-whiteboard-card[data-task-id="${CSS.escape(d.id)}"]`);
                if (nextCard instanceof HTMLElement) {
                    state.whiteboardNodeDrag = {
                        id: d.id,
                        did: d.did,
                        x0: nx0,
                        y0: ny0,
                        sx: Number(e2?.clientX) || 0,
                        sy: Number(e2?.clientY) || 0,
                        card: nextCard,
                        isSubNode: false,
                        detached: true,
                    };
                }
                return;
            }
            const dx = ((Number(e2?.clientX) || 0) - d.sx) / (zoom || 1);
            const dy = ((Number(e2?.clientY) || 0) - d.sy) / (zoom || 1);
            const nx = Math.round(d.x0 + dx);
            const ny = Math.round(d.y0 + dy);
            d.card.style.left = `${nx}px`;
            d.card.style.top = `${ny}px`;
            d.card.dataset.x = String(nx);
            d.card.dataset.y = String(ny);
            __tmSetWhiteboardNodePos(d.id, d.did, nx, ny, { persist: false, manual: true });
            __tmSetWhiteboardTaskPlaced(d.id, true, { persist: false });
            __tmScheduleWhiteboardEdgeRedraw();
        };
        const onUp = (eUp) => {
            try { document.removeEventListener('mousemove', onMove, true); } catch (e) {}
            try { document.removeEventListener('mouseup', onUp, true); } catch (e) {}
            const d = state.whiteboardNodeDrag;
            state.whiteboardNodeDrag = null;
            if (d && Array.isArray(d.group) && d.group.length > 1) {
                const notes = Array.isArray(SettingsStore.data.whiteboardNotes) ? [...SettingsStore.data.whiteboardNotes] : [];
                const allView = !(state.activeDocId && state.activeDocId !== 'all');
                d.group.forEach((g) => {
                    if (!g || g.kind !== 'note' || !(g.el instanceof HTMLElement)) return;
                    const nx = Number((g.el.style.left || '').replace('px', '')) || Number(g.x0 || 0);
                    const ny = Number((g.el.style.top || '').replace('px', '')) || Number(g.y0 || 0);
                    const idx = notes.findIndex((n) => String(n?.id || '').trim() === String(g.id || '').trim());
                    if (idx < 0) return;
                    const offX = allView ? (Number(g.el.parentElement?.dataset?.frameOffsetX) || 0) : 0;
                    const offY = allView ? (Number(g.el.parentElement?.dataset?.frameOffsetY) || 0) : 0;
                    notes[idx] = { ...(notes[idx] || {}), docId: g.did, x: Math.round(nx - offX), y: Math.round(ny - offY) };
                });
                SettingsStore.data.whiteboardNotes = notes;
                try { SettingsStore.syncToLocal(); } catch (e) {}
            }
            if (d && !d.isSubNode && !(Array.isArray(d.group) && d.group.length > 1)) {
                const task = state.flatTasks?.[String(d.id || '').trim()];
                const parentId = String(task?.parentTaskId || '').trim();
                const isDetached = parentId ? __tmIsWhiteboardChildDetached(d.id) : false;
                if (parentId && isDetached) {
                    let hit = null;
                    try { hit = document.elementFromPoint(Number(eUp?.clientX) || 0, Number(eUp?.clientY) || 0); } catch (e) {}
                    const parentNode = hit?.closest?.(`.tm-whiteboard-node[data-task-id="${CSS.escape(parentId)}"]`);
                    if (parentNode instanceof Element) {
                        __tmSetWhiteboardChildDetached(d.id, false);
                        __tmSetWhiteboardTaskPlaced(d.id, true, { persist: false });
                        try { SettingsStore.save(); } catch (e) {}
                        render();
                        return;
                    }
                }
            }
            try { SettingsStore.save(); } catch (e) {}
        };
        try { document.addEventListener('mousemove', onMove, true); } catch (e) {}
        try { document.addEventListener('mouseup', onUp, true); } catch (e) {}
        try { ev?.stopPropagation?.(); } catch (e) {}
    };

    window.tmWhiteboardSelectTask = function(taskId, ev) {
        if (state.viewMode !== 'whiteboard') return;
        const tool = String(SettingsStore.data.whiteboardTool || 'pan').trim();
        if (tool !== 'pan' && tool !== 'select') return;
        const id = String(taskId || '').trim();
        if (!id) return;
        try { ev?.stopPropagation?.(); } catch (e) {}
        if (tool === 'select') {
            state.whiteboardSelectedTaskId = '';
            state.whiteboardSelectedNoteId = '';
            state.whiteboardSelectedLinkId = '';
            state.whiteboardSelectedLinkDocId = '';
            __tmApplyWhiteboardCardSelectionDom('');
            const setTask = new Set((Array.isArray(state.whiteboardMultiSelectedTaskIds) ? state.whiteboardMultiSelectedTaskIds : []).map((x) => String(x || '').trim()).filter(Boolean));
            setTask.add(id);
            state.whiteboardMultiSelectedTaskIds = Array.from(setTask);
            state.whiteboardMultiSelectedNoteIds = Array.isArray(state.whiteboardMultiSelectedNoteIds)
                ? state.whiteboardMultiSelectedNoteIds.map((x) => String(x || '').trim()).filter(Boolean)
                : [];
            __tmApplyWhiteboardMultiSelectionDom();
            __tmRenderWhiteboardMultiTools(__tmComputeWhiteboardMultiSelectionRect());
            __tmScheduleWhiteboardEdgeRedraw();
            return;
        }
        __tmClearWhiteboardMultiSelection();
        state.whiteboardSelectedTaskId = id;
        state.whiteboardSelectedNoteId = '';
        state.whiteboardSelectedLinkId = '';
        state.whiteboardSelectedLinkDocId = '';
        __tmApplyWhiteboardCardSelectionDom(id);
        __tmScheduleWhiteboardEdgeRedraw();
        render();
    };

    window.tmWhiteboardDeleteCard = async function(taskId, docId, ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        const id = String(taskId || '').trim();
        if (!id) return;
        const ids = __tmWhiteboardCollectTaskTreeIds(id, { includeRoot: true, includeDetached: false, includeSnapshotTree: true });
        ids.forEach((tid) => __tmSetWhiteboardTaskPlaced(tid, false, { persist: false }));
        const snapshotIds = ids.filter((tid) => {
            const k = String(tid || '').trim();
            if (!k) return false;
            if (state.flatTasks?.[k]) return false;
            return !!__tmGetWhiteboardCardSnapshot(k);
        });
        __tmDeleteWhiteboardSnapshotTasks(snapshotIds);
        const idSet = new Set(ids.map((x) => String(x || '').trim()).filter(Boolean));
        const links = __tmGetManualTaskLinks().filter((x) => {
            const from = String(x?.from || '').trim();
            const to = String(x?.to || '').trim();
            return !idSet.has(from) && !idSet.has(to);
        });
        __tmSetManualTaskLinks(links);
        if (idSet.has(String(state.whiteboardSelectedTaskId || '').trim())) state.whiteboardSelectedTaskId = '';
        try { await SettingsStore.save(); } catch (e) {}
        render();
    };

    window.tmWhiteboardSelectNote = function(noteId, ev) {
        if (state.viewMode !== 'whiteboard') return;
        const tool = String(SettingsStore.data.whiteboardTool || 'pan');
        if (tool !== 'pan' && tool !== 'text' && tool !== 'select') return;
        if (state.whiteboardNoteEditor) return;
        try { ev?.stopPropagation?.(); } catch (e) {}
        const id = String(noteId || '').trim();
        if (!id) return;
        if (String(state.whiteboardSelectedNoteId || '').trim() === id) return;
        __tmClearWhiteboardMultiSelection();
        state.whiteboardSelectedNoteId = id;
        state.whiteboardSelectedTaskId = '';
        __tmApplyWhiteboardCardSelectionDom('');
        state.whiteboardSelectedLinkId = '';
        state.whiteboardSelectedLinkDocId = '';
        __tmScheduleWhiteboardEdgeRedraw();
        render();
    };

    window.tmWhiteboardNoteClick = function(noteId, ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        const prev = Number(state.whiteboardNoteClickTimer) || 0;
        if (prev) {
            try { clearTimeout(prev); } catch (e) {}
            state.whiteboardNoteClickTimer = 0;
        }
        state.whiteboardNoteClickTimer = setTimeout(() => {
            state.whiteboardNoteClickTimer = 0;
            try { window.tmWhiteboardSelectNote?.(noteId, ev); } catch (e) {}
        }, 180);
    };

    function __tmNormalizeWhiteboardNoteColor(v) {
        const s = String(v || '').trim();
        if (!s) return '';
        if (/^#[0-9a-fA-F]{3,8}$/.test(s)) return s;
        return '';
    }

    function __tmNormalizeWhiteboardNoteFontSize(v) {
        const n = Number(v);
        if (!Number.isFinite(n)) return 12;
        return Math.max(10, Math.min(40, Math.round(n)));
    }

    function __tmNormalizeWhiteboardNoteWidth(v) {
        const n = Number(v);
        if (!Number.isFinite(n)) return 0;
        return Math.max(80, Math.min(2200, Math.round(n)));
    }

    function __tmNormalizeWhiteboardNoteBold(v) {
        return !!v;
    }

    async function __tmUpdateWhiteboardNoteStyle(noteId, patch = {}) {
        const id = String(noteId || '').trim();
        if (!id) return false;
        const notes = Array.isArray(SettingsStore.data.whiteboardNotes) ? [...SettingsStore.data.whiteboardNotes] : [];
        const idx = notes.findIndex((n) => String(n?.id || '').trim() === id);
        if (idx < 0) return false;
        const cur = notes[idx] && typeof notes[idx] === 'object' ? notes[idx] : {};
        const next = { ...cur };
        if (Object.prototype.hasOwnProperty.call(patch, 'color')) {
            const c = __tmNormalizeWhiteboardNoteColor(patch.color);
            if (c) next.color = c;
            else delete next.color;
        }
        if (Object.prototype.hasOwnProperty.call(patch, 'fontSize')) {
            next.fontSize = __tmNormalizeWhiteboardNoteFontSize(patch.fontSize);
        }
        if (Object.prototype.hasOwnProperty.call(patch, 'width')) {
            const w = __tmNormalizeWhiteboardNoteWidth(patch.width);
            if (w > 0) next.width = w;
            else delete next.width;
        }
        if (Object.prototype.hasOwnProperty.call(patch, 'bold')) {
            next.bold = __tmNormalizeWhiteboardNoteBold(patch.bold);
        }
        notes[idx] = next;
        SettingsStore.data.whiteboardNotes = notes;
        try { SettingsStore.syncToLocal(); } catch (e) {}
        try { await SettingsStore.save(); } catch (e) {}
        return true;
    }

    window.tmWhiteboardAdjustNoteFontSize = async function(noteId, delta, ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        const id = String(noteId || '').trim();
        if (!id) return;
        const notes = Array.isArray(SettingsStore.data.whiteboardNotes) ? SettingsStore.data.whiteboardNotes : [];
        const note = notes.find((n) => String(n?.id || '').trim() === id);
        const cur = __tmNormalizeWhiteboardNoteFontSize(note?.fontSize);
        const d = Number(delta);
        const next = __tmNormalizeWhiteboardNoteFontSize(cur + (Number.isFinite(d) ? d : 0));
        const ok = await __tmUpdateWhiteboardNoteStyle(id, { fontSize: next });
        if (!ok) return;
        state.whiteboardSelectedNoteId = id;
        render();
    };

    window.tmWhiteboardSetNoteColor = async function(noteId, color, ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        const id = String(noteId || '').trim();
        if (!id) return;
        const ok = await __tmUpdateWhiteboardNoteStyle(id, { color: color });
        if (!ok) return;
        state.whiteboardSelectedNoteId = id;
        render();
    };

    window.tmWhiteboardToggleNoteBold = async function(noteId, ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        const id = String(noteId || '').trim();
        if (!id) return;
        const notes = Array.isArray(SettingsStore.data.whiteboardNotes) ? SettingsStore.data.whiteboardNotes : [];
        const note = notes.find((n) => String(n?.id || '').trim() === id);
        const next = !__tmNormalizeWhiteboardNoteBold(note?.bold);
        const ok = await __tmUpdateWhiteboardNoteStyle(id, { bold: next });
        if (!ok) return;
        state.whiteboardSelectedNoteId = id;
        render();
    };

    window.tmWhiteboardDeleteNote = async function(noteId, ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        const id = String(noteId || '').trim();
        if (!id) return;
        const notes = Array.isArray(SettingsStore.data.whiteboardNotes) ? SettingsStore.data.whiteboardNotes : [];
        SettingsStore.data.whiteboardNotes = notes.filter((n) => String(n?.id || '').trim() !== id);
        if (String(state.whiteboardSelectedNoteId || '').trim() === id) state.whiteboardSelectedNoteId = '';
        try { SettingsStore.syncToLocal(); } catch (e) {}
        try { await SettingsStore.save(); } catch (e) {}
        render();
    };

    window.tmWhiteboardDeleteMultiSelected = async function(ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        const taskIds = Array.from(new Set((Array.isArray(state.whiteboardMultiSelectedTaskIds) ? state.whiteboardMultiSelectedTaskIds : []).map((x) => String(x || '').trim()).filter(Boolean)));
        const noteIds = Array.from(new Set((Array.isArray(state.whiteboardMultiSelectedNoteIds) ? state.whiteboardMultiSelectedNoteIds : []).map((x) => String(x || '').trim()).filter(Boolean)));
        const linkKeys = Array.from(new Set((Array.isArray(state.whiteboardMultiSelectedLinkKeys) ? state.whiteboardMultiSelectedLinkKeys : []).map((x) => String(x || '').trim()).filter(Boolean)));
        if (!taskIds.length && !noteIds.length && !linkKeys.length) return;
        const allTaskIds = new Set();
        taskIds.forEach((id) => {
            __tmWhiteboardCollectTaskTreeIds(id, { includeRoot: true, includeDetached: false, includeSnapshotTree: true })
                .forEach((tid) => allTaskIds.add(String(tid || '').trim()));
        });
        allTaskIds.forEach((tid) => {
            if (!tid) return;
            __tmSetWhiteboardTaskPlaced(tid, false, { persist: false });
        });
        const snapshotIds = Array.from(allTaskIds).filter((tid) => {
            const k = String(tid || '').trim();
            if (!k) return false;
            if (state.flatTasks?.[k]) return false;
            return !!__tmGetWhiteboardCardSnapshot(k);
        });
        __tmDeleteWhiteboardSnapshotTasks(snapshotIds);
        if (allTaskIds.size) {
            const links = __tmGetManualTaskLinks().filter((x) => {
                const from = String(x?.from || '').trim();
                const to = String(x?.to || '').trim();
                return !allTaskIds.has(from) && !allTaskIds.has(to);
            });
            __tmSetManualTaskLinks(links);
        }
        if (linkKeys.length) {
            const selectedSet = new Set(linkKeys);
            const links = __tmGetManualTaskLinks().filter((x) => {
                const key = `${String(x?.docId || '').trim()}::${String(x?.id || '').trim()}`;
                return !selectedSet.has(key);
            });
            __tmSetManualTaskLinks(links);
        }
        if (noteIds.length) {
            const noteSet = new Set(noteIds);
            const notes = Array.isArray(SettingsStore.data.whiteboardNotes) ? SettingsStore.data.whiteboardNotes : [];
            SettingsStore.data.whiteboardNotes = notes.filter((n) => !noteSet.has(String(n?.id || '').trim()));
        }
        state.whiteboardSelectedTaskId = '';
        state.whiteboardSelectedNoteId = '';
        state.whiteboardSelectedLinkId = '';
        state.whiteboardSelectedLinkDocId = '';
        state.whiteboardMultiSelectedLinkKeys = [];
        __tmApplyWhiteboardCardSelectionDom('');
        __tmClearWhiteboardMultiSelection();
        try { SettingsStore.syncToLocal(); } catch (e) {}
        try { await SettingsStore.save(); } catch (e) {}
        render();
    };

    window.tmWhiteboardAutoConnectMultiSelected = async function(ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        const taskIds = Array.from(new Set((Array.isArray(state.whiteboardMultiSelectedTaskIds) ? state.whiteboardMultiSelectedTaskIds : []).map((x) => String(x || '').trim()).filter(Boolean)));
        if (taskIds.length < 2) return;
        const body = state.modal?.querySelector?.('#tmWhiteboardBody');
        if (!(body instanceof Element)) return;
        const pickNode = (taskId) => {
            try {
                return body.querySelector(`.tm-whiteboard-node[data-task-id="${CSS.escape(taskId)}"]`);
            } catch (e) {
                return null;
            }
        };
        const eligibleTaskIds = taskIds.filter((id) => {
            const el = pickNode(id);
            if (!(el instanceof HTMLElement)) return false;
            if (!el.classList.contains('tm-whiteboard-node--sub')) return true;
            return __tmIsWhiteboardChildDetached(id);
        });
        if (eligibleTaskIds.length < 2) {
            try { hint('ℹ 自动连线仅处理最高层卡片（已拖出的子任务除外）', 'info'); } catch (e) {}
            return;
        }
        const items = eligibleTaskIds.map((id) => {
            const el = pickNode(id);
            if (!(el instanceof HTMLElement)) return null;
            const rect = el.getBoundingClientRect();
            const docId = String(el.getAttribute('data-doc-id') || __tmGetTaskDocIdById(id) || '').trim();
            if (!docId) return null;
            return {
                id,
                docId,
                left: Number(rect.left) || 0,
                top: Number(rect.top) || 0,
                right: Number(rect.right) || 0,
                bottom: Number(rect.bottom) || 0,
            };
        }).filter(Boolean);
        if (items.length < 2) return;

        const byDoc = new Map();
        items.forEach((it) => {
            const did = String(it.docId || '').trim();
            if (!did) return;
            if (!byDoc.has(did)) byDoc.set(did, []);
            byDoc.get(did).push(it);
        });
        if (!byDoc.size) return;

        const buildRowsOrder = (arr) => {
            const remaining = arr.slice().sort((a, b) => (a.top - b.top) || (a.left - b.left));
            const rows = [];
            while (remaining.length) {
                const anchor = remaining.shift();
                const rowBottom = Number(anchor.bottom) || (Number(anchor.top) + 80);
                const row = [anchor];
                for (let i = remaining.length - 1; i >= 0; i--) {
                    const x = remaining[i];
                    if ((Number(x.top) || 0) < rowBottom) {
                        row.push(x);
                        remaining.splice(i, 1);
                    }
                }
                row.sort((a, b) => (a.left - b.left) || (a.top - b.top));
                rows.push(row);
            }
            rows.sort((a, b) => ((a[0]?.top || 0) - (b[0]?.top || 0)) || ((a[0]?.left || 0) - (b[0]?.left || 0)));
            return rows.flatMap((r) => r);
        };

        const manual = __tmGetManualTaskLinks();
        let added = 0;
        let skipped = 0;
        byDoc.forEach((arr, docId) => {
            if (!Array.isArray(arr) || arr.length < 2) return;
            const ordered = buildRowsOrder(arr);
            for (let i = 1; i < ordered.length; i++) {
                const fromId = String(ordered[i - 1]?.id || '').trim();
                const toId = String(ordered[i]?.id || '').trim();
                if (!fromId || !toId || fromId === toId) continue;
                const check = __tmCanLinkTasks(fromId, toId);
                if (!check.ok) {
                    skipped++;
                    continue;
                }
                const did = String(check.docId || docId || '').trim();
                if (!did) {
                    skipped++;
                    continue;
                }
                const exists = manual.some((x) => String(x?.from || '') === fromId && String(x?.to || '') === toId && String(x?.docId || '') === did);
                if (exists) {
                    skipped++;
                    continue;
                }
                manual.push({
                    id: `link_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
                    from: fromId,
                    to: toId,
                    docId: did,
                    createdAt: String(Date.now()),
                });
                added++;
            }
        });
        if (!added) {
            try { hint('ℹ 未新增连线（可能已存在或跨文档）', 'info'); } catch (e) {}
            return;
        }
        __tmSetManualTaskLinks(manual);
        try { await SettingsStore.save(); } catch (e) {}
        try { hint(`✅ 已新增 ${added} 条连线${skipped ? `（跳过 ${skipped} 条）` : ''}`, 'success'); } catch (e) {}
        __tmScheduleWhiteboardEdgeRedraw();
        render();
    };

    window.tmWhiteboardEditNote = function(noteId, docId, ev) {
        try {
            ev?.stopPropagation?.();
            ev?.preventDefault?.();
        } catch (e) {}
        const t = Number(state.whiteboardNoteClickTimer) || 0;
        if (t) {
            try { clearTimeout(t); } catch (e) {}
            state.whiteboardNoteClickTimer = 0;
        }
        if (String(SettingsStore.data.whiteboardTool || 'pan') !== 'pan') return;
        const id = String(noteId || '').trim();
        const did = String(docId || '').trim();
        if (!id || !did) return;
        const notes = Array.isArray(SettingsStore.data.whiteboardNotes) ? SettingsStore.data.whiteboardNotes : [];
        const note = notes.find((n) => String(n?.id || '').trim() === id);
        if (!note) return;
        const noteEl = (ev?.currentTarget instanceof HTMLElement)
            ? ev.currentTarget
            : state.modal?.querySelector?.(`.tm-whiteboard-note[data-note-id="${CSS.escape(id)}"][data-doc-id="${CSS.escape(did)}"]`);
        const docBody = (noteEl instanceof HTMLElement ? noteEl.closest('.tm-whiteboard-doc-body[data-doc-id]') : null)
            || state.modal?.querySelector?.(`.tm-whiteboard-doc-body[data-doc-id="${CSS.escape(did)}"]`);
        if (!(docBody instanceof HTMLElement)) return;
        __tmClearWhiteboardMultiSelection();
        state.whiteboardSelectedNoteId = id;
        state.whiteboardSelectedTaskId = '';
        __tmApplyWhiteboardCardSelectionDom('');
        state.whiteboardSelectedLinkId = '';
        state.whiteboardSelectedLinkDocId = '';
        __tmScheduleWhiteboardEdgeRedraw();
        const allView = !(state.activeDocId && state.activeDocId !== 'all');
        const offX = allView ? (Number(docBody.dataset?.frameOffsetX) || 0) : 0;
        const offY = allView ? (Number(docBody.dataset?.frameOffsetY) || 0) : 0;
        let x = (Number.isFinite(Number(note?.x)) ? Number(note.x) : 24) + offX;
        let y = (Number.isFinite(Number(note?.y)) ? Number(note.y) : 24) + offY;
        try {
            if (noteEl instanceof HTMLElement) {
                const sx = Number((noteEl.style.left || '').replace('px', ''));
                const sy = Number((noteEl.style.top || '').replace('px', ''));
                if (Number.isFinite(sx)) x = sx;
                if (Number.isFinite(sy)) y = sy;
                // 兜底：当 style 坐标不可用时，再退回到基于实际渲染位置的换算
                if (!Number.isFinite(sx) || !Number.isFinite(sy)) {
                    const zoom = Math.max(0.01, Number(__tmGetWhiteboardView()?.zoom) || 1);
                    const nr = noteEl.getBoundingClientRect();
                    const dr = docBody.getBoundingClientRect();
                    const rx = (nr.left - dr.left) / zoom;
                    const ry = (nr.top - dr.top) / zoom;
                    if (!Number.isFinite(sx) && Number.isFinite(rx)) x = rx;
                    if (!Number.isFinite(sy) && Number.isFinite(ry)) y = ry;
                }
            }
        } catch (e) {}
        __tmOpenWhiteboardNoteEditor(docBody, did, x, y, {
            noteId: id,
            text: String(note?.text || ''),
            offsetX: offX,
            offsetY: offY,
            fontSize: __tmNormalizeWhiteboardNoteFontSize(note?.fontSize),
            color: __tmNormalizeWhiteboardNoteColor(note?.color) || '',
            bold: __tmNormalizeWhiteboardNoteBold(note?.bold),
        });
    };

    window.tmWhiteboardNoteMouseDown = function(ev, noteId, docId) {
        if (state.viewMode !== 'whiteboard') return;
        const tool = String(SettingsStore.data.whiteboardTool || 'pan');
        if (tool !== 'pan' && tool !== 'text' && tool !== 'select') return;
        if (Number(ev?.button) !== 0) return;
        if (state.whiteboardNoteEditor) return;
        // 双击用于编辑，不应进入拖拽流程，否则 mouseup-render 会把编辑框顶掉
        if (Number(ev?.detail) >= 2) return;
        const target = ev?.target;
        if (target && target.closest && target.closest('.tm-whiteboard-note-resize,.tm-whiteboard-note-width-resize')) return;
        if (target && target.closest && target.closest('.tm-btn,input,button,select,textarea,label,a')) return;
        const id = String(noteId || '').trim();
        const did = String(docId || '').trim();
        if (!id || !did) return;
        const noteEl = ev?.currentTarget instanceof HTMLElement ? ev.currentTarget : (target?.closest?.('.tm-whiteboard-note') || null);
        if (!(noteEl instanceof HTMLElement)) return;
        const x0 = Number(noteEl.style.left.replace('px', '')) || 0;
        const y0 = Number(noteEl.style.top.replace('px', '')) || 0;
        const zoom = __tmGetWhiteboardView().zoom || 1;
        const sx = Number(ev?.clientX) || 0;
        const sy = Number(ev?.clientY) || 0;
        const multiTaskIds = Array.isArray(state.whiteboardMultiSelectedTaskIds)
            ? state.whiteboardMultiSelectedTaskIds.map((x) => String(x || '').trim()).filter(Boolean)
            : [];
        const multiNoteIds = Array.isArray(state.whiteboardMultiSelectedNoteIds)
            ? state.whiteboardMultiSelectedNoteIds.map((x) => String(x || '').trim()).filter(Boolean)
            : [];
        let groupDragItems = [];
        const wantsGroupDrag = (multiTaskIds.length + multiNoteIds.length > 1) && multiNoteIds.includes(id);
        if (wantsGroupDrag) {
            const uniqTaskIds = Array.from(new Set(multiTaskIds));
            const uniqNoteIds = Array.from(new Set(multiNoteIds));
            const taskItems = uniqTaskIds.map((tid) => {
                const cardEl = state.modal?.querySelector?.(`.tm-whiteboard-card[data-task-id="${CSS.escape(tid)}"]`);
                if (!(cardEl instanceof HTMLElement)) return null;
                if (cardEl.classList.contains('tm-whiteboard-node--sub')) return null;
                const sx0 = Number(cardEl.dataset?.x);
                const sy0 = Number(cardEl.dataset?.y);
                const tx0 = Number.isFinite(sx0) ? sx0 : Number((cardEl.style.left || '').replace('px', '')) || 0;
                const ty0 = Number.isFinite(sy0) ? sy0 : Number((cardEl.style.top || '').replace('px', '')) || 0;
                const tdid = String(cardEl.getAttribute('data-doc-id') || '').trim();
                if (!tdid) return null;
                return { kind: 'task', id: tid, did: tdid, el: cardEl, x0: tx0, y0: ty0 };
            }).filter(Boolean);
            const noteItems = uniqNoteIds.map((nid) => {
                const nEl = state.modal?.querySelector?.(`.tm-whiteboard-note[data-note-id="${CSS.escape(nid)}"]`);
                if (!(nEl instanceof HTMLElement)) return null;
                const nx0 = Number((nEl.style.left || '').replace('px', '')) || 0;
                const ny0 = Number((nEl.style.top || '').replace('px', '')) || 0;
                const ndid = String(nEl.getAttribute('data-doc-id') || '').trim();
                if (!ndid) return null;
                return { kind: 'note', id: nid, did: ndid, el: nEl, x0: nx0, y0: ny0 };
            }).filter(Boolean);
            groupDragItems = taskItems.concat(noteItems);
        }
        const useGroupDrag = groupDragItems.length > 1;
        if (!useGroupDrag) {
            __tmClearWhiteboardMultiSelection();
            state.whiteboardSelectedNoteId = id;
            state.whiteboardSelectedTaskId = '';
            __tmApplyWhiteboardCardSelectionDom('');
            state.whiteboardSelectedLinkId = '';
            state.whiteboardSelectedLinkDocId = '';
        } else {
            state.whiteboardSelectedTaskId = '';
            state.whiteboardSelectedNoteId = '';
            state.whiteboardSelectedLinkId = '';
            state.whiteboardSelectedLinkDocId = '';
            __tmApplyWhiteboardCardSelectionDom('');
            __tmApplyWhiteboardMultiSelectionDom();
            __tmRenderWhiteboardMultiTools(__tmComputeWhiteboardMultiSelectionRect());
        }
        state.whiteboardNoteDrag = { id, did, x0, y0, sx, sy, noteEl, moved: false, group: useGroupDrag ? groupDragItems : null };
        const onMove = (e2) => {
            const d = state.whiteboardNoteDrag;
            if (!d) return;
            const dx = ((Number(e2?.clientX) || 0) - d.sx) / (zoom || 1);
            const dy = ((Number(e2?.clientY) || 0) - d.sy) / (zoom || 1);
            if (!d.moved) {
                if (Math.abs(dx) + Math.abs(dy) < 3) return;
                d.moved = true;
            }
            if (Array.isArray(d.group) && d.group.length > 1) {
                d.group.forEach((g) => {
                    if (!g || !(g.el instanceof HTMLElement)) return;
                    const nx = Math.round(Number(g.x0 || 0) + dx);
                    const ny = Math.round(Number(g.y0 || 0) + dy);
                    g.el.style.left = `${nx}px`;
                    g.el.style.top = `${ny}px`;
                    if (g.kind === 'task') {
                        g.el.dataset.x = String(nx);
                        g.el.dataset.y = String(ny);
                        __tmSetWhiteboardNodePos(g.id, g.did, nx, ny, { persist: false, manual: true });
                        __tmSetWhiteboardTaskPlaced(g.id, true, { persist: false });
                    }
                });
                __tmScheduleWhiteboardEdgeRedraw();
                __tmRenderWhiteboardMultiTools(__tmComputeWhiteboardMultiSelectionRect());
                return;
            }
            const nx = Math.round(d.x0 + dx);
            const ny = Math.round(d.y0 + dy);
            d.noteEl.style.left = `${nx}px`;
            d.noteEl.style.top = `${ny}px`;
        };
        const onUp = async () => {
            try { document.removeEventListener('mousemove', onMove, true); } catch (e) {}
            try { document.removeEventListener('mouseup', onUp, true); } catch (e) {}
            const d = state.whiteboardNoteDrag;
            state.whiteboardNoteDrag = null;
            if (!d) return;
            if (!d.moved) {
                __tmScheduleWhiteboardEdgeRedraw();
                render();
                return;
            }
            if (Array.isArray(d.group) && d.group.length > 1) {
                const notes = Array.isArray(SettingsStore.data.whiteboardNotes) ? [...SettingsStore.data.whiteboardNotes] : [];
                const allView = !(state.activeDocId && state.activeDocId !== 'all');
                d.group.forEach((g) => {
                    if (!g || g.kind !== 'note' || !(g.el instanceof HTMLElement)) return;
                    const nx = Number((g.el.style.left || '').replace('px', '')) || Number(g.x0 || 0);
                    const ny = Number((g.el.style.top || '').replace('px', '')) || Number(g.y0 || 0);
                    const idx = notes.findIndex((n) => String(n?.id || '').trim() === String(g.id || '').trim());
                    if (idx < 0) return;
                    const offX = allView ? (Number(g.el.parentElement?.dataset?.frameOffsetX) || 0) : 0;
                    const offY = allView ? (Number(g.el.parentElement?.dataset?.frameOffsetY) || 0) : 0;
                    notes[idx] = { ...(notes[idx] || {}), docId: g.did, x: Math.round(nx - offX), y: Math.round(ny - offY) };
                });
                SettingsStore.data.whiteboardNotes = notes;
                try { SettingsStore.syncToLocal(); } catch (e) {}
                try { await SettingsStore.save(); } catch (e) {}
                render();
                return;
            }
            const nx = Number(d.noteEl.style.left.replace('px', '')) || d.x0;
            const ny = Number(d.noteEl.style.top.replace('px', '')) || d.y0;
            const notes = Array.isArray(SettingsStore.data.whiteboardNotes) ? [...SettingsStore.data.whiteboardNotes] : [];
            const idx = notes.findIndex((n) => String(n?.id || '').trim() === d.id);
            if (idx >= 0) {
                const allView = !(state.activeDocId && state.activeDocId !== 'all');
                const offX = allView ? (Number(d.noteEl.parentElement?.dataset?.frameOffsetX) || 0) : 0;
                const offY = allView ? (Number(d.noteEl.parentElement?.dataset?.frameOffsetY) || 0) : 0;
                notes[idx] = { ...(notes[idx] || {}), docId: d.did, x: Math.round(nx - offX), y: Math.round(ny - offY) };
                SettingsStore.data.whiteboardNotes = notes;
                try { SettingsStore.syncToLocal(); } catch (e) {}
                try { await SettingsStore.save(); } catch (e) {}
            }
            render();
        };
        try { document.addEventListener('mousemove', onMove, true); } catch (e) {}
        try { document.addEventListener('mouseup', onUp, true); } catch (e) {}
        try { ev?.stopPropagation?.(); } catch (e) {}
    };

    window.tmWhiteboardNoteResizeStart = function(ev, noteId, docId) {
        if (state.viewMode !== 'whiteboard') return;
        if (Number(ev?.button) !== 0) return;
        try { ev?.stopPropagation?.(); } catch (e) {}
        try { ev?.preventDefault?.(); } catch (e) {}
        const id = String(noteId || '').trim();
        const did = String(docId || '').trim();
        if (!id || !did) return;
        const handle = ev?.currentTarget instanceof HTMLElement ? ev.currentTarget : null;
        const noteEl = (handle && handle.closest('.tm-whiteboard-note')) || (ev?.target?.closest?.('.tm-whiteboard-note'));
        if (!(noteEl instanceof HTMLElement)) return;
        const notes = Array.isArray(SettingsStore.data.whiteboardNotes) ? SettingsStore.data.whiteboardNotes : [];
        const note = notes.find((n) => String(n?.id || '').trim() === id);
        const startFont = __tmNormalizeWhiteboardNoteFontSize(note?.fontSize);
        const sx = Number(ev?.clientX) || 0;
        const sy = Number(ev?.clientY) || 0;
        noteEl.style.fontSize = `${startFont}px`;
        const onMove = (e2) => {
            const dx = (Number(e2?.clientX) || 0) - sx;
            const dy = (Number(e2?.clientY) || 0) - sy;
            const next = __tmNormalizeWhiteboardNoteFontSize(startFont + Math.round((dx + dy) / 12));
            noteEl.style.fontSize = `${next}px`;
            state.whiteboardNoteResize = { noteId: id, docId: did, fontSize: next };
        };
        const onUp = async () => {
            try { document.removeEventListener('mousemove', onMove, true); } catch (e) {}
            try { document.removeEventListener('mouseup', onUp, true); } catch (e) {}
            const st = (state.whiteboardNoteResize && String(state.whiteboardNoteResize.noteId || '').trim() === id)
                ? state.whiteboardNoteResize
                : null;
            state.whiteboardNoteResize = null;
            const next = __tmNormalizeWhiteboardNoteFontSize(st?.fontSize ?? startFont);
            await __tmUpdateWhiteboardNoteStyle(id, { fontSize: next });
            state.whiteboardSelectedNoteId = id;
            render();
        };
        try { document.addEventListener('mousemove', onMove, true); } catch (e) {}
        try { document.addEventListener('mouseup', onUp, true); } catch (e) {}
    };

    window.tmWhiteboardNoteResizeWidthStart = function(ev, noteId, docId) {
        if (state.viewMode !== 'whiteboard') return;
        if (Number(ev?.button) !== 0) return;
        try { ev?.stopPropagation?.(); } catch (e) {}
        try { ev?.preventDefault?.(); } catch (e) {}
        const id = String(noteId || '').trim();
        const did = String(docId || '').trim();
        if (!id || !did) return;
        const handle = ev?.currentTarget instanceof HTMLElement ? ev.currentTarget : null;
        const noteEl = (handle && handle.closest('.tm-whiteboard-note')) || (ev?.target?.closest?.('.tm-whiteboard-note'));
        if (!(noteEl instanceof HTMLElement)) return;
        const startW = __tmNormalizeWhiteboardNoteWidth(Number(noteEl.getBoundingClientRect()?.width) || Number(noteEl.offsetWidth) || 0);
        const sx = Number(ev?.clientX) || 0;
        noteEl.style.width = `${startW}px`;
        noteEl.style.whiteSpace = 'pre-wrap';
        noteEl.style.overflowWrap = 'anywhere';
        const onMove = (e2) => {
            const dx = (Number(e2?.clientX) || 0) - sx;
            const next = __tmNormalizeWhiteboardNoteWidth(startW + dx);
            noteEl.style.width = `${next}px`;
            state.whiteboardNoteWidthResize = { noteId: id, docId: did, width: next };
        };
        const onUp = async () => {
            try { document.removeEventListener('mousemove', onMove, true); } catch (e) {}
            try { document.removeEventListener('mouseup', onUp, true); } catch (e) {}
            const st = (state.whiteboardNoteWidthResize && String(state.whiteboardNoteWidthResize.noteId || '').trim() === id)
                ? state.whiteboardNoteWidthResize
                : null;
            state.whiteboardNoteWidthResize = null;
            const next = __tmNormalizeWhiteboardNoteWidth(st?.width ?? startW);
            await __tmUpdateWhiteboardNoteStyle(id, { width: next });
            state.whiteboardSelectedNoteId = id;
            render();
        };
        try { document.addEventListener('mousemove', onMove, true); } catch (e) {}
        try { document.addEventListener('mouseup', onUp, true); } catch (e) {}
    };

    async function __tmCloseWhiteboardNoteEditor(opts = {}) {
        const o = (opts && typeof opts === 'object') ? opts : {};
        const st = state.whiteboardNoteEditor;
        state.whiteboardNoteEditor = null;
        if (!st || typeof st !== 'object') return;
        const el = st.el;
        const did = String(st.docId || '').trim();
        const noteId = String(st.noteId || '').trim();
        const x = Number(st.x);
        const y = Number(st.y);
        const ox = Number(st.offsetX) || 0;
        const oy = Number(st.offsetY) || 0;
        const fs = __tmNormalizeWhiteboardNoteFontSize(st.fontSize);
        const c = __tmNormalizeWhiteboardNoteColor(st.color) || '';
        const bd = __tmNormalizeWhiteboardNoteBold(st.bold);
        let value = '';
        try { value = String(el?.value || '').trim(); } catch (e) {}
        try { el?.remove?.(); } catch (e) {}
        if (!o.save) return;
        if (!did || !Number.isFinite(x) || !Number.isFinite(y)) return;
        const allView = !(state.activeDocId && state.activeDocId !== 'all');
        const sx = Math.round(x - (allView ? ox : 0));
        const sy = Math.round(y - (allView ? oy : 0));
        const notes0 = Array.isArray(SettingsStore.data.whiteboardNotes) ? [...SettingsStore.data.whiteboardNotes] : [];
        if (noteId) {
            const idx = notes0.findIndex((n) => String(n?.id || '').trim() === noteId);
            if (idx < 0 || !value) return;
            notes0[idx] = {
                ...(notes0[idx] || {}),
                docId: did,
                text: value,
                x: sx,
                y: sy,
                fontSize: fs,
                color: c,
                bold: bd,
                updatedAt: String(Date.now()),
            };
            SettingsStore.data.whiteboardNotes = notes0;
            try { SettingsStore.syncToLocal(); } catch (e) {}
            try { await SettingsStore.save(); } catch (e) {}
            render();
            return;
        }
        if (!value) return;
        const notes = Array.isArray(SettingsStore.data.whiteboardNotes) ? [...SettingsStore.data.whiteboardNotes] : [];
        notes.push({
            id: `note_${Date.now()}_${Math.random().toString(36).slice(2, 7)}`,
            docId: did,
            text: value,
            x: sx,
            y: sy,
            fontSize: fs,
            color: c,
            bold: bd,
            createdAt: String(Date.now()),
        });
        SettingsStore.data.whiteboardNotes = notes;
        try { SettingsStore.syncToLocal(); } catch (e) {}
        try { await SettingsStore.save(); } catch (e) {}
        render();
    }

    function __tmOpenWhiteboardNoteEditor(docBody, docId, x, y, opts = {}) {
        const o = (opts && typeof opts === 'object') ? opts : {};
        const bodyEl = docBody instanceof HTMLElement ? docBody : null;
        const did = String(docId || '').trim();
        if (!bodyEl || !did) return;
        const noteId = String(o.noteId || '').trim();
        const baseX = Math.round(Number(x) || 24);
        const baseY = Math.round(Number(y) || 24);
        const nx = baseX;
        const ny = baseY;
        const initialText = String(o.text || '');
        __tmCloseWhiteboardNoteEditor({ save: false });
        const input = document.createElement('textarea');
        input.className = 'tm-whiteboard-note-editor';
        input.style.left = `${nx}px`;
        input.style.top = `${ny}px`;
        const c0 = __tmNormalizeWhiteboardNoteColor(o.color) || '';
        const fs0 = __tmNormalizeWhiteboardNoteFontSize(o.fontSize);
        const bd0 = __tmNormalizeWhiteboardNoteBold(o.bold);
        if (c0) input.style.color = c0;
        input.style.fontSize = `${fs0}px`;
        input.style.fontWeight = bd0 ? '700' : '400';
        input.placeholder = '输入文字，Enter保存，Esc取消';
        input.value = initialText;
        input.addEventListener('mousedown', (e) => {
            try { e.stopPropagation(); } catch (err) {}
        });
        input.addEventListener('click', (e) => {
            try { e.stopPropagation(); } catch (err) {}
        });
        input.addEventListener('keydown', async (e) => {
            if (e.key === 'Escape') {
                try { e.preventDefault(); } catch (err) {}
                try { e.stopPropagation(); } catch (err) {}
                await __tmCloseWhiteboardNoteEditor({ save: false });
                return;
            }
            if (e.key === 'Enter' && !e.shiftKey) {
                try { e.preventDefault(); } catch (err) {}
                try { e.stopPropagation(); } catch (err) {}
                await __tmCloseWhiteboardNoteEditor({ save: true });
            }
        });
        input.addEventListener('blur', async () => {
            await __tmCloseWhiteboardNoteEditor({ save: true });
        });
        bodyEl.appendChild(input);
        try { input.focus(); } catch (e) {}
        try { input.setSelectionRange(input.value.length, input.value.length); } catch (e) {}
        state.whiteboardNoteEditor = {
            el: input,
            docId: did,
            noteId,
            x: nx,
            y: ny,
            offsetX: Number(o.offsetX) || 0,
            offsetY: Number(o.offsetY) || 0,
            fontSize: fs0,
            color: c0,
            bold: bd0,
        };
    }

    window.tmWhiteboardDocClick = async function(ev, docId) {
        const allView = !(state.activeDocId && state.activeDocId !== 'all');
        if (allView) return;
        if (String(SettingsStore.data.whiteboardTool || 'pan') !== 'text') return;
        const target = ev?.target;
        if (target && target.closest && target.closest('.tm-whiteboard-node,.tm-task-link-dot,.tm-task-checkbox,.tm-btn,.tm-task-content-clickable,.tm-whiteboard-note,.tm-whiteboard-note-editor')) return;
        const did = String(docId || '').trim();
        if (!did) return;
        const docBody = target?.closest?.('.tm-whiteboard-doc-body[data-doc-id]')
            || state.modal?.querySelector?.(`.tm-whiteboard-doc-body[data-doc-id="${CSS.escape(did)}"]`);
        if (!(docBody instanceof HTMLElement)) return;
        const p = __tmResolveWhiteboardPointerInfo(ev, did);
        const localX = Number.isFinite(Number(p?.localX)) ? Number(p.localX) : 24;
        const localY = Number.isFinite(Number(p?.localY)) ? Number(p.localY) : 24;
        __tmOpenWhiteboardNoteEditor(docBody, did, localX, localY);
    };

    window.tmWhiteboardBoardClick = async function(ev) {
        if (Number(state.whiteboardSuppressClickUntil || 0) > Date.now()) return;
        const target = ev?.target;
        if (target && target.closest && target.closest('.tm-whiteboard-node,.tm-task-link-dot,.tm-task-checkbox,.tm-btn,.tm-task-content-clickable,.tm-whiteboard-note,.tm-whiteboard-note-editor,.tm-whiteboard-edge,.tm-whiteboard-doc-resize,.tm-whiteboard-link-tools,.tm-whiteboard-multi-tools')) return;
        if (state.whiteboardNoteEditor && String(SettingsStore.data.whiteboardTool || 'pan') === 'text') {
            await __tmCloseWhiteboardNoteEditor({ save: true });
            return;
        }
        let changed = false;
        if (String(state.whiteboardSelectedLinkId || '').trim()) {
            state.whiteboardSelectedLinkId = '';
            state.whiteboardSelectedLinkDocId = '';
            __tmScheduleWhiteboardEdgeRedraw();
            changed = true;
        }
        if (String(state.whiteboardSelectedNoteId || '').trim()) {
            state.whiteboardSelectedNoteId = '';
            changed = true;
        }
        if ((Array.isArray(state.whiteboardMultiSelectedTaskIds) && state.whiteboardMultiSelectedTaskIds.length)
            || (Array.isArray(state.whiteboardMultiSelectedNoteIds) && state.whiteboardMultiSelectedNoteIds.length)) {
            __tmClearWhiteboardMultiSelection();
            changed = true;
        }
        if (String(state.whiteboardSelectedTaskId || '').trim()) {
            state.whiteboardSelectedTaskId = '';
            __tmApplyWhiteboardCardSelectionDom('');
            changed = true;
            if (String(SettingsStore.data.whiteboardTool || 'pan') !== 'text') {
                render();
                return;
            }
        } else if (String(SettingsStore.data.whiteboardTool || 'pan') !== 'text') {
            if (changed) render();
            return;
        }
        const docBody = target?.closest?.('.tm-whiteboard-doc-body[data-doc-id]');
        if (docBody instanceof Element) {
            const docId = String(docBody.getAttribute('data-doc-id') || '').trim();
            if (docId) return window.tmWhiteboardDocClick(ev, docId);
        }
        const selectedDoc = (state.activeDocId && state.activeDocId !== 'all') ? String(state.activeDocId) : '';
        const firstDoc = selectedDoc || String((SettingsStore.data.selectedDocIds || [])[0] || '').trim();
        if (!firstDoc) return;
        return window.tmWhiteboardDocClick(ev, firstDoc);
    };

    window.tmWhiteboardBoardDblClick = async function(ev) {
        const allView = !(state.activeDocId && state.activeDocId !== 'all');
        if (allView) return;
        const target = ev?.target;
        if (target && target.closest && target.closest('.tm-whiteboard-node,.tm-task-link-dot,.tm-task-checkbox,.tm-btn,.tm-task-content-clickable,.tm-whiteboard-note,.tm-whiteboard-note-editor,.tm-whiteboard-edge,.tm-whiteboard-doc-resize,.tm-whiteboard-link-tools,.tm-whiteboard-multi-tools,input,button,select,textarea,label,a')) return;
        const did = String(state.activeDocId || '').trim();
        if (!did || did === 'all') return;
        const point = __tmResolveWhiteboardPointerInfo(ev, did);
        const localX = Number.isFinite(Number(point?.localX)) ? Number(point.localX) : 24;
        const localY = Number.isFinite(Number(point?.localY)) ? Number(point.localY) : 56;
        const newContent = await (async () => {
            const cx = Number(ev?.clientX) || 0;
            const cy = Number(ev?.clientY) || 0;
            const anchor = document.createElement('div');
            anchor.style.position = 'fixed';
            anchor.style.left = `${Math.round(cx)}px`;
            anchor.style.top = `${Math.round(cy)}px`;
            anchor.style.width = '1px';
            anchor.style.height = '1px';
            anchor.style.pointerEvents = 'none';
            anchor.style.opacity = '0';
            document.body.appendChild(anchor);
            return await new Promise((resolve) => {
                let settled = false;
                const finish = (v, forceEmpty = false) => {
                    if (settled) return;
                    settled = true;
                    try { anchor.remove(); } catch (e) {}
                    resolve(forceEmpty ? '' : String(v || '').trim());
                };
                __tmOpenInlineEditor(anchor, ({ editor, close, onCleanup }) => {
                    editor.style.minWidth = '220px';
                    editor.style.padding = '8px';
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.placeholder = '输入任务名称（留空取消）';
                    input.value = '';
                    input.style.width = '100%';
                    editor.appendChild(input);
                    const commit = () => {
                        const v = String(input.value || '').trim();
                        finish(v, !v);
                        close();
                    };
                    const cancel = () => {
                        finish('', true);
                        close();
                    };
                    const { wrap } = __tmBuildActions('创建', commit, cancel);
                    editor.appendChild(wrap);
                    input.onkeydown = (e) => {
                        if (e.key === 'Enter') commit();
                        if (e.key === 'Escape') cancel();
                    };
                    onCleanup(() => {
                        if (!settled) finish('', true);
                    });
                });
            });
        })();
        if (!newContent) return;
        try {
            const createdTaskId = await __tmCreateTaskInDoc({
                docId: did,
                content: newContent,
                atTop: true,
            });
            if (!createdTaskId) throw new Error('任务创建失败');
            __tmSetWhiteboardTaskPlaced(createdTaskId, true, { persist: false });
            __tmSetWhiteboardNodePos(createdTaskId, did, localX, localY, { manual: true, persist: false });
            try { SettingsStore.syncToLocal(); } catch (e) {}
            try { await SettingsStore.save(); } catch (e) {}
            state.whiteboardSelectedTaskId = createdTaskId;
            __tmApplyWhiteboardCardSelectionDom(createdTaskId);
            applyFilters();
            render();
        } catch (e) {
            try { hint(`❌ 新建失败，已撤销: ${e?.message || String(e)}`, 'error'); } catch (e2) {}
        }
    };

    function __tmCleanupWhiteboardPoolDragGhost() {
        const el = state.whiteboardPoolDragGhostEl;
        state.whiteboardPoolDragGhostEl = null;
        if (!(el instanceof HTMLElement)) return;
        try { el.remove(); } catch (e) {}
    }

    function __tmBuildWhiteboardPoolDragGhostFromDom(dragItemEl, opts = {}) {
        const item = dragItemEl instanceof HTMLElement ? dragItemEl : null;
        if (!item) return null;
        const o = (opts && typeof opts === 'object') ? opts : {};
        const useSelf = !!o.useSelf;
        const node = useSelf ? item : (item.parentElement instanceof HTMLElement ? item.parentElement : item);
        let ghost = null;
        try { ghost = node.cloneNode(true); } catch (e) { ghost = null; }
        if (!(ghost instanceof HTMLElement)) return null;
        ghost.style.position = 'fixed';
        ghost.style.left = '-9999px';
        ghost.style.top = '-9999px';
        ghost.style.maxWidth = '420px';
        ghost.style.pointerEvents = 'none';
        ghost.style.zIndex = '-1';
        ghost.style.opacity = '0.95';
        try { document.body.appendChild(ghost); } catch (e) {}
        state.whiteboardPoolDragGhostEl = ghost;
        return ghost;
    }

    function __tmBuildWhiteboardPoolH2DragGhost(h2El, taskIds) {
        const titleEl = h2El instanceof HTMLElement ? h2El : null;
        const ids = Array.isArray(taskIds) ? taskIds.map((x) => String(x || '').trim()).filter(Boolean) : [];
        if (!titleEl || !ids.length) return null;
        const wrap = document.createElement('div');
        wrap.style.position = 'fixed';
        wrap.style.left = '-9999px';
        wrap.style.top = '-9999px';
        wrap.style.maxWidth = '420px';
        wrap.style.maxHeight = '360px';
        wrap.style.overflow = 'hidden';
        wrap.style.pointerEvents = 'none';
        wrap.style.zIndex = '-1';
        wrap.style.opacity = '0.95';
        wrap.style.border = '1px solid var(--tm-border-color)';
        wrap.style.borderRadius = '8px';
        wrap.style.background = 'var(--tm-bg-color)';
        wrap.style.padding = '6px';
        try {
            const h2Clone = titleEl.cloneNode(true);
            if (h2Clone instanceof HTMLElement) {
                h2Clone.style.cursor = 'grabbing';
                h2Clone.style.marginBottom = '4px';
                wrap.appendChild(h2Clone);
            }
        } catch (e) {}
        const pool = state.modal?.querySelector?.('.tm-whiteboard-sidebar');
        ids.forEach((tid) => {
            try {
                const src = pool?.querySelector?.(`.tm-whiteboard-pool-item[data-task-id="${CSS.escape(tid)}"]`);
                if (!(src instanceof HTMLElement)) return;
                const clone = src.cloneNode(true);
                if (!(clone instanceof HTMLElement)) return;
                clone.style.marginTop = '4px';
                wrap.appendChild(clone);
            } catch (e) {}
        });
        try { document.body.appendChild(wrap); } catch (e) {}
        state.whiteboardPoolDragGhostEl = wrap;
        return wrap;
    }

    function __tmBuildWhiteboardPoolMultiDragGhost(taskIds, fallbackEl) {
        const ids = Array.isArray(taskIds) ? taskIds.map((x) => String(x || '').trim()).filter(Boolean) : [];
        if (!ids.length) return __tmBuildWhiteboardPoolDragGhostFromDom(fallbackEl);
        const wrap = document.createElement('div');
        wrap.style.position = 'fixed';
        wrap.style.left = '-9999px';
        wrap.style.top = '-9999px';
        wrap.style.maxWidth = '420px';
        wrap.style.maxHeight = '360px';
        wrap.style.overflow = 'hidden';
        wrap.style.pointerEvents = 'none';
        wrap.style.zIndex = '-1';
        wrap.style.opacity = '0.95';
        wrap.style.border = '1px solid var(--tm-border-color)';
        wrap.style.borderRadius = '8px';
        wrap.style.background = 'var(--tm-bg-color)';
        wrap.style.padding = '6px';
        const pool = state.modal?.querySelector?.('.tm-whiteboard-sidebar');
        const maxPreview = 10;
        const pickIds = ids.slice(0, maxPreview);
        pickIds.forEach((tid) => {
            try {
                const src = pool?.querySelector?.(`.tm-whiteboard-pool-item[data-task-id="${CSS.escape(tid)}"]`);
                if (!(src instanceof HTMLElement)) return;
                const clone = src.cloneNode(true);
                if (!(clone instanceof HTMLElement)) return;
                clone.style.marginTop = '4px';
                wrap.appendChild(clone);
            } catch (e) {}
        });
        if (!wrap.childElementCount) return __tmBuildWhiteboardPoolDragGhostFromDom(fallbackEl);
        if (ids.length > maxPreview) {
            const more = document.createElement('div');
            more.style.marginTop = '6px';
            more.style.fontSize = '12px';
            more.style.color = 'var(--tm-secondary-text)';
            more.textContent = `... 还有 ${ids.length - maxPreview} 项`;
            wrap.appendChild(more);
        }
        try { document.body.appendChild(wrap); } catch (e) {}
        state.whiteboardPoolDragGhostEl = wrap;
        return wrap;
    }

    window.tmWhiteboardPoolItemMouseDown = function(ev, taskId, docId, locked) {
        if (Number(ev?.button) !== 0) return;
        const target = ev?.target;
        if (target && target.closest && target.closest('.tm-task-checkbox,.tm-task-content-clickable,.tm-whiteboard-pool-toggle,.tm-btn,input,button,select,textarea,label,a')) return;
        const id = String(taskId || '').trim();
        if (!id) return;
        const isLocked = !!locked;
        if (isLocked) return;
        try { ev?.stopPropagation?.(); } catch (e) {}
        const current = Array.isArray(state.whiteboardPoolSelectedTaskIds) ? state.whiteboardPoolSelectedTaskIds : [];
        const set = new Set(current.map((x) => String(x || '').trim()).filter(Boolean));
        const withModifier = !!(ev?.ctrlKey || ev?.metaKey);
        if (withModifier) {
            if (set.has(id)) set.delete(id);
            else set.add(id);
        } else {
            // 已多选且点中选中项时，保持多选，便于直接整体拖拽
            if (!(set.size > 1 && set.has(id))) {
                set.clear();
                set.add(id);
            }
        }
        state.whiteboardPoolSelectedTaskIds = Array.from(set);
        render();
    };

    window.tmWhiteboardPoolH2DragStart = function(ev, docId, h2Label) {
        const did = String(docId || '').trim();
        const h2 = String(h2Label || '').trim();
        const el = ev?.currentTarget instanceof HTMLElement ? ev.currentTarget : null;
        if (!did || !h2 || !(el instanceof HTMLElement)) return;
        const rawIds = String(el.getAttribute('data-task-ids') || '').trim();
        let taskIds = rawIds ? rawIds.split(',').map((x) => String(x || '').trim()).filter(Boolean) : [];
        if (!taskIds.length) return;
        const canDrag = (tid) => {
            const node = state.modal?.querySelector?.(`.tm-whiteboard-pool-item[data-task-id="${CSS.escape(String(tid || '').trim())}"]`);
            if (!(node instanceof HTMLElement)) return false;
            return String(node.getAttribute('draggable') || '').toLowerCase() !== 'false';
        };
        taskIds = taskIds.filter((tid) => canDrag(tid));
        if (!taskIds.length) return;
        state.whiteboardPoolSelectedTaskIds = taskIds.slice();
        state.draggingTaskId = taskIds[0];
        state.whiteboardPoolDragStart = {
            clientX: Number(ev?.clientX) || 0,
            clientY: Number(ev?.clientY) || 0,
            docId: did,
            taskIds: taskIds.slice(),
            h2,
            at: Date.now(),
        };
        try {
            const taskDocIds = {};
            taskIds.forEach((tid) => {
                const tdid = String(__tmGetTaskDocIdById(tid) || '').trim();
                if (tdid) taskDocIds[tid] = tdid;
            });
            const payload = JSON.stringify({ type: 'tm-whiteboard-pool-h2', taskIds: taskIds.slice(), docId: did, h2, taskDocIds });
            ev.dataTransfer.effectAllowed = 'move';
            ev.dataTransfer.setData('application/x-tm-task-id', taskIds[0]);
            ev.dataTransfer.setData('application/x-tm-whiteboard-pool', payload);
            ev.dataTransfer.setData('text/plain', payload);
            __tmCleanupWhiteboardPoolDragGhost();
            const dragGhost = __tmBuildWhiteboardPoolH2DragGhost(el, taskIds) || __tmBuildWhiteboardPoolDragGhostFromDom(el, { useSelf: true });
            if (dragGhost instanceof HTMLElement) {
                try { ev.dataTransfer.setDragImage(dragGhost, 12, 12); } catch (e) {}
            }
        } catch (e) {}
        __tmStartWhiteboardPoolGlobalTracking(String(state.activeDocId && state.activeDocId !== 'all' ? state.activeDocId : ''));
    };

    window.tmWhiteboardPoolDragStart = function(ev, taskId, docId) {
        const id = String(taskId || '').trim();
        const did = String(docId || '').trim();
        if (!id || !did) return;
        const selected0 = Array.isArray(state.whiteboardPoolSelectedTaskIds) ? state.whiteboardPoolSelectedTaskIds : [];
        const selectedSet = new Set(selected0.map((x) => String(x || '').trim()).filter(Boolean));
        let dragTaskIds = selectedSet.has(id) ? Array.from(selectedSet) : [id];
        if (!dragTaskIds.length) dragTaskIds = [id];
        const canDrag = (tid) => {
            const el = state.modal?.querySelector?.(`.tm-whiteboard-pool-item[data-task-id="${CSS.escape(String(tid || '').trim())}"]`);
            if (!(el instanceof HTMLElement)) return false;
            return String(el.getAttribute('draggable') || '').toLowerCase() !== 'false';
        };
        dragTaskIds = dragTaskIds.filter((tid) => canDrag(tid));
        if (!dragTaskIds.includes(id)) dragTaskIds.unshift(id);
        dragTaskIds = Array.from(new Set(dragTaskIds));
        if (!dragTaskIds.length) dragTaskIds = [id];
        state.whiteboardPoolSelectedTaskIds = dragTaskIds.slice();
        state.draggingTaskId = dragTaskIds[0] || id;
        state.whiteboardPoolDragStart = {
            clientX: Number(ev?.clientX) || 0,
            clientY: Number(ev?.clientY) || 0,
            docId: did,
            taskIds: dragTaskIds.slice(),
            at: Date.now(),
        };
        try {
            const taskDocIds = {};
            dragTaskIds.forEach((tid) => {
                const tdid = String(__tmGetTaskDocIdById(tid) || '').trim();
                if (tdid) taskDocIds[tid] = tdid;
            });
            const payload = JSON.stringify({ type: 'tm-whiteboard-pool', taskId: id, taskIds: dragTaskIds, docId: did, taskDocIds });
            ev.dataTransfer.effectAllowed = 'move';
            ev.dataTransfer.setData('application/x-tm-task-id', dragTaskIds[0] || id);
            ev.dataTransfer.setData('application/x-tm-whiteboard-pool', payload);
            ev.dataTransfer.setData('text/plain', payload);
            __tmCleanupWhiteboardPoolDragGhost();
            const dragGhost = dragTaskIds.length > 1
                ? __tmBuildWhiteboardPoolMultiDragGhost(dragTaskIds, ev?.currentTarget)
                : __tmBuildWhiteboardPoolDragGhostFromDom(ev?.currentTarget);
            if (dragGhost instanceof HTMLElement) {
                try { ev.dataTransfer.setDragImage(dragGhost, 12, 12); } catch (e) {}
            }
        } catch (e) {}
        __tmStartWhiteboardPoolGlobalTracking(String(state.activeDocId && state.activeDocId !== 'all' ? state.activeDocId : ''));
    };

    window.tmWhiteboardPoolDrag = function(ev, docIdHint) {
        __tmTrackWhiteboardPointerFromClient(ev?.clientX, ev?.clientY, String(docIdHint || state.activeDocId || ''));
    };

    window.tmWhiteboardPoolDragEnd = function() {
        state.draggingTaskId = '';
        __tmStopWhiteboardPoolGlobalTracking();
        __tmCleanupWhiteboardPoolDragGhost();
        state.whiteboardPoolDragStart = null;
        state.whiteboardLastBoardLocal = null;
        state.whiteboardLastBoardPointer = null;
    };

    window.tmWhiteboardBoardDragOver = function(ev) {
        try { ev?.preventDefault?.(); } catch (e) {}
        const info = __tmResolveWhiteboardPointerInfo(ev, String(state.activeDocId && state.activeDocId !== 'all' ? state.activeDocId : ''))
            || __tmTrackWhiteboardPointerFromClient(ev?.clientX, ev?.clientY, String(state.activeDocId && state.activeDocId !== 'all' ? state.activeDocId : ''));
        const docId = String(info?.docId || state.whiteboardLinkFromDocId || '').trim();
        if (info && 'clientX' in info) {
            state.whiteboardLastBoardPointer = {
                clientX: info.clientX,
                clientY: info.clientY,
                docId: info.docId,
                at: info.at,
            };
            state.whiteboardLastBoardLocal = {
                docId: info.docId,
                x: info.localX,
                y: info.localY,
                at: info.at,
            };
        }
        if (!String(state.whiteboardLinkFromTaskId || '').trim()) return;
        let hoverTaskId = '';
        let hoverDocId = '';
        try {
            const hit = document.elementFromPoint(Number(ev?.clientX) || 0, Number(ev?.clientY) || 0);
            const node = hit?.closest?.('.tm-whiteboard-node[data-task-id][data-doc-id]');
            if (node instanceof Element) {
                hoverTaskId = String(node.getAttribute('data-task-id') || '').trim();
                hoverDocId = String(node.getAttribute('data-doc-id') || '').trim();
            }
        } catch (e) {}
        if (hoverTaskId && hoverDocId) {
            __tmUpdateWhiteboardLinkHover(hoverTaskId, hoverDocId);
            __tmUpdateWhiteboardLinkPreviewFromEvent(ev, hoverTaskId, hoverDocId);
        } else {
            __tmUpdateWhiteboardLinkHover('', '');
            __tmUpdateWhiteboardLinkPreviewFromEvent(ev, '', docId);
        }
        if (state.viewMode === 'timeline') {
            try { state.__tmTimelineRenderDeps?.(); } catch (e) {}
        } else {
            __tmScheduleWhiteboardEdgeRedraw();
        }
    };

    function __tmResolveWhiteboardDropLocalPoint(ev, docId) {
        const did = String(docId || '').trim();
        if (!did) return null;
        const freshMs = 1800;
        const now = Date.now();
        const lastLocal = state.whiteboardLastBoardLocal;
        if (lastLocal && typeof lastLocal === 'object'
            && String(lastLocal.docId || '').trim() === did
            && Number.isFinite(Number(lastLocal.x))
            && Number.isFinite(Number(lastLocal.y))
            && (now - Number(lastLocal.at || 0)) < freshMs) {
            return { x: Number(lastLocal.x), y: Number(lastLocal.y) };
        }
        const info = __tmResolveWhiteboardPointerInfo(ev, did)
            || __tmTrackWhiteboardPointerFromClient(ev?.clientX, ev?.clientY, did);
        if (info && Number.isFinite(Number(info.localX)) && Number.isFinite(Number(info.localY))) {
            return { x: Number(info.localX), y: Number(info.localY) };
        }
        return null;
    }

    window.tmWhiteboardBoardDrop = async function(ev, docIdHint) {
        try { ev?.preventDefault?.(); } catch (e) {}
        try { ev?.stopPropagation?.(); } catch (e) {}
        try {
            const rawLink = ev?.dataTransfer?.getData?.('application/x-tm-task-link') || ev?.dataTransfer?.getData?.('text/plain');
            if (rawLink) {
                const obj = JSON.parse(rawLink);
                if (String(obj?.type || '').trim() === 'tm-task-link') {
                    let toId = '';
                    let toDocId = '';
                    try {
                        const hit = document.elementFromPoint(Number(ev?.clientX) || 0, Number(ev?.clientY) || 0);
                        const node = hit?.closest?.('.tm-whiteboard-node[data-task-id][data-doc-id]');
                        if (node instanceof Element) {
                            toId = String(node.getAttribute('data-task-id') || '').trim();
                            toDocId = String(node.getAttribute('data-doc-id') || '').trim();
                        }
                    } catch (e2) {}
                    if (toId) {
                        await window.tmTaskLinkDotDrop?.(ev, toId, toDocId);
                        return;
                    }
                }
            }
        } catch (e) {}
        let payload = null;
        try {
            const raw = ev?.dataTransfer?.getData?.('application/x-tm-whiteboard-pool') || ev?.dataTransfer?.getData?.('text/plain');
            if (raw) payload = JSON.parse(raw);
        } catch (e) {}
        const payloadType = String(payload?.type || '').trim();
        if (payloadType !== 'tm-whiteboard-pool' && payloadType !== 'tm-whiteboard-pool-h2') return;
        const taskIds = Array.isArray(payload?.taskIds)
            ? payload.taskIds.map((x) => String(x || '').trim()).filter(Boolean)
            : [String(payload?.taskId || '').trim()].filter(Boolean);
        if (!taskIds.length) return;
        const taskIdsSorted = (() => {
            const ids = taskIds.slice();
            try {
                const orderEls = state.modal?.querySelectorAll?.('.tm-whiteboard-pool-item[data-task-id]');
                const orderMap = new Map();
                let idx = 0;
                (orderEls ? Array.from(orderEls) : []).forEach((el) => {
                    const tid = String(el?.getAttribute?.('data-task-id') || '').trim();
                    if (!tid) return;
                    if (!orderMap.has(tid)) orderMap.set(tid, idx++);
                });
                if (orderMap.size <= 0) return ids;
                ids.sort((a, b) => {
                    const ia = orderMap.has(a) ? Number(orderMap.get(a)) : Number.MAX_SAFE_INTEGER;
                    const ib = orderMap.has(b) ? Number(orderMap.get(b)) : Number.MAX_SAFE_INTEGER;
                    if (ia !== ib) return ia - ib;
                    return 0;
                });
            } catch (e) {}
            return ids;
        })();
        const h2Title = (payloadType === 'tm-whiteboard-pool-h2') ? String(payload?.h2 || '').trim() : '';
        const pointDocId = String(docIdHint || '').trim();
        let docId = pointDocId;
        if (!docId) {
            const hitInfo = __tmResolveWhiteboardPointerInfo(ev, '')
                || __tmTrackWhiteboardPointerFromClient(ev?.clientX, ev?.clientY, '');
            docId = String(hitInfo?.docId || '').trim();
        }
        if (!docId) {
            const lastLocal = state.whiteboardLastBoardLocal;
            const freshMs = 1800;
            if (lastLocal && typeof lastLocal === 'object' && (Date.now() - Number(lastLocal.at || 0)) < freshMs) {
                docId = String(lastLocal.docId || '').trim();
            }
        }
        if (!docId) {
            docId = String(state.activeDocId && state.activeDocId !== 'all' ? state.activeDocId : '').trim();
        }
        if (!docId) return;
        const globalCollectDocId = String(SettingsStore.data.newTaskDocId || '').trim();
        const viewport = state.modal?.querySelector?.('#tmWhiteboardViewport');
        const docBody = state.modal?.querySelector?.(`.tm-whiteboard-doc-body[data-doc-id="${CSS.escape(docId)}"]`);
        if (!(viewport instanceof HTMLElement) || !(docBody instanceof HTMLElement)) return;
        // 使用固定锚点，避免卡片尺寸变化（父子结构展开）影响落点体感。
        const anchorX = 18;
        const anchorY = 16;
        const local = __tmResolveWhiteboardDropLocalPoint(ev, docId);
        const docRect = docBody.getBoundingClientRect();
        const zoom = Math.max(0.01, Number(__tmGetWhiteboardView()?.zoom) || 1);
        const fallbackX = (docRect.width > 0 ? (docRect.width * 0.5) : 220) / zoom;
        const fallbackY = (docRect.height > 0 ? (docRect.height * 0.5) : 140) / zoom;
        const nx0 = Math.round((Number(local?.x) || fallbackX) - anchorX);
        const ny = Math.round((Number(local?.y) || fallbackY) - anchorY);
        const stepX = 320;
        let movedAcrossDoc = false;
        const placed = [];
        for (let i = 0; i < taskIdsSorted.length; i++) {
            const taskId = String(taskIdsSorted[i] || '').trim();
            if (!taskId) continue;
            const taskDocFromPayload = String(payload?.taskDocIds?.[taskId] || '').trim();
            const payloadDocId = String(payload?.docId || '').trim();
            const cardDoc = taskDocFromPayload || String(__tmGetTaskDocIdById(taskId) || '').trim() || payloadDocId;
            if (!cardDoc) continue;
            const cardDocName = String((state.allDocuments || []).find(d => String(d?.id || '').trim() === cardDoc)?.name || '').trim();
            const sourceIsInbox = /inbox/i.test(cardDocName) || /收件箱|收集箱|收件/.test(cardDocName);
            const sourceIsGlobalCollect = !!globalCollectDocId && cardDoc === globalCollectDocId;
            if (cardDoc !== docId && !sourceIsInbox && !sourceIsGlobalCollect) continue;
            if (cardDoc !== docId) {
                try {
                    movedAcrossDoc = await __tmMoveTaskToDoc(taskId, docId, { silentHint: true }) || movedAcrossDoc;
                } catch (e) {
                    continue;
                }
            }
            try {
                __tmWhiteboardCollectTaskTreeIds(taskId, { includeRoot: false, includeDetached: true, includeSnapshotTree: true })
                    .forEach((cid) => {
                        __tmSetWhiteboardChildDetached(cid, false);
                        __tmSetWhiteboardTaskPlaced(cid, false, { persist: false });
                    });
            } catch (e) {}
            const nx = nx0 + (i * stepX);
            __tmSetWhiteboardNodePos(taskId, docId, nx, ny, { persist: false, manual: true });
            __tmSetWhiteboardTaskPlaced(taskId, true, { persist: false });
            try {
                const t = state.flatTasks?.[taskId];
                if (t) __tmUpsertWhiteboardTaskSnapshot(t, { persist: false });
            } catch (e) {}
            placed.push(taskId);
        }
        if (!placed.length) return;
        if (h2Title) {
            const notes = Array.isArray(SettingsStore.data.whiteboardNotes) ? [...SettingsStore.data.whiteboardNotes] : [];
            notes.push({
                id: `note_${Date.now()}_${Math.random().toString(36).slice(2, 7)}`,
                docId,
                text: h2Title,
                x: nx0,
                y: Math.max(0, ny - 75),
                fontSize: 30,
                bold: true,
                color: '',
                createdAt: String(Date.now()),
            });
            SettingsStore.data.whiteboardNotes = notes;
        }
        if (placed.length > 1) {
            state.whiteboardSelectedTaskId = '';
            state.whiteboardSelectedNoteId = '';
            state.whiteboardSelectedLinkId = '';
            state.whiteboardSelectedLinkDocId = '';
            state.whiteboardMultiSelectedTaskIds = placed.slice();
            state.whiteboardMultiSelectedNoteIds = [];
            state.whiteboardMultiSelectedLinkKeys = [];
            __tmApplyWhiteboardCardSelectionDom('');
            __tmApplyWhiteboardMultiSelectionDom();
            __tmRenderWhiteboardMultiTools(__tmComputeWhiteboardMultiSelectionRect());
        } else {
            __tmClearWhiteboardMultiSelection();
            state.whiteboardSelectedTaskId = placed[0];
        }
        __tmStopWhiteboardPoolGlobalTracking();
        state.whiteboardPoolDragStart = null;
        state.whiteboardLastBoardLocal = null;
        state.whiteboardLastBoardPointer = null;
        try { await SettingsStore.save(); } catch (e) {}
        if (movedAcrossDoc) {
            try { await loadSelectedDocuments(); } catch (e) { render(); }
        } else {
            render();
        }
    };

    window.tmWhiteboardDocResizeMouseDown = function(ev, docId, dir) {
        if (state.viewMode !== 'whiteboard') return;
        const allView = !(state.activeDocId && state.activeDocId !== 'all');
        if (allView) return;
        if (Number(ev?.button) !== 0) return;
        const did = String(docId || '').trim();
        if (!did) return;
        const modeRaw = String(dir || 'bottom-right').trim().toLowerCase();
        const allowed = new Set(['left', 'right', 'top', 'bottom', 'top-left', 'top-right', 'bottom-left', 'bottom-right', 'both']);
        const mode = allowed.has(modeRaw) ? modeRaw : 'bottom-right';
        const bodyEl = state.modal?.querySelector?.(`.tm-whiteboard-doc-body[data-doc-id="${CSS.escape(did)}"]`);
        if (!(bodyEl instanceof HTMLElement)) return;
        const zoom = Math.max(0.01, Number(__tmGetWhiteboardView()?.zoom) || 1);
        const startW = Number(bodyEl.clientWidth) || 1000;
        const startH = Number(bodyEl.clientHeight) || 520;
        const sx = Number(ev?.clientX) || 0;
        const sy = Number(ev?.clientY) || 0;
        state.whiteboardDocResize = { did, sx, sy, startW, startH, bodyEl, zoom, mode };
        try {
            document.body.style.userSelect = 'none';
            const cursorMap = {
                left: 'ew-resize',
                right: 'ew-resize',
                top: 'ns-resize',
                bottom: 'ns-resize',
                'top-left': 'nwse-resize',
                'bottom-right': 'nwse-resize',
                both: 'nwse-resize',
                'top-right': 'nesw-resize',
                'bottom-left': 'nesw-resize',
            };
            document.body.style.cursor = cursorMap[mode] || 'nwse-resize';
        } catch (e) {}
        const onMove = (e2) => {
            const s = state.whiteboardDocResize;
            if (!s) return;
            const dx = ((Number(e2?.clientX) || 0) - s.sx) / s.zoom;
            const dy = ((Number(e2?.clientY) || 0) - s.sy) / s.zoom;
            const hasLeft = (s.mode === 'left' || s.mode === 'top-left' || s.mode === 'bottom-left');
            const hasRight = (s.mode === 'right' || s.mode === 'top-right' || s.mode === 'bottom-right' || s.mode === 'both');
            const hasTop = (s.mode === 'top' || s.mode === 'top-left' || s.mode === 'top-right');
            const hasBottom = (s.mode === 'bottom' || s.mode === 'bottom-left' || s.mode === 'bottom-right' || s.mode === 'both');
            const wRaw = hasLeft ? (s.startW - dx) : (hasRight ? (s.startW + dx) : s.startW);
            const hRaw = hasTop ? (s.startH - dy) : (hasBottom ? (s.startH + dy) : s.startH);
            const w = Math.max(520, Math.round(wRaw));
            const h = Math.max(220, Math.round(hRaw));
            s.bodyEl.style.width = `${w}px`;
            s.bodyEl.style.height = `${h}px`;
            __tmSetWhiteboardDocFrameSize(s.did, w, h, { persist: false });
            __tmScheduleWhiteboardEdgeRedraw();
        };
        const onUp = async () => {
            try { document.removeEventListener('mousemove', onMove, true); } catch (e) {}
            try { document.removeEventListener('mouseup', onUp, true); } catch (e) {}
            state.whiteboardDocResize = null;
            try {
                document.body.style.userSelect = '';
                document.body.style.cursor = '';
            } catch (e) {}
            try { await SettingsStore.save(); } catch (e) {}
            __tmScheduleWhiteboardEdgeRedraw();
        };
        try { document.addEventListener('mousemove', onMove, true); } catch (e) {}
        try { document.addEventListener('mouseup', onUp, true); } catch (e) {}
        try { ev?.preventDefault?.(); } catch (e) {}
        try { ev?.stopPropagation?.(); } catch (e) {}
    };

    function __tmRenderWhiteboardEdges() {
        if (state.viewMode !== 'whiteboard') return;
        const body = state.modal?.querySelector?.('#tmWhiteboardBody');
        if (!body) return;
        const docBodies = body.querySelectorAll('.tm-whiteboard-doc-body[data-doc-id]');
        docBodies.forEach((docBody) => {
            if (!(docBody instanceof Element)) return;
            try {
                docBody.querySelectorAll('.tm-whiteboard-link-tools[data-tm-wb-dyn="1"]').forEach((el) => {
                    try { el.remove(); } catch (e) {}
                });
            } catch (e) {}
            const docId = String(docBody.getAttribute('data-doc-id') || '').trim();
            if (!docId) return;
            const svg = docBody.querySelector('.tm-whiteboard-edges');
            if (!(svg instanceof SVGElement)) return;
            const width = Math.max(Math.ceil(docBody.scrollWidth), Math.ceil(docBody.clientWidth), 1);
            const height = Math.max(Math.ceil(docBody.scrollHeight), Math.ceil(docBody.clientHeight), 1);
            try { svg.setAttribute('width', String(width)); } catch (e) {}
            try { svg.setAttribute('height', String(height)); } catch (e) {}
            try { svg.setAttribute('viewBox', `0 0 ${width} ${height}`); } catch (e) {}

            const links = __tmGetAllTaskLinks({ docId, includeAuto: false });
            const rootRect = docBody.getBoundingClientRect();
            const zoom = Math.max(0.01, Number(__tmGetWhiteboardView()?.zoom) || 1);
            const getLocalCenter = (el) => {
                if (!(el instanceof Element)) return null;
                try {
                    const rect = el.getBoundingClientRect();
                    return {
                        x: (rect.left - rootRect.left + (rect.width / 2) + docBody.scrollLeft) / zoom,
                        y: (rect.top - rootRect.top + (rect.height / 2) + docBody.scrollTop) / zoom,
                    };
                } catch (e) {
                    return null;
                }
            };
            const getPt = (taskId, kind) => {
                const id = String(taskId || '').trim();
                if (!id) return null;
                const node = docBody.querySelector(`.tm-whiteboard-node[data-task-id="${CSS.escape(id)}"]`);
                if (!(node instanceof Element)) {
                    const proxyTaskId = __tmFindWhiteboardCollapsedProxyTaskId(id, docId);
                    if (!proxyTaskId) return null;
                    const proxyNode = docBody.querySelector(`.tm-whiteboard-node[data-task-id="${CSS.escape(proxyTaskId)}"]`);
                    if (!(proxyNode instanceof Element)) return null;
                    const proxyDot = proxyNode.querySelector('.tm-whiteboard-collapse-proxy-dot');
                    if (!(proxyDot instanceof Element)) return null;
                    return getLocalCenter(proxyDot);
                }
                const dotSel = kind === 'from' ? '.tm-task-link-dot--out' : '.tm-task-link-dot--in';
                const anchor = node.querySelector(dotSel) || node;
                return getLocalCenter(anchor);
            };
            const getLocalRect = (el) => {
                if (!(el instanceof Element)) return null;
                try {
                    const rect = el.getBoundingClientRect();
                    const x = (rect.left - rootRect.left + docBody.scrollLeft) / zoom;
                    const y = (rect.top - rootRect.top + docBody.scrollTop) / zoom;
                    const w = rect.width / zoom;
                    const h = rect.height / zoom;
                    if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(w) || !Number.isFinite(h)) return null;
                    return { x, y, w: Math.max(1, w), h: Math.max(1, h) };
                } catch (e) {
                    return null;
                }
            };
            const obstacleRects = [];
            const rectByTaskId = new Map();
            try {
                docBody.querySelectorAll('.tm-whiteboard-node[data-task-id]').forEach((el) => {
                    if (!(el instanceof Element)) return;
                    const rid = String(el.getAttribute('data-task-id') || '').trim();
                    const rr = getLocalRect(el);
                    if (!rid || !rr) return;
                    obstacleRects.push({ taskId: rid, ...rr });
                    rectByTaskId.set(rid, rr);
                });
            } catch (e) {}
            const segmentHitsRect = (a, b, rect, pad = 10) => {
                const l = rect.x - pad;
                const r = rect.x + rect.w + pad;
                const t = rect.y - pad;
                const bt = rect.y + rect.h + pad;
                const ax = Number(a?.x);
                const ay = Number(a?.y);
                const bx = Number(b?.x);
                const by = Number(b?.y);
                if (!Number.isFinite(ax) || !Number.isFinite(ay) || !Number.isFinite(bx) || !Number.isFinite(by)) return false;
                // 只处理正交线段
                if (Math.abs(ay - by) <= 0.001) {
                    const y = ay;
                    const x0 = Math.min(ax, bx);
                    const x1 = Math.max(ax, bx);
                    return y >= t && y <= bt && x1 >= l && x0 <= r;
                }
                if (Math.abs(ax - bx) <= 0.001) {
                    const x = ax;
                    const y0 = Math.min(ay, by);
                    const y1 = Math.max(ay, by);
                    return x >= l && x <= r && y1 >= t && y0 <= bt;
                }
                return false;
            };
            const orthPathHitsObstacle = (pts, excludeTaskIds) => {
                if (!Array.isArray(pts) || pts.length < 2) return true;
                const excluded = new Set((excludeTaskIds || []).map((x) => String(x || '').trim()).filter(Boolean));
                for (let i = 1; i < pts.length; i++) {
                    const a = pts[i - 1];
                    const b = pts[i];
                    for (const rect of obstacleRects) {
                        if (excluded.has(String(rect.taskId || '').trim())) continue;
                        if (segmentHitsRect(a, b, rect, 10)) return true;
                    }
                }
                return false;
            };
            const pointsToPathD = (pts) => {
                if (!Array.isArray(pts) || !pts.length) return '';
                const head = `M ${pts[0].x.toFixed(2)} ${pts[0].y.toFixed(2)}`;
                if (pts.length === 1) return head;
                return `${head} ${pts.slice(1).map((p) => `L ${p.x.toFixed(2)} ${p.y.toFixed(2)}`).join(' ')}`;
            };
            const pointsToSmoothPathD = (pts, radius = 10) => {
                if (!Array.isArray(pts) || pts.length < 2) return '';
                if (pts.length === 2) return pointsToPathD(pts);
                const r0 = Math.max(0, Number(radius) || 0);
                const fmt = (n) => Number(n).toFixed(2);
                let d = `M ${fmt(pts[0].x)} ${fmt(pts[0].y)}`;
                for (let i = 1; i < pts.length - 1; i++) {
                    const p0 = pts[i - 1];
                    const p1 = pts[i];
                    const p2 = pts[i + 1];
                    const v1x = p1.x - p0.x;
                    const v1y = p1.y - p0.y;
                    const v2x = p2.x - p1.x;
                    const v2y = p2.y - p1.y;
                    const l1 = Math.hypot(v1x, v1y);
                    const l2 = Math.hypot(v2x, v2y);
                    if (!(l1 > 0) || !(l2 > 0) || r0 <= 0) {
                        d += ` L ${fmt(p1.x)} ${fmt(p1.y)}`;
                        continue;
                    }
                    const r = Math.min(r0, l1 / 2, l2 / 2);
                    const inX = p1.x - (v1x / l1) * r;
                    const inY = p1.y - (v1y / l1) * r;
                    const outX = p1.x + (v2x / l2) * r;
                    const outY = p1.y + (v2y / l2) * r;
                    d += ` L ${fmt(inX)} ${fmt(inY)} Q ${fmt(p1.x)} ${fmt(p1.y)} ${fmt(outX)} ${fmt(outY)}`;
                }
                const last = pts[pts.length - 1];
                d += ` L ${fmt(last.x)} ${fmt(last.y)}`;
                return d;
            };
            const pathMidPoint = (pts) => {
                if (!Array.isArray(pts) || pts.length < 2) return null;
                const segLens = [];
                let total = 0;
                for (let i = 1; i < pts.length; i++) {
                    const dx = Number(pts[i].x) - Number(pts[i - 1].x);
                    const dy = Number(pts[i].y) - Number(pts[i - 1].y);
                    const len = Math.hypot(dx, dy);
                    segLens.push(len);
                    total += len;
                }
                if (!(total > 0)) return { x: pts[0].x, y: pts[0].y };
                let acc = 0;
                const half = total / 2;
                for (let i = 1; i < pts.length; i++) {
                    const seg = segLens[i - 1];
                    if (acc + seg >= half) {
                        const t = seg <= 0 ? 0 : ((half - acc) / seg);
                        return {
                            x: pts[i - 1].x + ((pts[i].x - pts[i - 1].x) * t),
                            y: pts[i - 1].y + ((pts[i].y - pts[i - 1].y) * t),
                        };
                    }
                    acc += seg;
                }
                return { x: pts[pts.length - 1].x, y: pts[pts.length - 1].y };
            };
            const buildAvoidPath = (from, to, excludeTaskIds = [], routeMeta = {}) => {
                if (!from || !to) return { d: '', pts: [] };
                const midY = (from.y + to.y) * 0.5;
                const gap = 28;
                const fromRect = (() => {
                    const id = String(routeMeta?.fromTaskId || routeMeta?.fromProxyTaskId || '').trim();
                    return id ? (rectByTaskId.get(id) || null) : null;
                })();
                const toRect = (() => {
                    const id = String(routeMeta?.toTaskId || routeMeta?.toProxyTaskId || '').trim();
                    return id ? (rectByTaskId.get(id) || null) : null;
                })();
                const needStartGap = !!(fromRect && toRect)
                    ? ((fromRect.x + fromRect.w) > toRect.x)
                    : ((to.x - from.x) < 80);
                if (!needStartGap) {
                    const x1 = from.x + ((to.x - from.x) * 0.5);
                    const x2 = x1;
                    const pts = [from, { x: x1, y: from.y }, { x: x2, y: to.y }, to];
                    return { d: `M ${from.x.toFixed(2)} ${from.y.toFixed(2)} C ${x1.toFixed(2)} ${from.y.toFixed(2)} ${x2.toFixed(2)} ${to.y.toFixed(2)} ${to.x.toFixed(2)} ${to.y.toFixed(2)}`, pts };
                }
                const fx = from.x + gap;
                const tx = to.x - gap;
                const yCandidatesRaw = [from.y, to.y, midY];
                obstacleRects.forEach((r) => {
                    yCandidatesRaw.push(r.y - 14);
                    yCandidatesRaw.push(r.y + r.h + 14);
                });
                const seenY = new Set();
                const yCandidates = yCandidatesRaw
                    .map((y) => Math.round(Number(y) * 10) / 10)
                    .filter((y) => Number.isFinite(y))
                    .filter((y) => {
                        const k = String(y);
                        if (seenY.has(k)) return false;
                        seenY.add(k);
                        return true;
                    })
                    .sort((a, b) => Math.abs(a - midY) - Math.abs(b - midY));
                const candidates = [];
                yCandidates.forEach((ry) => {
                    candidates.push([
                        from,
                        { x: fx, y: from.y },
                        { x: fx, y: ry },
                        { x: tx, y: ry },
                        { x: tx, y: to.y },
                        to,
                    ]);
                });
                for (const pts of candidates) {
                    if (!orthPathHitsObstacle(pts, excludeTaskIds)) {
                        return { d: pointsToSmoothPathD(pts, 10), pts };
                    }
                }
                // 回退：保留原来的曲线，避免无路径时完全不显示
                const x1 = from.x + ((to.x - from.x) * 0.5);
                const x2 = x1;
                const pts = [from, { x: x1, y: from.y }, { x: x2, y: to.y }, to];
                return { d: `M ${from.x.toFixed(2)} ${from.y.toFixed(2)} C ${x1.toFixed(2)} ${from.y.toFixed(2)} ${x2.toFixed(2)} ${to.y.toFixed(2)} ${to.x.toFixed(2)} ${to.y.toFixed(2)}`, pts };
            };
            const markerIdIn = `tmWbArrowIn_${docId.replace(/[^a-zA-Z0-9_-]/g, '_')}`;
            const markerIdOut = `tmWbArrowOut_${docId.replace(/[^a-zA-Z0-9_-]/g, '_')}`;
            const defs = `
                <defs>
                    <marker id="${esc(markerIdOut)}" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto" markerUnits="strokeWidth">
                        <path d="M0,0 L8,3 L0,6 Z" fill="#2f6fed"></path>
                    </marker>
                    <marker id="${esc(markerIdIn)}" markerWidth="8" markerHeight="6" refX="1" refY="3" orient="auto-start-reverse" markerUnits="strokeWidth">
                        <path d="M8,0 L0,3 L8,6 Z" fill="#2f6fed"></path>
                    </marker>
                </defs>
            `;
            const selectedLinkId = String(state.whiteboardSelectedLinkId || '').trim();
            const selectedLinkDocId = String(state.whiteboardSelectedLinkDocId || '').trim();
            const multiSelectedLinkSet = new Set((Array.isArray(state.whiteboardMultiSelectedLinkKeys) ? state.whiteboardMultiSelectedLinkKeys : []).map((x) => String(x || '').trim()).filter(Boolean));
            let selectedToolPos = null;
            const paths = links.map((link) => {
                const from = getPt(link.from, 'from');
                const to = getPt(link.to, 'to');
                if (!from || !to) return '';
                const fromProxy = __tmFindWhiteboardCollapsedProxyTaskId(link.from, docId);
                const toProxy = __tmFindWhiteboardCollapsedProxyTaskId(link.to, docId);
                const routed = buildAvoidPath(
                    from,
                    to,
                    [link.from, link.to, fromProxy, toProxy],
                    { fromTaskId: link.from, toTaskId: link.to, fromProxyTaskId: fromProxy, toProxyTaskId: toProxy }
                );
                const d = routed.d;
                const isSelected = link.manual
                    && selectedLinkId
                    && selectedLinkDocId === docId
                    && String(link.id || '').trim() === selectedLinkId;
                const linkKey = `${docId}::${String(link.id || '').trim()}`;
                const cls = link.manual
                    ? `tm-whiteboard-edge tm-whiteboard-edge--manual${isSelected ? ' tm-whiteboard-edge--selected' : ''}${multiSelectedLinkSet.has(linkKey) ? ' tm-whiteboard-multi-selected' : ''}`
                    : 'tm-whiteboard-edge tm-whiteboard-edge--auto';
                const idEsc = String(link.id || '').replace(/\\/g, '\\\\').replace(/'/g, "\\'");
                const docEsc = String(docId || '').replace(/\\/g, '\\\\').replace(/'/g, "\\'");
                const click = link.manual ? `onclick="tmWhiteboardSelectLink('${idEsc}', '${docEsc}', event)"` : '';
                if (isSelected) {
                    const pts = Array.isArray(routed.pts) && routed.pts.length >= 2 ? routed.pts : [from, to];
                    const mp = pathMidPoint(pts) || { x: (from.x + to.x) * 0.5, y: (from.y + to.y) * 0.5 };
                    const mx = mp.x;
                    const my = mp.y;
                    selectedToolPos = { x: mx, y: my };
                }
                const dataAttrs = link.manual ? ` data-link-id="${esc(String(link.id || ''))}" data-doc-id="${esc(String(docId || ''))}"` : '';
                return `<path class="${cls}" d="${d}" marker-end="url(#${esc(markerIdOut)})"${dataAttrs} ${click}></path>`;
            }).join('');
            let previewPath = '';
            const fromTaskId = String(state.whiteboardLinkFromTaskId || '').trim();
            const fromDocId = String(state.whiteboardLinkFromDocId || '').trim();
            const preview = state.whiteboardLinkPreview && typeof state.whiteboardLinkPreview === 'object' ? state.whiteboardLinkPreview : null;
            if (fromTaskId && fromDocId === docId && preview) {
                const from = getPt(fromTaskId, 'from');
                if (from) {
                    let tx = NaN;
                    let ty = NaN;
                    if (String(preview.targetTaskId || '').trim()) {
                        const toPt = getPt(String(preview.targetTaskId || '').trim(), 'to');
                        if (toPt) {
                            tx = toPt.x;
                            ty = toPt.y;
                        }
                    }
                    if (!Number.isFinite(tx) || !Number.isFinite(ty)) {
                        const cx = Number(preview.clientX);
                        const cy = Number(preview.clientY);
                        if (Number.isFinite(cx) && Number.isFinite(cy)) {
                            tx = (cx - rootRect.left + docBody.scrollLeft) / zoom;
                            ty = (cy - rootRect.top + docBody.scrollTop) / zoom;
                        }
                    }
                    if (Number.isFinite(tx) && Number.isFinite(ty)) {
                        const fromProxy = __tmFindWhiteboardCollapsedProxyTaskId(fromTaskId, docId);
                        const targetTaskId = String(preview.targetTaskId || '').trim();
                        const toProxy = targetTaskId ? __tmFindWhiteboardCollapsedProxyTaskId(targetTaskId, docId) : '';
                        const d = buildAvoidPath(
                            from,
                            { x: tx, y: ty },
                            [fromTaskId, fromProxy, targetTaskId, toProxy],
                            { fromTaskId, toTaskId: targetTaskId, fromProxyTaskId: fromProxy, toProxyTaskId: toProxy }
                        ).d;
                        previewPath = `<path class="tm-whiteboard-edge tm-whiteboard-edge--preview" d="${d}" marker-end="url(#${esc(markerIdOut)})"></path>`;
                    }
                }
            }
            svg.innerHTML = defs + paths + previewPath;
            if (selectedToolPos && selectedLinkId && selectedLinkDocId === docId) {
                try {
                    const tools = document.createElement('div');
                    tools.className = 'tm-whiteboard-link-tools';
                    tools.setAttribute('data-tm-wb-dyn', '1');
                    tools.style.left = `${Math.round(selectedToolPos.x - 56)}px`;
                    tools.style.top = `${Math.round(selectedToolPos.y - 42)}px`;
                    tools.innerHTML = `<button class="tm-btn tm-btn-danger" style="padding:2px 8px;font-size:12px;" title="移除该连线">移除连线</button>`;
                    const btn = tools.querySelector('button');
                    if (btn) {
                        btn.addEventListener('click', (ev) => {
                            try { ev.stopPropagation(); } catch (e) {}
                            try { window.tmWhiteboardRemoveSelectedLink?.(ev); } catch (e) {}
                        });
                    }
                    tools.addEventListener('click', (ev) => {
                        try { ev.stopPropagation(); } catch (e) {}
                    });
                    docBody.appendChild(tools);
                } catch (e) {}
            }
        });
    }

    function __tmResetLinkDragState() {
        state.whiteboardLinkFromTaskId = '';
        state.whiteboardLinkFromDocId = '';
        state.whiteboardLinkPress = null;
        state.whiteboardLinkPreview = null;
        __tmUpdateWhiteboardLinkHover('', '');
        __tmUpdateTimelineLinkHover('');
        try { state.__tmTimelineRenderDeps?.(); } catch (e) {}
    }

    function __tmUpdateWhiteboardLinkPreviewFromEvent(ev, targetTaskId, targetDocId) {
        const fromTaskId = String(state.whiteboardLinkFromTaskId || '').trim();
        const fromDocId = String(state.whiteboardLinkFromDocId || '').trim();
        if (!fromTaskId || !fromDocId) return;
        const tId = String(targetTaskId || '').trim();
        const tDocId = String(targetDocId || '').trim();
        state.whiteboardLinkPreview = {
            mode: state.viewMode === 'timeline' ? 'timeline' : 'whiteboard',
            clientX: Number(ev?.clientX) || 0,
            clientY: Number(ev?.clientY) || 0,
            targetTaskId: tId,
            targetDocId: tDocId || fromDocId,
        };
    }

    function __tmUpdateTimelineLinkHover(taskId) {
        const id = String(taskId || '').trim();
        state.timelineLinkHoverTaskId = id;
        const body = state.modal?.querySelector?.('#tmGanttBody');
        if (!(body instanceof HTMLElement)) return;
        try {
            body.querySelectorAll('.tm-gantt-row--link-hover').forEach((el) => el.classList.remove('tm-gantt-row--link-hover'));
        } catch (e) {}
        if (!id) return;
        try {
            const row = body.querySelector(`.tm-gantt-row[data-id="${CSS.escape(id)}"]`);
            if (row instanceof HTMLElement) row.classList.add('tm-gantt-row--link-hover');
        } catch (e) {}
    }

    function __tmUpdateWhiteboardLinkHover(taskId, docId) {
        const tid = String(taskId || '').trim();
        const did = String(docId || '').trim();
        state.whiteboardLinkHoverTaskId = tid;
        state.whiteboardLinkHoverDocId = did;
        const body = state.modal?.querySelector?.('#tmWhiteboardBody');
        if (!(body instanceof HTMLElement)) return;
        try {
            body.querySelectorAll('.tm-whiteboard-node--link-hover').forEach((el) => el.classList.remove('tm-whiteboard-node--link-hover'));
        } catch (e) {}
        if (!tid || !did) return;
        try {
            const node = body.querySelector(`.tm-whiteboard-node[data-task-id="${CSS.escape(tid)}"][data-doc-id="${CSS.escape(did)}"]`);
            if (node instanceof HTMLElement) node.classList.add('tm-whiteboard-node--link-hover');
        } catch (e) {}
    }

    function __tmClearTaskLinkPointerFallback() {
        const s = state.whiteboardLinkPointerFallback;
        if (!s || typeof s !== 'object') return;
        try { s.detach?.(); } catch (e) {}
        state.whiteboardLinkPointerFallback = null;
    }

    function __tmStartTaskLinkPointerFallback(ev, taskId, docId) {
        __tmClearTaskLinkPointerFallback();
        const fromTaskId = String(taskId || '').trim();
        const fromDocId = String(docId || '').trim();
        if (!fromTaskId || !fromDocId) return;
        const pointerIdRaw = Number(ev?.pointerId);
        const pointerId = Number.isFinite(pointerIdRaw) ? pointerIdRaw : null;
        const sx = Number(ev?.clientX) || 0;
        const sy = Number(ev?.clientY) || 0;
        const session = {
            pointerId,
            fromTaskId,
            fromDocId,
            sx,
            sy,
            moved: false,
            dragStarted: false,
            hoverTaskId: '',
            hoverDocId: '',
            detach: null,
        };
        const samePointer = (e2) => {
            if (!session) return false;
            if (!Number.isFinite(Number(session.pointerId))) return true;
            const cur = Number(e2?.pointerId);
            if (!Number.isFinite(cur)) return true;
            return cur === Number(session.pointerId);
        };
        const updateHoverFromPoint = (e2) => {
            const x = Number(e2?.clientX);
            const y = Number(e2?.clientY);
            if (!Number.isFinite(x) || !Number.isFinite(y)) return;
            let tid = '';
            let did = '';
            try {
                const hit = document.elementFromPoint(x, y);
                const wbNode = hit?.closest?.('.tm-whiteboard-node[data-task-id][data-doc-id]');
                if (wbNode instanceof Element) {
                    tid = String(wbNode.getAttribute('data-task-id') || '').trim();
                    did = String(wbNode.getAttribute('data-doc-id') || '').trim();
                } else {
                    const row = hit?.closest?.('.tm-gantt-row[data-id]');
                    if (row instanceof Element) {
                        tid = String(row.getAttribute('data-id') || '').trim();
                        did = String(row.getAttribute('data-doc-id') || '').trim();
                    }
                }
            } catch (e) {}
            session.hoverTaskId = tid;
            session.hoverDocId = did;
            if (state.viewMode === 'whiteboard') {
                __tmUpdateWhiteboardLinkHover(tid, did);
            } else {
                __tmUpdateTimelineLinkHover(tid);
            }
            __tmUpdateWhiteboardLinkPreviewFromEvent(e2, tid, did || fromDocId);
            if (state.viewMode === 'timeline') {
                try { state.__tmTimelineRenderDeps?.(); } catch (e) {}
            } else {
                __tmScheduleWhiteboardEdgeRedraw();
            }
        };
        const onMove = (e2) => {
            if (!samePointer(e2)) return;
            const x = Number(e2?.clientX) || sx;
            const y = Number(e2?.clientY) || sy;
            if (!session.moved) {
                const dx = x - sx;
                const dy = y - sy;
                if ((dx * dx + dy * dy) >= 16) session.moved = true;
            }
            updateHoverFromPoint(e2);
        };
        const onUp = async (e2) => {
            if (!samePointer(e2)) return;
            __tmClearTaskLinkPointerFallback();
            if (session.dragStarted) return;
            if (session.moved && session.hoverTaskId) {
                try {
                    await window.tmTaskLinkDotDrop?.(e2, session.hoverTaskId, session.hoverDocId || fromDocId);
                    return;
                } catch (e) {}
            }
            __tmResetLinkDragState();
            __tmScheduleWhiteboardEdgeRedraw();
        };
        const detach = () => {
            try { window.removeEventListener('pointermove', onMove, true); } catch (e) {}
            try { window.removeEventListener('pointerup', onUp, true); } catch (e) {}
            try { window.removeEventListener('pointercancel', onUp, true); } catch (e) {}
            try { window.removeEventListener('blur', onUp, true); } catch (e) {}
        };
        session.detach = detach;
        state.whiteboardLinkPointerFallback = session;
        try { window.addEventListener('pointermove', onMove, true); } catch (e) {}
        try { window.addEventListener('pointerup', onUp, true); } catch (e) {}
        try { window.addEventListener('pointercancel', onUp, true); } catch (e) {}
        try { window.addEventListener('blur', onUp, true); } catch (e) {}
    }

    window.tmTaskLinkDotPressStart = function(ev, taskId, docId) {
        state.whiteboardLinkPress = {
            taskId: String(taskId || '').trim(),
            docId: String(docId || '').trim(),
            at: Date.now(),
        };
        const id = String(taskId || '').trim();
        const did = String(docId || '').trim();
        if (!id || !did) return;
        state.whiteboardLinkFromTaskId = id;
        state.whiteboardLinkFromDocId = did;
        __tmUpdateWhiteboardLinkHover('', '');
        __tmUpdateWhiteboardLinkPreviewFromEvent(ev, '', did);
        __tmScheduleWhiteboardEdgeRedraw();
        __tmStartTaskLinkPointerFallback(ev, id, did);
    };

    window.tmTaskLinkDotDragStart = function(ev, taskId, docId) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        const fb = state.whiteboardLinkPointerFallback;
        if (fb && typeof fb === 'object') {
            fb.dragStarted = true;
            try { fb.detach?.(); } catch (e) {}
            state.whiteboardLinkPointerFallback = null;
        }
        const id = String(taskId || '').trim();
        const did = String(docId || '').trim();
        if (!id || !did) return;
        state.whiteboardLinkFromTaskId = id;
        state.whiteboardLinkFromDocId = did;
        __tmUpdateWhiteboardLinkHover('', '');
        __tmUpdateWhiteboardLinkPreviewFromEvent(ev, '', did);
        try {
            ev.dataTransfer.effectAllowed = 'link';
            const payload = JSON.stringify({ type: 'tm-task-link', taskId: id, docId: did });
            ev.dataTransfer.setData('application/x-tm-task-link', payload);
            ev.dataTransfer.setData('text/plain', payload);
        } catch (e) {}
        __tmScheduleWhiteboardEdgeRedraw();
    };

    window.tmTaskLinkDotDragOver = function(ev) {
        try { ev?.preventDefault?.(); } catch (e) {}
        try { ev?.stopPropagation?.(); } catch (e) {}
        const target = ev?.currentTarget instanceof Element ? ev.currentTarget : (ev?.target?.closest?.('.tm-task-link-dot') || null);
        const taskId = String(target?.closest?.('.tm-whiteboard-node,[data-id]')?.getAttribute?.('data-task-id') || target?.closest?.('.tm-gantt-row')?.getAttribute?.('data-id') || '').trim();
        const docId = String(target?.closest?.('.tm-whiteboard-node')?.getAttribute?.('data-doc-id') || target?.closest?.('.tm-gantt-row')?.getAttribute?.('data-doc-id') || '').trim();
        if (state.viewMode === 'whiteboard') __tmUpdateWhiteboardLinkHover(taskId, docId);
        __tmUpdateWhiteboardLinkPreviewFromEvent(ev, taskId, docId);
        if (state.viewMode === 'timeline') {
            __tmUpdateTimelineLinkHover(taskId);
            try { state.__tmTimelineRenderDeps?.(); } catch (e) {}
        } else {
            __tmScheduleWhiteboardEdgeRedraw();
        }
    };

    window.tmTimelineLinkRowDragOver = function(ev, taskId, docId) {
        try { ev?.preventDefault?.(); } catch (e) {}
        try { ev?.stopPropagation?.(); } catch (e) {}
        const fromTaskId = String(state.whiteboardLinkFromTaskId || '').trim();
        if (!fromTaskId) return;
        const id = String(taskId || '').trim();
        __tmUpdateTimelineLinkHover(id);
        __tmUpdateWhiteboardLinkPreviewFromEvent(ev, id, String(docId || '').trim());
        try { state.__tmTimelineRenderDeps?.(); } catch (e) {}
    };

    window.tmTimelineLinkRowDragLeave = function(ev, taskId) {
        const related = ev?.relatedTarget;
        if (related && related instanceof Element) {
            const row = ev?.currentTarget instanceof Element ? ev.currentTarget : null;
            if (row && row.contains(related)) return;
        }
        const id = String(taskId || '').trim();
        if (!id || String(state.timelineLinkHoverTaskId || '').trim() !== id) return;
        __tmUpdateTimelineLinkHover('');
        try { state.__tmTimelineRenderDeps?.(); } catch (e) {}
    };

    window.tmTaskLinkDotDragEnd = function(ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        __tmClearTaskLinkPointerFallback();
        __tmResetLinkDragState();
        __tmScheduleWhiteboardEdgeRedraw();
    };

    window.tmTaskLinkDotDrop = async function(ev, targetTaskId, targetDocId) {
        try { ev?.preventDefault?.(); } catch (e) {}
        try { ev?.stopPropagation?.(); } catch (e) {}
        const toId = String(targetTaskId || '').trim();
        let fromId = '';
        let fromDocId = '';
        try {
            const raw = ev?.dataTransfer?.getData?.('application/x-tm-task-link') || ev?.dataTransfer?.getData?.('text/plain');
            if (raw) {
                const obj = JSON.parse(raw);
                if (String(obj?.type || '').trim() === 'tm-task-link') {
                    fromId = String(obj?.taskId || '').trim();
                    fromDocId = String(obj?.docId || '').trim();
                }
            }
        } catch (e) {}
        if (!fromId) fromId = String(state.whiteboardLinkFromTaskId || '').trim();
        if (!fromDocId) fromDocId = String(state.whiteboardLinkFromDocId || '').trim();
        const toDocId = String(targetDocId || '').trim() || __tmGetTaskDocIdById(toId);
        if (!fromId || !toId || !fromDocId || !toDocId || fromId === toId) {
            __tmResetLinkDragState();
            __tmScheduleWhiteboardEdgeRedraw();
            return;
        }
        const check = __tmCanLinkTasks(fromId, toId);
        if (!check.ok) {
            hint(`⚠ ${check.reason}`, 'warning');
            __tmResetLinkDragState();
            __tmScheduleWhiteboardEdgeRedraw();
            return;
        }
        const docId = String(check.docId || '').trim();
        const manual = __tmGetManualTaskLinks();
        const exists = manual.some(x => String(x?.from || '') === fromId && String(x?.to || '') === toId && String(x?.docId || '') === docId);
        if (exists) {
            hint('ℹ 该连线已存在', 'info');
            __tmResetLinkDragState();
            __tmScheduleWhiteboardEdgeRedraw();
            return;
        }
        manual.push({
            id: `link_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
            from: fromId,
            to: toId,
            docId,
            createdAt: String(Date.now()),
        });
        __tmSetManualTaskLinks(manual);
        try { await SettingsStore.save(); } catch (e) {}
        __tmResetLinkDragState();
        render();
    };

    window.tmWhiteboardRemoveLink = async function(linkId, ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        const id = String(linkId || '').trim();
        if (!id) return;
        const manual = __tmGetManualTaskLinks().filter(x => String(x?.id || '').trim() !== id);
        __tmSetManualTaskLinks(manual);
        if (String(state.whiteboardSelectedLinkId || '').trim() === id) {
            state.whiteboardSelectedLinkId = '';
            state.whiteboardSelectedLinkDocId = '';
        }
        try { await SettingsStore.save(); } catch (e) {}
        if (state.viewMode === 'whiteboard') __tmScheduleWhiteboardEdgeRedraw();
        render();
    };

    window.tmWhiteboardSelectLink = function(linkId, docId, ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        const id = String(linkId || '').trim();
        const did = String(docId || '').trim();
        if (!id || !did) return;
        if (String(state.whiteboardSelectedLinkId || '').trim() === id && String(state.whiteboardSelectedLinkDocId || '').trim() === did) {
            state.whiteboardSelectedLinkId = '';
            state.whiteboardSelectedLinkDocId = '';
        } else {
            state.whiteboardSelectedLinkId = id;
            state.whiteboardSelectedLinkDocId = did;
        }
        __tmScheduleWhiteboardEdgeRedraw();
    };

    window.tmWhiteboardRemoveSelectedLink = async function(ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        const id = String(state.whiteboardSelectedLinkId || '').trim();
        if (!id) return;
        return window.tmWhiteboardRemoveLink(id, ev);
    };

    window.tmWhiteboardToggleSidebar = async function(ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        const next = !SettingsStore.data.whiteboardSidebarCollapsed;
        SettingsStore.data.whiteboardSidebarCollapsed = next;
        const body = state.modal?.querySelector?.('#tmWhiteboardBody');
        const layout = body?.querySelector?.('.tm-whiteboard-layout');
        const btn = body?.querySelector?.('.tm-whiteboard-sidebar-toggle');
        if (layout) {
            try { layout.classList.toggle('tm-whiteboard-layout--sidebar-collapsed', !!next); } catch (e) {}
        }
        if (btn) {
            try {
                btn.textContent = next ? '☰' : '⟨';
                btn.title = next ? '展开侧栏' : '折叠侧栏';
            } catch (e) {}
        }
        if (!layout || !btn) render();
        try { await SettingsStore.save(); } catch (e) {}
    };

    window.tmWhiteboardSetTool = async function(tool) {
        const t = String(tool || 'pan').trim();
        const next = (t === 'select' || t === 'text' || t === 'pan') ? t : 'pan';
        if (next !== 'text') {
            try { await __tmCloseWhiteboardNoteEditor({ save: true }); } catch (e) {}
        }
        __tmClearWhiteboardMultiSelection();
        SettingsStore.data.whiteboardTool = next;
        try { await SettingsStore.save(); } catch (e) {}
        render();
    };

    window.tmWhiteboardToggleShowDone = async function(enabled) {
        SettingsStore.data.whiteboardShowDone = !!enabled;
        try { await SettingsStore.save(); } catch (e) {}
        render();
    };

    window.tmWhiteboardMoveBackToParent = async function(taskId, docId, ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        const id = String(taskId || '').trim();
        if (!id) return;
        const pid = __tmResolveWhiteboardTaskParentId(id);
        if (!pid) return;
        __tmSetWhiteboardChildDetached(id, false);
        __tmSetWhiteboardTaskPlaced(id, false, { persist: false });
        try { await SettingsStore.save(); } catch (e) {}
        render();
    };

    function __tmEnsureWhiteboardTaskSelected(taskId) {
        const id = String(taskId || '').trim();
        if (!id) return;
        if (String(state.whiteboardSelectedTaskId || '').trim() === id) return;
        __tmClearWhiteboardMultiSelection();
        state.whiteboardSelectedTaskId = id;
        state.whiteboardSelectedNoteId = '';
        state.whiteboardSelectedLinkId = '';
        state.whiteboardSelectedLinkDocId = '';
        __tmApplyWhiteboardCardSelectionDom(id);
        __tmScheduleWhiteboardEdgeRedraw();
    }

    function __tmCanEditWhiteboardTaskField(taskId) {
        const id = String(taskId || '').trim();
        if (!id) return false;
        if (state.viewMode !== 'whiteboard') return false;
        if (String(state.whiteboardSelectedTaskId || '').trim() !== id) return false;
        const t = state.flatTasks?.[id];
        if (!t) return false;
        return true;
    }

    window.tmWhiteboardEditStatus = function(taskId, el, ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        __tmEnsureWhiteboardTaskSelected(taskId);
        if (!__tmCanEditWhiteboardTaskField(taskId)) return;
        try { window.tmKanbanOpenStatusSelect?.(String(taskId || '').trim(), el, ev); } catch (e) {}
    };

    window.tmWhiteboardEditPriority = function(taskId, el, ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        __tmEnsureWhiteboardTaskSelected(taskId);
        if (!__tmCanEditWhiteboardTaskField(taskId)) return;
        try { window.tmPickPriority?.(String(taskId || '').trim(), el, ev); } catch (e) {}
    };

    window.tmWhiteboardEditDate = function(taskId, ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        __tmEnsureWhiteboardTaskSelected(taskId);
        if (!__tmCanEditWhiteboardTaskField(taskId)) return;
        try { window.tmKanbanPickDate?.(String(taskId || '').trim(), ev); } catch (e) {}
    };

    window.tmWhiteboardToggleAutoConnect = async function(enabled) {
        SettingsStore.data.whiteboardAutoConnectByCreated = false;
        try { await SettingsStore.save(); } catch (e) {}
        hint('ℹ 已移除默认时间连线功能', 'info');
    };

    window.tmWhiteboardToggleAutoLayout = async function(enabled) {
        SettingsStore.data.whiteboardAutoLayout = false;
        try { await SettingsStore.save(); } catch (e) {}
        hint('ℹ 已移除自动排布功能', 'info');
    };

    window.tmWhiteboardClearLinks = async function() {
        const ok = confirm('确认清空所有手动连线？');
        if (!ok) return;
        __tmSetManualTaskLinks([]);
        state.whiteboardSelectedLinkId = '';
        state.whiteboardSelectedLinkDocId = '';
        state.whiteboardMultiSelectedLinkKeys = [];
        __tmApplyWhiteboardMultiSelectionDom();
        __tmRenderWhiteboardMultiTools(__tmComputeWhiteboardMultiSelectionRect());
        try { await SettingsStore.save(); } catch (e) {}
        render();
    };

    window.tmWhiteboardDetachChild = async function(taskId, ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        const id = String(taskId || '').trim();
        if (!id) return;
        const task = state.flatTasks?.[id];
        if (!task) return;
        const pid = String(task?.parentTaskId || '').trim();
        if (!pid) return;
        const docA = __tmGetTaskDocIdById(id);
        const docB = __tmGetTaskDocIdById(pid);
        if (!docA || !docB || docA !== docB) return;
        __tmSetWhiteboardChildDetached(id, true, pid);
        try { await SettingsStore.save(); } catch (e) {}
        render();
    };

    window.tmWhiteboardReattachChild = async function(taskId, ev) {
        try { ev?.stopPropagation?.(); } catch (e) {}
        const id = String(taskId || '').trim();
        if (!id) return;
        __tmSetWhiteboardChildDetached(id, false);
        try { await SettingsStore.save(); } catch (e) {}
        render();
    };

    window.tmWhiteboardCardDragStart = function(ev, taskId, docId) {
        const id = String(taskId || '').trim();
        const did = String(docId || '').trim();
        if (!id || !did) return;
        try {
            const payload = JSON.stringify({ type: 'tm-whiteboard-task', taskId: id, docId: did });
            ev.dataTransfer.effectAllowed = 'move';
            ev.dataTransfer.setData('application/x-tm-whiteboard-task', payload);
            ev.dataTransfer.setData('text/plain', payload);
        } catch (e) {}
    };

    window.tmWhiteboardLaneDragOver = function(ev) {
        try { ev?.preventDefault?.(); } catch (e) {}
    };

    window.tmWhiteboardLaneDrop = async function(ev, docId) {
        try { ev?.preventDefault?.(); } catch (e) {}
        try { ev?.stopPropagation?.(); } catch (e) {}
        let payload = null;
        try {
            const raw = ev?.dataTransfer?.getData?.('application/x-tm-whiteboard-task') || ev?.dataTransfer?.getData?.('text/plain');
            if (raw) payload = JSON.parse(raw);
        } catch (e) {}
        if (String(payload?.type || '').trim() !== 'tm-whiteboard-task') return;
        const taskId = String(payload?.taskId || '').trim();
        const fromDocId = String(payload?.docId || '').trim();
        const toDocId = String(docId || '').trim();
        if (!taskId || !fromDocId || !toDocId || fromDocId !== toDocId) return;
        const task = state.flatTasks?.[taskId];
        const pid = String(task?.parentTaskId || '').trim();
        if (!task || !pid) return;
        if (__tmGetTaskDocIdById(pid) !== toDocId) return;
        __tmSetWhiteboardChildDetached(taskId, true, pid);
        try { await SettingsStore.save(); } catch (e) {}
        render();
    };

    window.tmWhiteboardLaneClick = async function(ev, docId) {
        return window.tmWhiteboardDocClick(ev, docId);
    };

    window.tmWhiteboardRemoveNote = async function(noteId, ev) {
        return window.tmWhiteboardDeleteNote(noteId, ev);
    };

    window.tmWhiteboardToggleTaskCollapse = function(taskId, ev) {
        try {
            ev?.stopPropagation?.();
            ev?.preventDefault?.();
        } catch (e) {}
        const id = String(taskId || '').trim();
        if (!id) return;
        const s = __tmKanbanGetCollapsedSet();
        if (s.has(id)) s.delete(id);
        else s.add(id);
        __tmKanbanPersistCollapsed();
        render();
    };

    window.tmGetCalendarDragTasks = function(limit) {
        const max = Number.isFinite(Number(limit)) ? Math.max(1, Math.min(500, Math.floor(Number(limit)))) : 200;
        const filtered = Array.isArray(state.filteredTasks) ? state.filteredTasks : [];
        const docsToGroup = new Map();
        try {
            const groups = Array.isArray(SettingsStore.data.docGroups) ? SettingsStore.data.docGroups : [];
            groups.forEach((g) => {
                const gid = String(g?.id || '').trim();
                const docs = Array.isArray(g?.docs) ? g.docs : [];
                if (!gid) return;
                docs.forEach((d) => {
                    const did = String((typeof d === 'object' ? d?.id : d) || '').trim();
                    if (!did) return;
                    if (!docsToGroup.has(did)) docsToGroup.set(did, gid);
                });
            });
        } catch (e) {}

        const mode = String(SettingsStore.data.tomatoSpentAttrMode || 'minutes').trim() || 'minutes';
        const useHours = !!(SettingsStore.data.enableTomatoIntegration && mode === 'hours');

        const out = [];
        for (const t of filtered) {
            if (!t) continue;
            if (t.done) continue;
            const id = String(t.id || '').trim();
            if (!id) continue;
            const title = String(t.content || '').trim();
            const docId = String(t.root_id || '').trim();
            const gid = docId ? docsToGroup.get(docId) : '';
            const calendarId = gid ? `group:${gid}` : 'default';

            const mins = __tmParseDurationMinutes(t?.duration);
            const durationMin = (Number.isFinite(Number(mins)) && Number(mins) > 0) ? Math.round(Number(mins)) : 60;

            let spent = '';
            try {
                if (useHours) spent = __tmFormatSpentHours(__tmParseNumber(t?.tomatoHours)) || '';
                else spent = __tmFormatSpentMinutes(__tmGetTaskSpentMinutes(t)) || '';
            } catch (e) {}

            out.push({ id, title: title || '(无标题)', spent, durationMin, calendarId });
            if (out.length >= max) break;
        }
        return out;
    };

    window.tmQueryCalendarTasks = function(params) {
        const p = (params && typeof params === 'object') ? params : {};
        const size = Number.isFinite(Number(p.pageSize)) ? Math.max(20, Math.min(500, Math.floor(Number(p.pageSize)))) : 200;
        const page = Number.isFinite(Number(p.page)) ? Math.max(1, Math.floor(Number(p.page))) : 1;
        const q = String(p.query || '').trim().toLowerCase();

        const filtered = Array.isArray(state.filteredTasks) ? state.filteredTasks : [];
        const map = new Map(filtered.map((t) => [String(t?.id || '').trim(), t]).filter(([k]) => !!k));
        const childSet = new Set();
        for (const t of filtered) {
            const pid = String(t?.parentTaskId || '').trim();
            if (pid) childSet.add(pid);
        }
        const depthMemo = new Map();
        const getDepth = (id) => {
            if (!id) return 0;
            if (depthMemo.has(id)) return depthMemo.get(id);
            const t = map.get(id);
            if (!t) return 0;
            const pid = String(t.parentTaskId || '').trim();
            const d = pid ? Math.min(20, getDepth(pid) + 1) : 0;
            depthMemo.set(id, d);
            return d;
        };

        const docsToGroup = new Map();
        try {
            const groups = Array.isArray(SettingsStore.data.docGroups) ? SettingsStore.data.docGroups : [];
            groups.forEach((g) => {
                const gid = String(g?.id || '').trim();
                const docs = Array.isArray(g?.docs) ? g.docs : [];
                if (!gid) return;
                docs.forEach((d) => {
                    const did = String(d?.id || '').trim();
                    if (!did) return;
                    if (!docsToGroup.has(did)) docsToGroup.set(did, gid);
                });
            });
        } catch (e) {}

        const mode = String(SettingsStore.data.tomatoSpentAttrMode || 'minutes').trim() || 'minutes';
        const useHours = !!(SettingsStore.data.enableTomatoIntegration && mode === 'hours');

        const all = [];
        for (const t of filtered) {
            if (!t) continue;
            if (t.done) continue;
            const id = String(t.id || '').trim();
            if (!id) continue;
            const title = String(t.content || '').trim() || '(无标题)';
            if (q && !title.toLowerCase().includes(q)) continue;
            const docId = String(t.root_id || '').trim();
            const gid = docId ? docsToGroup.get(docId) : '';
            const calendarId = gid ? `group:${gid}` : 'default';

            const mins = __tmParseDurationMinutes(t?.duration);
            const durationMin = (Number.isFinite(Number(mins)) && Number(mins) > 0) ? Math.round(Number(mins)) : 60;

            let spent = '';
            try {
                if (useHours) spent = __tmFormatSpentHours(__tmParseNumber(t?.tomatoHours)) || '';
                else spent = __tmFormatSpentMinutes(__tmGetTaskSpentMinutes(t)) || '';
            } catch (e) {}

            all.push({
                id,
                title,
                spent,
                durationMin,
                calendarId,
                depth: getDepth(id),
                hasChildren: childSet.has(id),
            });
        }

        const total = all.length;
        const start = (page - 1) * size;
        const items = all.slice(start, start + size);
        return { total, page, pageSize: size, items };
    };

    window.tmQueryCalendarTaskDateEvents = async function(rangeStart, rangeEnd) {
        const startKey = __tmNormalizeDateOnly(rangeStart);
        const endKey = __tmNormalizeDateOnly(rangeEnd);
        const toTs = (k) => {
            const kk = String(k || '').trim();
            if (!kk) return 0;
            const d = new Date(`${kk}T12:00:00`);
            return Number.isNaN(d.getTime()) ? 0 : d.getTime();
        };
        const rangeStartTs = toTs(startKey) || 0;
        const rangeEndTs = toTs(endKey) || 0;

        const getAllDocIdsForCalendar = async () => {
            const groups = Array.isArray(SettingsStore.data.docGroups) ? SettingsStore.data.docGroups : [];
            const legacyIds = Array.isArray(SettingsStore.data.selectedDocIds) ? SettingsStore.data.selectedDocIds : [];
            const quickAddDocId = String(SettingsStore.data.newTaskDocId || '').trim();
            const targetDocs = [];
            legacyIds.forEach((id) => {
                const did = String(id || '').trim();
                if (did) targetDocs.push({ id: did, recursive: false });
            });
            groups.forEach((g) => {
                const docs = Array.isArray(g?.docs) ? g.docs : [];
                docs.forEach((d) => {
                    const did = String((typeof d === 'object' ? d?.id : d) || '').trim();
                    if (!did) return;
                    targetDocs.push({ id: did, recursive: !!(typeof d === 'object' && d && d.recursive) });
                });
            });
            const finalIds = new Set();
            if (quickAddDocId && quickAddDocId !== '__dailyNote__') finalIds.add(quickAddDocId);
            await Promise.all(targetDocs.map(async (doc) => {
                if (!doc || !doc.id) return;
                finalIds.add(doc.id);
                if (doc.recursive && API && typeof API.getSubDocIds === 'function') {
                    try {
                        const subIds = await API.getSubDocIds(doc.id);
                        (Array.isArray(subIds) ? subIds : []).forEach((sid) => {
                            const s = String(sid || '').trim();
                            if (s) finalIds.add(s);
                        });
                    } catch (e) {}
                }
            }));
            return Array.from(finalIds);
        };

        const getAllTasksForCalendar = async () => {
            const limit = Number.isFinite(Number(SettingsStore.data.queryLimit)) ? Number(SettingsStore.data.queryLimit) : 2000;
            const allDocIds = await getAllDocIdsForCalendar();
            const docKey = allDocIds.slice().sort().join(',');
            const key = `${limit}|${docKey}`;
            const prev = window.__tmCalendarAllTasksCache;
            if (prev && prev.key === key && Array.isArray(prev.tasks) && (Date.now() - (Number(prev.ts) || 0) < 8000)) return prev.tasks;
            try { await MetaStore.load?.(); } catch (e) {}
            const res = await API.getTasksByDocuments(allDocIds, limit, { doneOnly: false });
            const tasks = Array.isArray(res?.tasks) ? res.tasks : [];
            const out = [];
            for (const task of tasks) {
                if (!task || typeof task !== 'object') continue;
                let parsedDone = !!task.done;
                try {
                    const parsed = API.parseTaskStatus(task.markdown);
                    parsedDone = !!parsed.done;
                    task.done = parsedDone;
                    task.content = parsed.content;
                } catch (e) {}
                try { MetaStore.applyToTask?.(task); } catch (e) {}
                task.done = parsedDone; // 以文档中的真实复选框状态为准
                try { normalizeTaskFields(task, task.docName || '未命名文档'); } catch (e) {}
                out.push(task);
            }
            window.__tmCalendarAllTasksCache = { key, ts: Date.now(), tasks: out };
            return out;
        };

        const getDocsToGroupMap = async () => {
            const groups = Array.isArray(SettingsStore.data.docGroups) ? SettingsStore.data.docGroups : [];
            const parts = [];
            for (const g of groups) {
                const gid = String(g?.id || '').trim();
                if (!gid) continue;
                const docs = Array.isArray(g?.docs) ? g.docs : [];
                const ds = docs.map((d) => {
                    const did = String((typeof d === 'object' ? d?.id : d) || '').trim();
                    const rec = !!(typeof d === 'object' && d && d.recursive);
                    if (!did) return '';
                    return did + (rec ? '*' : '');
                }).filter(Boolean);
                parts.push(`${gid}:${ds.join(',')}`);
            }
            const key = parts.join('|');
            const prev = window.__tmCalendarDocsToGroupCache;
            if (prev && prev.key === key && prev.map instanceof Map) return prev.map;

            const map = new Map();
            for (const g of groups) {
                const gid = String(g?.id || '').trim();
                if (!gid) continue;
                const docs = Array.isArray(g?.docs) ? g.docs : [];
                for (const d of docs) {
                    const did = String((typeof d === 'object' ? d?.id : d) || '').trim();
                    const rec = !!(typeof d === 'object' && d && d.recursive);
                    if (!did) continue;
                    if (!map.has(did)) map.set(did, gid);
                    if (rec && API && typeof API.getSubDocIds === 'function') {
                        try {
                            const subIds = await API.getSubDocIds(did);
                            (Array.isArray(subIds) ? subIds : []).forEach((sid) => {
                                const s = String(sid || '').trim();
                                if (!s) return;
                                if (!map.has(s)) map.set(s, gid);
                            });
                        } catch (e) {}
                    }
                }
            }

            window.__tmCalendarDocsToGroupCache = { key, map };
            return map;
        };

        let docsToGroup = new Map();
        try { docsToGroup = await getDocsToGroupMap(); } catch (e) {}

        const nextDay = (k) => {
            const ts = toTs(k);
            if (!ts) return '';
            const d = new Date(ts + 86400000);
            const pad = (n) => String(n).padStart(2, '0');
            return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
        };

        let filtered = [];
        try { filtered = await getAllTasksForCalendar(); } catch (e) { filtered = []; }
        const out = [];
        for (const t of filtered) {
            if (!t) continue;
            if (t.done) continue;
            const id = String(t.id || '').trim();
            if (!id) continue;
            const s0 = __tmNormalizeDateOnly(t?.startDate);
            const e0 = __tmNormalizeDateOnly(t?.completionTime);
            if (!s0 && !e0) continue;
            const start = s0 || e0;
            const end = e0 || s0 || start;
            const startTs = toTs(start);
            const endExKey = nextDay(end);
            const endExTs = toTs(endExKey);
            if (rangeStartTs && endExTs && endExTs <= rangeStartTs) continue;
            if (rangeEndTs && startTs && startTs >= rangeEndTs) continue;

            const title = String(t.content || '').trim() || '(无标题)';
            const docId = String(t.root_id || '').trim();
            const gid = docId ? docsToGroup.get(docId) : '';
            const calendarId = gid ? `group:${gid}` : 'default';
            out.push({ id, title, start, endExclusive: endExKey || nextDay(start), calendarId });
        }
        return out;
    };

    window.tmRenderCalendarTaskTableHtml = function() {
        const originalOrder = SettingsStore.data.columnOrder;
        const originalWidths = SettingsStore.data.columnWidths;
        try {
            // Ensure calendarColumnWidths is initialized with defaults if missing or empty
            if (!SettingsStore.data.calendarColumnWidths || Object.keys(SettingsStore.data.calendarColumnWidths).length === 0) {
                SettingsStore.data.calendarColumnWidths = { content: 140, duration: 60, spent: 60 };
            }
            
            SettingsStore.data.columnOrder = ['content', 'duration', 'spent'];
            SettingsStore.data.columnWidths = SettingsStore.data.calendarColumnWidths;

            const colOrder = SettingsStore.data.columnOrder;
            const widths = SettingsStore.data.columnWidths || {};
            const headers = {
                pinned: `<th data-col="pinned" style="width: ${widths.pinned || 48}px; min-width: ${widths.pinned || 48}px; max-width: ${widths.pinned || 48}px; text-align: center; white-space: nowrap; overflow: hidden;">📌<span class="tm-col-resize" onmousedown="startColResize(event, 'pinned')"></span></th>`,
                content: `<th data-col="content" style="width: ${widths.content || 360}px; min-width: ${widths.content || 360}px; max-width: ${widths.content || 360}px; white-space: nowrap; overflow: hidden;">任务内容<span class="tm-col-resize" onmousedown="startColResize(event, 'content')"></span></th>`,
                score: `<th data-col="score" style="width: ${widths.score || 96}px; min-width: ${widths.score || 96}px; max-width: ${widths.score || 96}px; text-align: center; white-space: nowrap; overflow: hidden;">优先级<span class="tm-col-resize" onmousedown="startColResize(event, 'score')"></span></th>`,
                doc: `<th data-col="doc" style="width: ${widths.doc || 180}px; min-width: ${widths.doc || 180}px; max-width: ${widths.doc || 180}px; white-space: nowrap; overflow: hidden;">文档<span class="tm-col-resize" onmousedown="startColResize(event, 'doc')"></span></th>`,
                h2: (() => {
                    const level = SettingsStore.data.taskHeadingLevel || 'h2';
                    const labels = { h1: '一级标题', h2: '二级标题', h3: '三级标题', h4: '四级标题', h5: '五级标题', h6: '六级标题' };
                    const label = labels[level] || '标题';
                    return `<th data-col="h2" style="width: ${widths.h2 || 180}px; min-width: ${widths.h2 || 180}px; max-width: ${widths.h2 || 180}px; white-space: nowrap; overflow: hidden;">${label}<span class="tm-col-resize" onmousedown="startColResize(event, 'h2')"></span></th>`;
                })(),
                priority: `<th data-col="priority" style="width: ${widths.priority || 96}px; min-width: ${widths.priority || 96}px; max-width: ${widths.priority || 96}px; text-align: center; white-space: nowrap; overflow: hidden;">重要性<span class="tm-col-resize" onmousedown="startColResize(event, 'priority')"></span></th>`,
                startDate: `<th data-col="startDate" style="width: ${widths.startDate || 90}px; min-width: ${widths.startDate || 90}px; max-width: ${widths.startDate || 90}px; white-space: nowrap; overflow: hidden;">开始日期<span class="tm-col-resize" onmousedown="startColResize(event, 'startDate')"></span></th>`,
                completionTime: `<th data-col="completionTime" style="width: ${widths.completionTime || 170}px; min-width: ${widths.completionTime || 170}px; max-width: ${widths.completionTime || 170}px; white-space: nowrap; overflow: hidden;">完成日期<span class="tm-col-resize" onmousedown="startColResize(event, 'completionTime')"></span></th>`,
                duration: `<th data-col="duration" style="width: ${widths.duration || 96}px; min-width: ${widths.duration || 96}px; max-width: ${widths.duration || 96}px; white-space: nowrap; overflow: hidden;">时长<span class="tm-col-resize" onmousedown="startColResize(event, 'duration')"></span></th>`,
                spent: `<th data-col="spent" style="width: ${widths.spent || 96}px; min-width: ${widths.spent || 96}px; max-width: ${widths.spent || 96}px; white-space: nowrap; overflow: hidden;">耗时<span class="tm-col-resize" onmousedown="startColResize(event, 'spent')"></span></th>`,
                remark: `<th data-col="remark" style="width: ${widths.remark || 240}px; min-width: ${widths.remark || 240}px; max-width: ${widths.remark || 240}px; white-space: nowrap; overflow: hidden;">备注<span class="tm-col-resize" onmousedown="startColResize(event, 'remark')"></span></th>`,
                status: `<th data-col="status" style="width: ${widths.status || 96}px; min-width: ${widths.status || 96}px; max-width: ${widths.status || 96}px; text-align: center; white-space: nowrap; overflow: hidden;">状态<span class="tm-col-resize" onmousedown="startColResize(event, 'status')"></span></th>`
            };
            const thead = colOrder.map(col => headers[col] || '').join('');
            return `
                <div class="tm-calendar-task-list" style="height:100%; display:flex; flex-direction:column;">
                    <table class="tm-table" id="tmTaskTable" data-tm-table="calendar">
                        <thead><tr>${thead}</tr></thead>
                        <tbody>${renderTaskList()}</tbody>
                    </table>
                </div>
            `;
        } catch (e) {
            return '';
        } finally {
            SettingsStore.data.columnOrder = originalOrder;
            SettingsStore.data.columnWidths = originalWidths;
        }
    };

    window.tmCalendarApplyCollapseDom = function() {
        try { __tmApplyVisibilityFromState(state.modal); } catch (e) {}
    };

    window.tmCalendarGetTaskDragMeta = function(id) {
        const tid = String(id || '').trim();
        if (!tid) return null;
        const t = state.flatTasks?.[tid] || null;
        if (!t) return null;

        const buildDocsToGroupKey = () => {
            const groups = Array.isArray(SettingsStore.data.docGroups) ? SettingsStore.data.docGroups : [];
            const parts = [];
            for (const g of groups) {
                const gid = String(g?.id || '').trim();
                if (!gid) continue;
                const docs = Array.isArray(g?.docs) ? g.docs : [];
                const ds = docs.map((d) => {
                    const did = String((typeof d === 'object' ? d?.id : d) || '').trim();
                    const rec = !!(typeof d === 'object' && d && d.recursive);
                    if (!did) return '';
                    return did + (rec ? '*' : '');
                }).filter(Boolean);
                parts.push(`${gid}:${ds.join(',')}`);
            }
            return parts.join('|');
        };

        const key = buildDocsToGroupKey();
        let docsToGroup = null;
        const cached = window.__tmCalendarDocsToGroupCache;
        if (cached && cached.key === key && cached.map instanceof Map) {
            docsToGroup = cached.map;
        } else {
            docsToGroup = new Map();
            try {
                const groups = Array.isArray(SettingsStore.data.docGroups) ? SettingsStore.data.docGroups : [];
                groups.forEach((g) => {
                    const gid = String(g?.id || '').trim();
                    const docs = Array.isArray(g?.docs) ? g.docs : [];
                    if (!gid) return;
                    docs.forEach((d) => {
                        const did = String((typeof d === 'object' ? d?.id : d) || '').trim();
                        if (!did) return;
                        if (!docsToGroup.has(did)) docsToGroup.set(did, gid);
                    });
                });
            } catch (e) {}
            try { Promise.resolve().then(() => window.tmCalendarWarmDocsToGroupCache?.()).catch(() => null); } catch (e) {}
        }
        const docId = String(t.root_id || t.docId || '').trim();
        let gid = docId ? String(docsToGroup.get(docId) || '').trim() : '';
        if (!gid && docId) {
            try {
                const groups = Array.isArray(SettingsStore.data.docGroups) ? SettingsStore.data.docGroups : [];
                for (const g of groups) {
                    const gId = String(g?.id || '').trim();
                    if (!gId) continue;
                    const docs = Array.isArray(g?.docs) ? g.docs : [];
                    const hit = docs.some((d) => String((typeof d === 'object' ? d?.id : d) || '').trim() === docId);
                    if (hit) {
                        gid = gId;
                        break;
                    }
                }
            } catch (e) {}
        }
        const calendarId = gid ? `group:${gid}` : 'default';

        const mins = __tmParseDurationMinutes(t?.duration);
        const durationMin = (Number.isFinite(Number(mins)) && Number(mins) > 0) ? Math.round(Number(mins)) : 60;
        const title = String(t.content || '').trim() || '(无标题)';
        return { title, durationMin, calendarId };
    };

    window.tmIsTaskDone = function(id) {
        const tid = String(id || '').trim();
        if (!tid) return false;
        try {
            if (state.doneOverrides && Object.prototype.hasOwnProperty.call(state.doneOverrides, tid)) {
                return !!state.doneOverrides[tid];
            }
        } catch (e) {}
        const t = state.flatTasks?.[tid] || null;
        return !!(t && t.done);
    };

    window.tmCalendarWarmDocsToGroupCache = async function() {
        const groups = Array.isArray(SettingsStore.data.docGroups) ? SettingsStore.data.docGroups : [];
        const parts = [];
        for (const g of groups) {
            const gid = String(g?.id || '').trim();
            if (!gid) continue;
            const docs = Array.isArray(g?.docs) ? g.docs : [];
            const ds = docs.map((d) => {
                const did = String((typeof d === 'object' ? d?.id : d) || '').trim();
                const rec = !!(typeof d === 'object' && d && d.recursive);
                if (!did) return '';
                return did + (rec ? '*' : '');
            }).filter(Boolean);
            parts.push(`${gid}:${ds.join(',')}`);
        }
        const key = parts.join('|');
        const prev = window.__tmCalendarDocsToGroupCache;
        if (prev && prev.key === key && prev.map instanceof Map) return true;

        const map = new Map();
        for (const g of groups) {
            const gid = String(g?.id || '').trim();
            if (!gid) continue;
            const docs = Array.isArray(g?.docs) ? g.docs : [];
            for (const d of docs) {
                const did = String((typeof d === 'object' ? d?.id : d) || '').trim();
                const rec = !!(typeof d === 'object' && d && d.recursive);
                if (!did) continue;
                if (!map.has(did)) map.set(did, gid);
                if (rec && API && typeof API.getSubDocIds === 'function') {
                    try {
                        const subIds = await API.getSubDocIds(did);
                        (Array.isArray(subIds) ? subIds : []).forEach((sid) => {
                            const s = String(sid || '').trim();
                            if (!s) return;
                            if (!map.has(s)) map.set(s, gid);
                        });
                    } catch (e) {}
                }
            }
        }
        window.__tmCalendarDocsToGroupCache = { key, map };
        return true;
    };

    function __tmKanbanClearDragOver(modalEl) {
        const modal = modalEl instanceof Element ? modalEl : state.modal;
        if (!modal) return;
        try {
            const cols = modal.querySelectorAll('.tm-kanban-col.tm-kanban-col--dragover');
            cols.forEach(el => { try { el.classList.remove('tm-kanban-col--dragover'); } catch (e) {} });
        } catch (e) {}
    }

    function __tmKanbanGetCollapsedSet() {
        if (!(state.__tmKanbanCollapsedIds instanceof Set)) state.__tmKanbanCollapsedIds = new Set();
        return state.__tmKanbanCollapsedIds;
    }

    function __tmKanbanPersistCollapsed() {
        try {
            const s = __tmKanbanGetCollapsedSet();
            const arr = Array.from(s).map(x => String(x || '').trim()).filter(Boolean);
            SettingsStore.data.kanbanCollapsedTaskIds = arr;
            try { Storage.set('tm_kanban_collapsed_task_ids', arr); } catch (e) {}
            SettingsStore.save();
        } catch (e) {}
    }

    window.tmKanbanToggleCollapse = function(id, ev) {
        try {
            ev?.stopPropagation?.();
            ev?.preventDefault?.();
        } catch (e) {}
        const tid = String(id || '').trim();
        if (!tid) return;
        const s = __tmKanbanGetCollapsedSet();
        if (s.has(tid)) s.delete(tid);
        else s.add(tid);
        __tmKanbanPersistCollapsed();
        render();
    };

    function __tmKanbanCollectDescendantIds(rootId) {
        const id0 = String(rootId || '').trim();
        if (!id0) return [];
        const out = [];
        const seen = new Set();
        const walk = (id) => {
            const tid = String(id || '').trim();
            if (!tid || seen.has(tid)) return;
            seen.add(tid);
            out.push(tid);
            const t = state.flatTasks[tid];
            const kids = Array.isArray(t?.children) ? t.children : [];
            kids.forEach(k => walk(k?.id));
        };
        walk(id0);
        return out;
    }

    async function __tmKanbanWaitForUnlock(timeoutMs = 8000) {
        const start = Date.now();
        while (GlobalLock.isLocked()) {
            if (Date.now() - start > timeoutMs) return false;
            await new Promise(r => setTimeout(r, 32));
        }
        return true;
    }

    window.tmKanbanDragStart = function(ev, id) {
        try { ev.stopPropagation(); } catch (e) {}
        const taskId = String(id || '').trim();
        if (!taskId) return;
        state.draggingTaskId = taskId;
        try { ev.dataTransfer.effectAllowed = 'move'; } catch (e) {}
        try { ev.dataTransfer.setData('application/x-tm-task-id', taskId); } catch (e) {}
        try { ev.dataTransfer.setData('text/plain', taskId); } catch (e) {}
        state.__tmKanbanDragId = taskId;
        state.__tmKanbanDragIds = [taskId];
        try { ev.currentTarget?.classList?.add?.('tm-kanban-card--dragging'); } catch (e) {}

        if (!SettingsStore.data.kanbanDragSyncSubtasks) {
            try {
                const target = ev.currentTarget;
                if (target instanceof Element && target.querySelector('.tm-kanban-subtasks')) {
                    const clone = target.cloneNode(true);
                    const sub = clone.querySelector('.tm-kanban-subtasks');
                    if (sub) sub.remove();
                    clone.style.position = 'absolute';
                    clone.style.top = '-9999px';
                    clone.style.left = '-9999px';
                    clone.style.width = `${target.offsetWidth}px`;
                    clone.style.background = getComputedStyle(target).background;
                    document.body.appendChild(clone);
                    const rect = target.getBoundingClientRect();
                    ev.dataTransfer.setDragImage(clone, ev.clientX - rect.left, ev.clientY - rect.top);
                    setTimeout(() => clone.remove(), 0);
                }
            } catch (e) {
                console.error('Failed to set drag image', e);
            }
        }
    };

    window.tmKanbanDragEnd = function(ev, id) {
        try { ev.currentTarget?.classList?.remove?.('tm-kanban-card--dragging'); } catch (e) {}
        state.draggingTaskId = '';
        try { __tmClearDocTabDropTarget(); } catch (e) {}
        try { delete state.__tmKanbanDragId; } catch (e) {}
        try { delete state.__tmKanbanDragIds; } catch (e) {}
        __tmKanbanClearDragOver();
    };

    window.tmKanbanDragOver = function(ev) {
        try { ev.preventDefault(); } catch (e) {}
        try { ev.dataTransfer.dropEffect = 'move'; } catch (e) {}
        const col = ev?.target instanceof Element ? ev.target.closest('.tm-kanban-col') : null;
        if (!col) return;
        try {
            if (!col.classList.contains('tm-kanban-col--dragover')) {
                __tmKanbanClearDragOver();
                col.classList.add('tm-kanban-col--dragover');
            }
        } catch (e) {}
    };

    window.tmKanbanDragLeave = function(ev) {
        const col = ev?.target instanceof Element ? ev.target.closest('.tm-kanban-col') : null;
        if (!col) return;
        const rel = ev?.relatedTarget instanceof Element ? ev.relatedTarget : null;
        if (rel && col.contains(rel)) return;
        try { col.classList.remove('tm-kanban-col--dragover'); } catch (e) {}
    };

    window.tmKanbanAutoScroll = function(ev) {
        try { ev.preventDefault(); } catch (e) {}
        const modal = state.modal;
        if (!modal) return;
        const body = modal.querySelector('.tm-body.tm-body--kanban');
        if (!body) return;
        const rect = body.getBoundingClientRect();
        const x = ev.clientX;
        const y = ev.clientY;
        const edge = 48;
        const speed = 18;

        const dx = x < rect.left + edge ? -speed : x > rect.right - edge ? speed : 0;
        const dy = y < rect.top + edge ? -speed : y > rect.bottom - edge ? speed : 0;
        if (!dx && !dy) return;

        const prevTs = Number(state.__tmKanbanAutoScrollTs) || 0;
        const now = Date.now();
        if (now - prevTs < 16) return;
        state.__tmKanbanAutoScrollTs = now;

        try { if (dx) body.scrollLeft += dx; } catch (e) {}
        try {
            if (dy) {
                const col = ev?.target instanceof Element ? ev.target.closest('.tm-kanban-col') : null;
                const colBody = col?.querySelector?.('.tm-kanban-col-body');
                if (colBody) colBody.scrollTop += dy;
            }
        } catch (e) {}
    };

    function __tmBindKanbanPan(modalEl) {
        const modal = modalEl instanceof Element ? modalEl : state.modal;
        if (!modal) return;
        const bodyEl = modal.querySelector('.tm-body.tm-body--kanban');
        if (!bodyEl) return;
        if (String(bodyEl.dataset?.tmKanbanPanBound || '') === '1') return;
        bodyEl.dataset.tmKanbanPanBound = '1';
        const clamp0 = (n, min, max) => Math.max(min, Math.min(max, n));

        const onPanPointerDown = (e) => {
            const target = e?.target;
            if (!(target instanceof Element)) return;
            if (e && typeof e.button === 'number' && e.button !== 0) return;
            if (target.closest('input,button,select,textarea,a')) return;
            if (target.closest('.tm-kanban-card,.tm-kanban-chip,.tm-kanban-more,.tm-kanban-toggle,.tm-task-checkbox,.tm-task-content-clickable')) return;
            if ((bodyEl.scrollWidth - bodyEl.clientWidth) <= 2) return;

            const startX = e.clientX;
            const startY = e.clientY;
            const baseScrollLeft = bodyEl.scrollLeft;
            let active = false;
            let ended = false;
            let winMoveBound = false;
            const threshold = 6;

            const cleanup = () => {
                if (ended) return;
                ended = true;
                if (winMoveBound) {
                    try { window.removeEventListener('pointermove', onWinMove, true); } catch (e2) {}
                    try { window.removeEventListener('pointerup', onWinUp, true); } catch (e2) {}
                    try { window.removeEventListener('pointercancel', onWinUp, true); } catch (e2) {}
                    try { window.removeEventListener('blur', onWinUp, true); } catch (e2) {}
                }
                try { bodyEl.style.cursor = ''; } catch (e2) {}
                try { bodyEl.style.userSelect = ''; } catch (e2) {}
            };

            const onWinMove = (ev) => {
                if (ended) return;
                const dx = ev.clientX - startX;
                const dy = ev.clientY - startY;
                if (!active) {
                    if (Math.abs(dx) < threshold) return;
                    if (Math.abs(dx) <= Math.abs(dy)) return;
                    active = true;
                    try { bodyEl.setPointerCapture?.(e.pointerId); } catch (e2) {}
                    try { bodyEl.style.cursor = 'grabbing'; } catch (e2) {}
                    try { bodyEl.style.userSelect = 'none'; } catch (e2) {}
                }
                const maxLeft = Math.max(0, bodyEl.scrollWidth - bodyEl.clientWidth);
                bodyEl.scrollLeft = clamp0(baseScrollLeft - dx, 0, maxLeft);
                try { ev.preventDefault(); } catch (e2) {}
            };

            const onWinUp = () => cleanup();

            winMoveBound = true;
            window.addEventListener('pointermove', onWinMove, true);
            window.addEventListener('pointerup', onWinUp, true);
            window.addEventListener('pointercancel', onWinUp, true);
            window.addEventListener('blur', onWinUp, true);
        };

        bodyEl.addEventListener('pointerdown', onPanPointerDown, { passive: false });
    }

    async function __tmKanbanMoveIdsToStatus(taskIds, targetStatus) {
        const st = String(targetStatus || '').trim();
        const ids0 = Array.isArray(taskIds) ? taskIds : [];
        const ids = Array.from(new Set(ids0.map(x => String(x || '').trim()).filter(Boolean)));
        if (!ids.length || !st) return;
        if (GlobalLock.isLocked()) {
            hint('⚠ 操作频繁，请稍后再试', 'warning');
            return;
        }

        const isDoneCol = st === '__done__';
        for (const id of ids) {
            const t0 = state.flatTasks[id];
            if (!t0) continue;

            if (isDoneCol) {
                if (!t0.done) {
                    const ok0 = await __tmKanbanWaitForUnlock();
                    if (!ok0) break;
                    await tmSetDone(id, true);
                    await __tmKanbanWaitForUnlock();
                }
                continue;
            }

            if (t0.done) {
                const ok0 = await __tmKanbanWaitForUnlock();
                if (!ok0) break;
                await tmSetDone(id, false);
                await __tmKanbanWaitForUnlock();
            }

            const t = state.flatTasks[id];
            if (!t) continue;
            const prev = String(t.customStatus || '').trim() || 'todo';
            if (prev === st) continue;
            t.customStatus = st;
            try {
                await __tmPersistMetaAndAttrsAsync(id, { customStatus: st });
            } catch (e) {
                hint(`❌ 状态更新失败: ${e.message}`, 'error');
                return;
            }
        }

        applyFilters();
        render();
    }

    window.tmKanbanDrop = function(ev) {
        try { ev.preventDefault(); } catch (e) {}
        const col = ev?.target instanceof Element ? ev.target.closest('.tm-kanban-col') : null;
        const st = String(col?.dataset?.status || '').trim();
        __tmKanbanClearDragOver();
        let id = '';
        try { id = String(ev.dataTransfer.getData('text/plain') || '').trim(); } catch (e) {}
        if (!id) id = String(state.__tmKanbanDragId || '').trim();
        if (!id || !st) return;
        let ids = Array.isArray(state.__tmKanbanDragIds) && state.__tmKanbanDragIds.length ? state.__tmKanbanDragIds : [id];
        
        if (SettingsStore.data.kanbanDragSyncSubtasks) {
            const allIds = new Set(ids);
            ids.forEach(rootId => {
                const descendants = __tmKanbanCollectDescendantIds(rootId);
                descendants.forEach(did => allIds.add(did));
            });
            ids = Array.from(allIds);
        }

        __tmKanbanMoveIdsToStatus(ids, st).catch(e => {
            hint(`❌ 操作失败: ${e.message}`, 'error');
        });
    };

    window.tmKanbanPickDate = async function(id, ev) {
        try {
            ev?.stopPropagation?.();
            ev?.preventDefault?.();
        } catch (e) {}
        const tid = String(id || '').trim();
        if (!tid) return;
        const task = state.flatTasks[tid];
        if (!task) return;
        const anchorEl = (ev?.currentTarget instanceof Element)
            ? ev.currentTarget
            : (ev?.target instanceof Element ? ev.target.closest('.tm-kanban-chip') : null);
        const current = String(task.completionTime || '').trim() || String(task.startDate || '').trim();

        if (!(anchorEl instanceof Element)) {
            const next = await showDatePrompt('设置日期', current);
            if (next == null) return;
            try {
                task.completionTime = String(next || '').trim();
                await __tmPersistMetaAndAttrsAsync(tid, { completionTime: String(next || '').trim() });
                applyFilters();
                render();
                hint(next ? '✅ 日期已更新' : '✅ 日期已清空', 'success');
            } catch (e) {
                hint(`❌ 更新失败: ${e.message}`, 'error');
            }
            return;
        }

        __tmOpenInlineEditor(anchorEl, ({ editor, close }) => {
            editor.style.minWidth = '168px';
            editor.style.padding = '8px';

            const input = document.createElement('input');
            input.type = 'date';
            input.className = 'tm-input';
            input.value = __tmNormalizeDateOnly(current || '');
            editor.appendChild(input);

            const clearBtn = document.createElement('button');
            clearBtn.className = 'tm-btn tm-btn-secondary';
            clearBtn.textContent = '清空';
            clearBtn.onclick = async () => {
                try {
                    task.completionTime = '';
                    await __tmPersistMetaAndAttrsAsync(tid, { completionTime: '' });
                    close();
                    applyFilters();
                    render();
                    hint('✅ 日期已清空', 'success');
                } catch (e) {
                    hint(`❌ 更新失败: ${e.message}`, 'error');
                }
            };

            const actions = document.createElement('div');
            actions.className = 'tm-inline-editor-actions';
            actions.appendChild(clearBtn);
            editor.appendChild(actions);

            const save = async () => {
                const raw = String(input.value || '').trim();
                const next = raw ? __tmNormalizeDateOnly(raw) : '';
                try {
                    task.completionTime = next;
                    await __tmPersistMetaAndAttrsAsync(tid, { completionTime: next });
                    close();
                    applyFilters();
                    render();
                    hint(next ? '✅ 日期已更新' : '✅ 日期已清空', 'success');
                } catch (e) {
                    hint(`❌ 更新失败: ${e.message}`, 'error');
                }
            };

            input.onchange = () => { save(); };
            input.onkeydown = (e) => {
                if (e.key === 'Enter') save();
            };
            input.onclick = () => { try { input.showPicker?.(); } catch (e) {} };
            setTimeout(() => {
                try {
                    input.focus();
                    input.showPicker?.();
                } catch (e) {}
            }, 0);
        });
    };

    window.tmGanttZoomIn = function() {
        const next = Math.min(60, Math.max(10, Math.round((Number(state.ganttView?.dayWidth) || 24) + 4)));
        state.ganttView.dayWidth = next;
        render();
    };

    window.tmGanttZoomOut = function() {
        const next = Math.min(60, Math.max(10, Math.round((Number(state.ganttView?.dayWidth) || 24) - 4)));
        state.ganttView.dayWidth = next;
        render();
    };

    window.tmGanttFit = function() {
        if (state.viewMode !== 'timeline') return;
        try {
            const body = state.modal?.querySelector?.('#tmGanttBody');
            const w = body?.clientWidth;
            if (!Number.isFinite(w) || w <= 0) {
                state.ganttView.__forceScrollLeft = 0;
                render();
                return;
            }
            const view = globalThis.__TaskHorizonGanttView;
            const parse = view?.parseDateOnlyToTs;
            const startOfDayTs = view?.startOfDayTs;
            const DAY_MS = Number(view?.DAY_MS) || 86400000;
            if (typeof parse !== 'function' || typeof startOfDayTs !== 'function') {
                state.ganttView.__forceScrollLeft = 0;
                render();
                return;
            }
            const rowModel = __tmBuildTaskRowModel();
            let minTs = 0;
            let maxTs = 0;
            for (const r of rowModel) {
                if (r?.type !== 'task') continue;
                const t = state.flatTasks[String(r.id)];
                if (!t) continue;
                const sTs = parse(t?.startDate);
                const eTs = parse(t?.completionTime);
                const a = sTs || eTs;
                const b = eTs || sTs;
                if (!a || !b) continue;
                if (!minTs || a < minTs) minTs = a;
                if (!maxTs || b > maxTs) maxTs = b;
            }
            const now = Date.now();
            const paddingDays = Math.max(0, Number(state.ganttView?.paddingDays) || 0);
            const pad = paddingDays * DAY_MS;
            const startTs = startOfDayTs((minTs || now) - pad);
            const endTs = startOfDayTs((maxTs || now) + pad);
            const dayCount = Math.max(1, Math.min(366, Math.round((endTs - startTs) / DAY_MS) + 1));
            const usableW = Math.max(120, w - 24);
            const next = Math.max(10, Math.min(60, Math.floor(usableW / dayCount)));
            state.ganttView.dayWidth = next;
            state.ganttView.__forceScrollLeft = 0;
            render();
        } catch (e) {
            try { state.ganttView.__forceScrollLeft = 0; } catch (e2) {}
            render();
        }
    };

    window.tmGanttToday = function() {
        const body = state.modal?.querySelector?.('#tmGanttBody');
        if (!body) return;
        const todayLine = body.querySelector('.tm-gantt-today');
        if (!todayLine) return;
        const left = Number.parseFloat(String(todayLine.style.left || '').replace('px', ''));
        if (!Number.isFinite(left)) return;
        const target = Math.max(0, Math.round(left - body.clientWidth * 0.35));
        body.scrollLeft = target;
        try { body.dispatchEvent(new Event('scroll')); } catch (e) {}
    };

    window.tmToggleDesktopMenu = function(e) {
        if (e) { e.stopPropagation(); e.preventDefault(); }
        
        // 移除现有的菜单
        const existing = document.getElementById('tmDesktopMenu');
        if (existing) {
            try { if (state.desktopMenuCloseTimer) { clearTimeout(state.desktopMenuCloseTimer); state.desktopMenuCloseTimer = null; } } catch (e2) {}
            if (state.desktopMenuCloseHandler) {
                try { document.removeEventListener('click', state.desktopMenuCloseHandler); } catch (e2) {}
                state.desktopMenuCloseHandler = null;
            }
            existing.remove();
            return;
        }
        
        const menu = document.createElement('div');
        menu.id = 'tmDesktopMenu';
        menu.className = 'tm-popup-menu';
        menu.style.cssText = `
            position: absolute;
            top: 45px;
            right: 15px;
            background: var(--tm-bg-color);
            border: 1px solid var(--tm-border-color);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 8px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 140px;
        `;
        
        menu.innerHTML = `
            <button class="tm-btn tm-btn-info" onclick="tmShowSearchModal(); document.getElementById('tmDesktopMenu').remove()" style="text-align:left; padding: 6px 12px;">🔍 搜索${state.searchKeyword ? ` (${String(state.searchKeyword || '').trim()})` : ''}</button>
            <button class="tm-btn tm-btn-info" onclick="tmShowSummaryModal(); document.getElementById('tmDesktopMenu').remove()" style="text-align:left; padding: 6px 12px;">📝 摘要</button>
            <button class="tm-btn tm-btn-info" onclick="tmToggleCalendarSideDock(); document.getElementById('tmDesktopMenu').remove()" style="text-align:left; padding: 6px 12px;">${SettingsStore.data.calendarSideDockEnabled ? '☑' : '☐'} 日历侧边栏</button>
            ${state.searchKeyword ? `<button class="tm-btn tm-btn-secondary" onclick="tmSearch(''); document.getElementById('tmDesktopMenu').remove()" style="text-align:left; padding: 6px 12px;">清除搜索</button>` : ''}
            <button class="tm-btn tm-btn-info" onclick="tmToggleWhiteboardSequenceMode(); document.getElementById('tmDesktopMenu').remove()" style="text-align:left; padding: 6px 12px;">${SettingsStore.data.whiteboardSequenceMode ? '☑' : '☐'} 白板顺序模式</button>
            <button class="tm-btn tm-btn-info" onclick="tmCollapseAllTasks(); document.getElementById('tmDesktopMenu').remove()" style="text-align:left; padding: 6px 12px;">▸ 全部折叠</button>
            <button class="tm-btn tm-btn-info" onclick="tmExpandAllTasks(); document.getElementById('tmDesktopMenu').remove()" style="text-align:left; padding: 6px 12px;">▾ 全部展开</button>
        `;
        
        // 点击外部关闭
        const closeHandler = (ev) => {
            if (!menu.contains(ev.target) && ev.target !== e.target) {
                menu.remove();
                try { document.removeEventListener('click', closeHandler); } catch (e2) {}
                if (state.desktopMenuCloseHandler === closeHandler) state.desktopMenuCloseHandler = null;
            }
        };
        state.desktopMenuCloseHandler = closeHandler;
        try { if (state.desktopMenuCloseTimer) { clearTimeout(state.desktopMenuCloseTimer); state.desktopMenuCloseTimer = null; } } catch (e2) {}
        state.desktopMenuCloseTimer = setTimeout(() => {
            try { document.addEventListener('click', closeHandler); } catch (e2) {}
            try { state.desktopMenuCloseTimer = null; } catch (e2) {}
        }, 0);
        
        const container = document.querySelector('.tm-filter-rule-bar');
        if (container) {
            container.style.position = 'relative';
            container.appendChild(menu);
        }
    };

    window.tmToggleWhiteboardSequenceMode = async function(enabled) {
        const next = (typeof enabled === 'boolean') ? enabled : !SettingsStore.data.whiteboardSequenceMode;
        SettingsStore.data.whiteboardSequenceMode = !!next;
        try { await SettingsStore.save(); } catch (e) {}
        try { applyFilters(); } catch (e) {}
        render();
    };

    function __tmHideMobileMenu() {
        const menu = document.getElementById('tmMobileMenu');
        if (menu) menu.style.display = 'none';
        try { if (state.mobileMenuCloseTimer) { clearTimeout(state.mobileMenuCloseTimer); state.mobileMenuCloseTimer = null; } } catch (e) {}
        if (state.mobileMenuCloseHandler) {
            try { document.removeEventListener('click', state.mobileMenuCloseHandler); } catch (e) {}
            try { document.removeEventListener('touchstart', state.mobileMenuCloseHandler); } catch (e) {}
            state.mobileMenuCloseHandler = null;
        }
    }

    window.tmToggleMobileMenu = function(e) {
        const menu = document.getElementById('tmMobileMenu');
        if (!menu) return;

        const now = Date.now();
        const type = String(e?.type || '');
        if (type.startsWith('touch')) {
            state.mobileMenuLastTouchTs = now;
        } else {
            const lastTouchTs = Number(state.mobileMenuLastTouchTs) || 0;
            if (lastTouchTs && now - lastTouchTs < 500) return;
        }
        if (e) {
            try { e.stopPropagation?.(); } catch (e2) {}
            try { e.preventDefault?.(); } catch (e2) {}
        }

        const open = menu.style.display !== 'none';
        if (!open) {
            menu.style.display = 'block';
            
            if (state.mobileMenuCloseHandler) {
                try { document.removeEventListener('click', state.mobileMenuCloseHandler); } catch (e2) {}
                try { document.removeEventListener('touchstart', state.mobileMenuCloseHandler); } catch (e2) {}
                state.mobileMenuCloseHandler = null;
            }
            const closeHandler = (ev) => {
                if (menu.contains(ev.target)) return;
                if (ev.target.closest('.tm-mobile-menu-btn')) return;
                __tmHideMobileMenu();
            };
            state.mobileMenuCloseHandler = closeHandler;
            
            try { if (state.mobileMenuCloseTimer) { clearTimeout(state.mobileMenuCloseTimer); state.mobileMenuCloseTimer = null; } } catch (e2) {}
            state.mobileMenuCloseTimer = setTimeout(() => {
                try { document.addEventListener('click', closeHandler); } catch (e2) {}
                try { document.addEventListener('touchstart', closeHandler, { passive: true }); } catch (e2) {}
                try { state.mobileMenuCloseTimer = null; } catch (e2) {}
            }, 0);
        } else {
            __tmHideMobileMenu();
        }
    };

    window.tmHideMobileMenu = function() {
        try { __tmHideMobileMenu(); } catch (e) {}
    };

    window.tmClose = function(event) {
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
        state.openToken = (Number(state.openToken) || 0) + 1;
        try { __tmHideMobileMenu(); } catch (e) {}
        try {
            if (state.desktopMenuCloseTimer) {
                clearTimeout(state.desktopMenuCloseTimer);
                state.desktopMenuCloseTimer = null;
            }
            if (state.desktopMenuCloseHandler) {
                document.removeEventListener('click', state.desktopMenuCloseHandler);
                state.desktopMenuCloseHandler = null;
            }
            document.getElementById('tmDesktopMenu')?.remove?.();
        } catch (e) {}
        try {
            if (state.taskContextMenuCloseHandler) {
                document.removeEventListener('click', state.taskContextMenuCloseHandler);
                document.removeEventListener('contextmenu', state.taskContextMenuCloseHandler);
                state.taskContextMenuCloseHandler = null;
            }
            document.getElementById('tm-task-context-menu')?.remove?.();
        } catch (e) {}
        try {
            if (__tmResizeState) {
                document.removeEventListener('mousemove', __tmOnResize);
                document.removeEventListener('mouseup', __tmStopResize);
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                __tmResizeState = null;
            }
        } catch (e) {}
        try {
            if (__tmTimelineSplitResizeOnMove) document.removeEventListener('mousemove', __tmTimelineSplitResizeOnMove);
            if (__tmTimelineSplitResizeOnUp) document.removeEventListener('mouseup', __tmTimelineSplitResizeOnUp);
            __tmTimelineSplitResizeOnMove = null;
            __tmTimelineSplitResizeOnUp = null;
            __tmTimelineSplitResizeState = null;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        } catch (e) {}
        try {
            if (__tmTimelineContentResizeOnMove) document.removeEventListener('mousemove', __tmTimelineContentResizeOnMove);
            if (__tmTimelineContentResizeOnUp) document.removeEventListener('mouseup', __tmTimelineContentResizeOnUp);
            __tmTimelineContentResizeOnMove = null;
            __tmTimelineContentResizeOnUp = null;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        } catch (e) {}
        try {
            if (__tmWhiteboardSidebarResizeOnMove) document.removeEventListener('mousemove', __tmWhiteboardSidebarResizeOnMove);
            if (__tmWhiteboardSidebarResizeOnUp) document.removeEventListener('mouseup', __tmWhiteboardSidebarResizeOnUp);
            __tmWhiteboardSidebarResizeOnMove = null;
            __tmWhiteboardSidebarResizeOnUp = null;
            __tmWhiteboardSidebarResizeState = null;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        } catch (e) {}
        
        // 强制移除所有可能的模态框（防御性编程）
        const modals = document.querySelectorAll('.tm-modal, .tm-settings-modal, .tm-rules-modal, .tm-prompt-modal');
        modals.forEach(el => {
            try { el.remove(); } catch (e) {}
        });

        // 清理状态引用
        state.modal = null;
        state.settingsModal = null;
        state.summaryModal = null;
        state.rulesModal = null;
        state.priorityModal = null;
        state.quickAddModal = null;
        state.exportModal = null;
    };

    // 列宽调整功能
    let __tmResizeState = null;
    let __tmTimelineSplitResizeState = null;
    let __tmTimelineSplitResizeOnMove = null;
    let __tmTimelineSplitResizeOnUp = null;
    let __tmTimelineContentResizeOnMove = null;
    let __tmTimelineContentResizeOnUp = null;
    let __tmWhiteboardSidebarResizeState = null;
    let __tmWhiteboardSidebarResizeOnMove = null;
    let __tmWhiteboardSidebarResizeOnUp = null;

    window.startColResize = function(event, colName) {
        event.preventDefault();
        event.stopPropagation();
        const th = event.target.closest('th');
        const startX = event.clientX;
        const startWidth = th.offsetWidth;
        const isCalendar = !!th.closest('.tm-calendar-task-list');

        __tmResizeState = {
            colName,
            startX,
            startWidth,
            th,
            isCalendar
        };

        document.addEventListener('mousemove', __tmOnResize);
        document.addEventListener('mouseup', __tmStopResize);
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
    };

    function __tmOnResize(event) {
        if (!__tmResizeState) return;
        const deltaX = event.clientX - __tmResizeState.startX;
        const newWidth = Math.max(10, Math.min(800, Math.round(__tmResizeState.startWidth + deltaX)));
        __tmResizeState.th.style.width = newWidth + 'px';
        __tmResizeState.th.style.minWidth = newWidth + 'px';
        __tmResizeState.th.style.maxWidth = newWidth + 'px';
    }

    function __tmStopResize(event) {
        if (!__tmResizeState) return;

        const deltaX = event.clientX - __tmResizeState.startX;
        const newWidth = Math.max(10, Math.min(800, Math.round(__tmResizeState.startWidth + deltaX)));
        
        if (__tmResizeState.isCalendar) {
            if (!SettingsStore.data.calendarColumnWidths) SettingsStore.data.calendarColumnWidths = {};
            SettingsStore.data.calendarColumnWidths[__tmResizeState.colName] = newWidth;
            SettingsStore.save();
        } else {
            SettingsStore.updateColumnWidth(__tmResizeState.colName, newWidth);
        }

        // 清理
        document.removeEventListener('mousemove', __tmOnResize);
        document.removeEventListener('mouseup', __tmStopResize);
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
        __tmResizeState = null;
    };

    window.tmStartTimelineSplitResize = function(event) {
        try { event.preventDefault(); } catch (e) {}
        try { event.stopPropagation(); } catch (e) {}
        const leftEl = state.modal?.querySelector?.('.tm-timeline-left');
        if (!leftEl) return;
        try {
            if (__tmTimelineSplitResizeOnMove) document.removeEventListener('mousemove', __tmTimelineSplitResizeOnMove);
            if (__tmTimelineSplitResizeOnUp) document.removeEventListener('mouseup', __tmTimelineSplitResizeOnUp);
        } catch (e) {}
        __tmTimelineSplitResizeOnMove = null;
        __tmTimelineSplitResizeOnUp = null;
        const startX = event.clientX;
        const startWidth = leftEl.getBoundingClientRect().width;
        __tmTimelineSplitResizeState = { startX, startWidth, leftEl };

        const onMove = (ev) => {
            if (!__tmTimelineSplitResizeState) return;
            const dx = ev.clientX - __tmTimelineSplitResizeState.startX;
            const next = Math.max(360, Math.min(900, Math.round(__tmTimelineSplitResizeState.startWidth + dx)));
            __tmTimelineSplitResizeState.leftEl.style.width = `${next}px`;
        };
        const onUp = async (ev) => {
            if (!__tmTimelineSplitResizeState) return;
            const dx = ev.clientX - __tmTimelineSplitResizeState.startX;
            const next = Math.max(360, Math.min(900, Math.round(__tmTimelineSplitResizeState.startWidth + dx)));
            __tmTimelineSplitResizeState = null;
            try { document.removeEventListener('mousemove', onMove); } catch (e) {}
            try { document.removeEventListener('mouseup', onUp); } catch (e) {}
            __tmTimelineSplitResizeOnMove = null;
            __tmTimelineSplitResizeOnUp = null;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            SettingsStore.data.timelineLeftWidth = next;
            try { await SettingsStore.save(); } catch (e) {}
        };

        __tmTimelineSplitResizeOnMove = onMove;
        __tmTimelineSplitResizeOnUp = onUp;
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
    };

    window.tmStartTimelineContentResize = function(event) {
        try { event.preventDefault(); } catch (e) {}
        try { event.stopPropagation(); } catch (e) {}
        const th = event.target.closest('th');
        if (!th) return;
        try {
            if (__tmTimelineContentResizeOnMove) document.removeEventListener('mousemove', __tmTimelineContentResizeOnMove);
            if (__tmTimelineContentResizeOnUp) document.removeEventListener('mouseup', __tmTimelineContentResizeOnUp);
        } catch (e) {}
        __tmTimelineContentResizeOnMove = null;
        __tmTimelineContentResizeOnUp = null;
        const startX = event.clientX;
        const table = state.modal?.querySelector?.('#tmTimelineLeftTable');
        const col = state.modal?.querySelector?.('#tmTimelineColContent');
        const startWidth = th.getBoundingClientRect().width;
        const startW = Number.isFinite(startWidth) ? startWidth : th.offsetWidth;

        const onMove = (ev) => {
            const dx = ev.clientX - startX;
            const next = Math.max(10, Math.min(800, Math.round(startW + dx)));
            if (col) col.style.width = `${next}px`;
            th.style.width = `${next}px`;
            th.style.minWidth = `${next}px`;
            th.style.maxWidth = `${next}px`;
            const startW2 = Number(SettingsStore.data.columnWidths?.startDate) || 90;
            const endW2 = Number(SettingsStore.data.columnWidths?.completionTime) || 170;
            const total = Math.round(next + startW2 + endW2 + 2);
            if (table) {
                table.style.width = `${total}px`;
                table.style.minWidth = `${total}px`;
                table.style.maxWidth = `${total}px`;
            }
        };

        const onUp = async (ev) => {
            const dx = ev.clientX - startX;
            const next = Math.max(10, Math.min(800, Math.round(startW + dx)));
            try { document.removeEventListener('mousemove', onMove); } catch (e) {}
            try { document.removeEventListener('mouseup', onUp); } catch (e) {}
            __tmTimelineContentResizeOnMove = null;
            __tmTimelineContentResizeOnUp = null;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';

            SettingsStore.data.timelineContentWidth = next;
            try { await SettingsStore.save(); } catch (e) {}
            render();
        };

        __tmTimelineContentResizeOnMove = onMove;
        __tmTimelineContentResizeOnUp = onUp;
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
    };

    window.tmStartWhiteboardSidebarResize = function(event) {
        try { event.preventDefault(); } catch (e) {}
        try { event.stopPropagation(); } catch (e) {}
        if (SettingsStore.data.whiteboardSidebarCollapsed) return;
        const layout = state.modal?.querySelector?.('.tm-whiteboard-layout');
        const sidebar = layout?.querySelector?.('.tm-whiteboard-sidebar');
        if (!layout || !sidebar) return;
        try {
            if (__tmWhiteboardSidebarResizeOnMove) document.removeEventListener('mousemove', __tmWhiteboardSidebarResizeOnMove);
            if (__tmWhiteboardSidebarResizeOnUp) document.removeEventListener('mouseup', __tmWhiteboardSidebarResizeOnUp);
        } catch (e) {}
        __tmWhiteboardSidebarResizeOnMove = null;
        __tmWhiteboardSidebarResizeOnUp = null;
        const startX = event.clientX;
        const startWidth = sidebar.getBoundingClientRect().width;
        __tmWhiteboardSidebarResizeState = { startX, startWidth, layout };

        const onMove = (ev) => {
            if (!__tmWhiteboardSidebarResizeState) return;
            const dx = ev.clientX - __tmWhiteboardSidebarResizeState.startX;
            const next = Math.max(220, Math.min(520, Math.round(__tmWhiteboardSidebarResizeState.startWidth + dx)));
            const el = __tmWhiteboardSidebarResizeState.layout;
            el.style.setProperty('--tm-wb-sidebar-width', `${next}px`);
        };
        const onUp = async (ev) => {
            if (!__tmWhiteboardSidebarResizeState) return;
            const dx = ev.clientX - __tmWhiteboardSidebarResizeState.startX;
            const next = Math.max(220, Math.min(520, Math.round(__tmWhiteboardSidebarResizeState.startWidth + dx)));
            __tmWhiteboardSidebarResizeState = null;
            try { document.removeEventListener('mousemove', onMove); } catch (e) {}
            try { document.removeEventListener('mouseup', onUp); } catch (e) {}
            __tmWhiteboardSidebarResizeOnMove = null;
            __tmWhiteboardSidebarResizeOnUp = null;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            SettingsStore.data.whiteboardSidebarWidth = next;
            try { await SettingsStore.save(); } catch (e) {}
        };

        __tmWhiteboardSidebarResizeOnMove = onMove;
        __tmWhiteboardSidebarResizeOnUp = onUp;
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
    };

    function __tmUpdateTimelineTaskInDOM(taskId) {
        const id = String(taskId || '').trim();
        if (!id) return;
        const task = state.flatTasks?.[id];
        if (!task) return;
        const modal = state.modal;
        if (!modal) return;

        try {
            const row = modal.querySelector(`#tmTimelineLeftTable tbody tr[data-id="${id}"]`);
            if (row) {
                const tds = row.querySelectorAll('td');
                if (tds && tds.length >= 3) {
                    try { tds[1].textContent = __tmFormatTaskTime(task.startDate); } catch (e) {}
                    try { tds[2].textContent = __tmFormatTaskTime(task.completionTime); } catch (e) {}
                }
            }
        } catch (e) {}

        try {
            const ganttBody = modal.querySelector('#tmGanttBody');
            if (!ganttBody) return;
            const rowEl = ganttBody.querySelector(`.tm-gantt-row[data-id="${id}"]`);
            if (!rowEl) return;

            const view = globalThis.__TaskHorizonGanttView;
            if (!view) return;
            const startTs0 = Number(ganttBody.dataset?.tmGanttStartTs);
            const dayWidth0 = Number(ganttBody.dataset?.tmGanttDayWidth);
            const dayCount0 = Number(ganttBody.dataset?.tmGanttDayCount);
            if (!Number.isFinite(startTs0) || !Number.isFinite(dayWidth0) || !Number.isFinite(dayCount0) || dayWidth0 <= 0) return;

            const sTs0 = view.parseDateOnlyToTs(task?.startDate);
            const eTs0 = view.parseDateOnlyToTs(task?.completionTime);
            const aTs = sTs0 || eTs0;
            const bTs = eTs0 || sTs0;
            const milestoneRaw = task?.milestone;
            const isMilestone = typeof milestoneRaw === 'boolean'
                ? milestoneRaw
                : ['1', 'true'].includes(String(milestoneRaw || '').trim().toLowerCase());

            const bar = rowEl.querySelector('.tm-gantt-bar');
            const marker = rowEl.querySelector('.tm-gantt-milestone');
            if (!aTs && !bTs) {
                if (bar) bar.remove();
                if (marker) marker.remove();
                return;
            }

            const dayIdxOf = (ts) => Math.round((view.startOfDayTs(ts) - view.startOfDayTs(startTs0)) / view.DAY_MS);
            const startIdx = __tmClamp(dayIdxOf(aTs), 0, dayCount0 - 1);
            const endIdx = __tmClamp(dayIdxOf(bTs), 0, dayCount0 - 1);
            const left = Math.min(startIdx, endIdx) * dayWidth0;
            const width = (Math.abs(endIdx - startIdx) + 1) * dayWidth0;
            const milestoneLeft = endIdx * dayWidth0 + (dayWidth0 * 0.5);

            const docId = String(task?.docId || task?.root_id || '').trim();
            const isDark = __tmIsDarkMode();
            const baseColor = __tmGetDocColorHex(docId, isDark);
            const done = !!task?.done;
            const barColor = done
                ? __tmDesaturateHex(__tmDarkenHex(baseColor, isDark ? 0.48 : 0.36), isDark ? 0.36 : 0.26)
                : baseColor;

            const title = `${String(task?.content || '').trim()}\n${view.formatDateOnlyFromTs(aTs)} ~ ${view.formatDateOnlyFromTs(bTs)}`;
            const milestoneTitle = `${String(task?.content || '').trim()}\n里程碑：${view.formatDateOnlyFromTs(bTs)}`;

            if (isMilestone && bTs) {
                if (bar) bar.remove();
                if (marker) {
                    marker.style.left = `${milestoneLeft}px`;
                    marker.title = milestoneTitle;
                    return;
                }
                const markerEl = document.createElement('div');
                markerEl.className = 'tm-gantt-milestone';
                markerEl.style.left = `${milestoneLeft}px`;
                markerEl.title = milestoneTitle;
                markerEl.textContent = '🚩';
                rowEl.appendChild(markerEl);
                return;
            }

            if (marker) marker.remove();

            if (bar) {
                bar.style.left = `${left}px`;
                bar.style.width = `${width}px`;
                bar.style.background = barColor;
                bar.style.top = '50%';
                bar.style.transform = 'translateY(-50%)';
                bar.title = title;
                return;
            }

            const barEl = document.createElement('div');
            barEl.className = 'tm-gantt-bar';
            barEl.style.left = `${left}px`;
            barEl.style.width = `${width}px`;
            barEl.style.background = barColor;
            barEl.style.top = '50%';
            barEl.style.transform = 'translateY(-50%)';
            barEl.title = title;
            const h1 = document.createElement('div');
            h1.className = 'tm-gantt-bar-handle tm-gantt-bar-handle--start';
            h1.setAttribute('data-handle', 'start');
            const h2 = document.createElement('div');
            h2.className = 'tm-gantt-bar-handle tm-gantt-bar-handle--end';
            h2.setAttribute('data-handle', 'end');
            barEl.appendChild(h1);
            barEl.appendChild(h2);
            rowEl.appendChild(barEl);
        } catch (e) {}
    }

    function normalizeTaskFields(task, docNameFallback) {
        if (!task || typeof task !== 'object') return task;

        const isValidValue = (val) => val !== undefined && val !== null && val !== '' && val !== 'null';

        const normalizePriority = (raw) => {
            const s = String(raw ?? '').trim();
            if (!s) return '';
            const map = {
                high: 'high',
                medium: 'medium',
                low: 'low',
                none: '',
                '高': 'high',
                '中': 'medium',
                '低': 'low',
                '无': '',
            };
            if (Object.prototype.hasOwnProperty.call(map, s)) return map[s];
            const lower = s.toLowerCase();
            if (Object.prototype.hasOwnProperty.call(map, lower)) return map[lower];
            return '';
        };
        const p0 = task.priority ?? task.customPriority ?? task.custom_priority ?? '';
        task.priority = normalizePriority(p0);
        const milestone0 = task.milestone ?? task.customMilestone ?? task.custom_milestone ?? '';
        if (typeof milestone0 === 'boolean') {
            task.milestone = milestone0;
        } else {
            const ms = String(milestone0 || '').trim().toLowerCase();
            task.milestone = ms === 'true' || ms === '1';
        }
        task.duration = isValidValue(task.duration) ? String(task.duration) : (isValidValue(task.custom_duration) ? String(task.custom_duration) : '');
        task.remark = isValidValue(task.remark) ? String(task.remark) : (isValidValue(task.custom_remark) ? String(task.custom_remark) : '');
        task.completionTime = isValidValue(task.completionTime) ? String(task.completionTime) : (isValidValue(task.completion_time) ? String(task.completion_time) : '');
        task.startDate = isValidValue(task.startDate) ? String(task.startDate) : (isValidValue(task.start_date) ? String(task.start_date) : '');
        task.customTime = isValidValue(task.customTime) ? String(task.customTime) : (isValidValue(task.custom_time) ? String(task.custom_time) : '');
        task.customStatus = isValidValue(task.customStatus) ? String(task.customStatus) : (isValidValue(task.custom_status) ? String(task.custom_status) : '');
        task.tomatoMinutes = isValidValue(task.tomatoMinutes) ? String(task.tomatoMinutes) : (isValidValue(task.tomato_minutes) ? String(task.tomato_minutes) : '');
        task.tomatoHours = isValidValue(task.tomatoHours) ? String(task.tomatoHours) : (isValidValue(task.tomato_hours) ? String(task.tomato_hours) : '');
        const pin0 = task.pinned ?? task.customPinned ?? task.custom_pinned ?? '';
        if (typeof pin0 === 'boolean') {
            task.pinned = pin0;
        } else {
            const s = String(pin0 || '').trim().toLowerCase();
            task.pinned = s === 'true' || s === '1';
        }

        const meta = MetaStore.get(task.id);
        if (meta) {
            if ('pinned' in meta) {
                const ms = meta.pinned;
                if (typeof ms === 'boolean') task.pinned = ms;
                else {
                    const s = String(ms || '').trim().toLowerCase();
                    if (s === 'true' || s === '1' || s === '') task.pinned = s === 'true' || s === '1';
                }
            }
            if ('milestone' in meta) {
                const ms = meta.milestone;
                if (typeof ms === 'boolean') task.milestone = ms;
                else {
                    const s = String(ms || '').trim().toLowerCase();
                    if (s === 'true' || s === '1' || s === '') task.milestone = s === 'true' || s === '1';
                }
            }
            if (!isValidValue(task.priority) && isValidValue(meta.priority)) task.priority = normalizePriority(meta.priority);
            if (!isValidValue(task.duration) && isValidValue(meta.duration)) task.duration = meta.duration;
            if (!isValidValue(task.remark) && isValidValue(meta.remark)) task.remark = meta.remark;
            if (!isValidValue(task.completionTime) && isValidValue(meta.completionTime)) task.completionTime = meta.completionTime;
            if (!isValidValue(task.startDate) && isValidValue(meta.startDate)) task.startDate = meta.startDate;
            if (!isValidValue(task.customTime) && isValidValue(meta.customTime)) task.customTime = meta.customTime;
            if (!isValidValue(task.customStatus) && isValidValue(meta.customStatus)) task.customStatus = meta.customStatus;
        }

        task.docName = task.docName || task.doc_name || docNameFallback || '未知文档';
        task.parentTaskId = task.parentTaskId || task.parent_task_id || null;
        task.docId = task.docId || task.root_id || null;
        task.docSeq = Number.isFinite(Number(task.docSeq ?? task.doc_seq)) ? Number(task.docSeq ?? task.doc_seq) : Number.POSITIVE_INFINITY;
        task.blockPath = String(task.blockPath || task.block_path || task.path || '').trim();
        task.blockSort = String(task.blockSort || task.block_sort || task.sort || '').trim();
        return task;
    }

    function __tmFormatDate(value) {
        if (!value) return '';
        const d = new Date(value);
        if (Number.isNaN(d.getTime())) return '';
        return d.toLocaleDateString();
    }

    function __tmFormatTaskTime(value) {
        const s = String(value || '').trim();
        if (!s) return '';
        if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
        if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(s)) return s.slice(0, 10);
        if (/^\d{14}$/.test(s)) return `${s.slice(0, 4)}-${s.slice(4, 6)}-${s.slice(6, 8)}`;
        if (/^\d{8}$/.test(s)) return `${s.slice(0, 4)}-${s.slice(4, 6)}-${s.slice(6, 8)}`;
        if (/^\d+$/.test(s)) {
            const n = Number(s);
            if (Number.isFinite(n) && n > 0) {
                const ts = n < 1e12 ? n * 1000 : n;
                const d0 = new Date(ts);
                if (!Number.isNaN(d0.getTime())) {
                    const pad = (n) => String(n).padStart(2, '0');
                    return `${d0.getFullYear()}-${pad(d0.getMonth() + 1)}-${pad(d0.getDate())}`;
                }
            }
        }
        const d = new Date(s);
        if (Number.isNaN(d.getTime())) return s;
        const pad = (n) => String(n).padStart(2, '0');
        return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
    }

    function __tmGetTaskSpentMinutes(task) {
        if (!SettingsStore.data.enableTomatoIntegration) return null;
        const mode = String(SettingsStore.data.tomatoSpentAttrMode || 'minutes').trim() || 'minutes';
        if (mode === 'hours') return null;
        const m = __tmParseNumber(task?.tomatoMinutes);
        if (!Number.isFinite(m) || m <= 0) return null;
        return Math.round(m);
    }

    function __tmFormatSpentHours(hours) {
        const n = Number(hours);
        if (!Number.isFinite(n) || n <= 0) return '';
        const rounded = Math.round(n * 100) / 100;
        return String(rounded);
    }

    function __tmFormatSpentMinutes(minutes) {
        const n = Number(minutes);
        if (!Number.isFinite(n) || n <= 0) return '';
        const total = Math.round(n);
        const h = Math.floor(total / 60);
        const m = total % 60;
        if (h > 0 && m > 0) return `${h}h${m}m`;
        if (h > 0) return `${h}h`;
        return `${m}m`;
    }

    function __tmNormalizeDateOnly(value) {
        const s = String(value || '').trim();
        if (!s) return '';
        if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
        if (/^\d{4}-\d{2}-\d{2}T/.test(s)) return s.slice(0, 10);
        if (/^\d{4}-\d{2}-\d{2}\s/.test(s)) return s.slice(0, 10);
        const d = new Date(s);
        if (Number.isNaN(d.getTime())) return '';
        const pad = (n) => String(n).padStart(2, '0');
        return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
    }

    function __tmParseTimeToTs(value) {
        const s = String(value || '').trim();
        if (!s) return 0;
        if (/^\d{14}$/.test(s)) {
            const y = Number(s.slice(0, 4));
            const mon = Number(s.slice(4, 6)) - 1;
            const d = Number(s.slice(6, 8));
            const hh = Number(s.slice(8, 10));
            const mm = Number(s.slice(10, 12));
            const ss = Number(s.slice(12, 14));
            const dt = new Date(y, mon, d, hh, mm, ss, 0);
            return Number.isNaN(dt.getTime()) ? 0 : dt.getTime();
        }
        if (/^\d{8}$/.test(s)) {
            const y = Number(s.slice(0, 4));
            const mon = Number(s.slice(4, 6)) - 1;
            const d = Number(s.slice(6, 8));
            const dt = new Date(y, mon, d, 12, 0, 0, 0);
            return Number.isNaN(dt.getTime()) ? 0 : dt.getTime();
        }
        if (/^\d+$/.test(s)) {
            const n = Number(s);
            if (!Number.isFinite(n) || n <= 0) return 0;
            const ts = n < 1e12 ? n * 1000 : n;
            return ts;
        }
        if (/^\d{4}-\d{2}-\d{2}$/.test(s)) {
            const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(s);
            const y = Number(m[1]);
            const mon = Number(m[2]) - 1;
            const d = Number(m[3]);
            const dt = new Date(y, mon, d, 12, 0, 0, 0);
            return Number.isNaN(dt.getTime()) ? 0 : dt.getTime();
        }
        const t = new Date(s).getTime();
        return Number.isNaN(t) ? 0 : t;
    }

    function __tmParseDurationMinutes(value) {
        const s = String(value || '').trim();
        if (!s) return null;
        const fmt = String(SettingsStore?.data?.durationFormat || 'hours').trim();
        const numberToMinutes = (n) => {
            if (!Number.isFinite(n) || n < 0) return null;
            if (fmt === 'hours') return n * 60;
            return n;
        };
        if (/^\d+(\.\d+)?$/.test(s)) {
            const n = Number(s);
            return numberToMinutes(n);
        }
        let total = 0;
        let matched = false;
        const re = /(\d+(?:\.\d+)?)\s*([dhm])/ig;
        let m;
        while ((m = re.exec(s))) {
            matched = true;
            const n = Number(m[1]);
            const unit = String(m[2] || '').toLowerCase();
            if (!Number.isFinite(n)) continue;
            if (unit === 'd') total += n * 1440;
            else if (unit === 'h') total += n * 60;
            else total += n;
        }
        if (matched) return total;
        const n0 = Number.parseFloat(s);
        return numberToMinutes(n0);
    }

    function __tmGetTaskDocIdById(taskId) {
        const id = String(taskId || '').trim();
        if (!id) return '';
        const t = state.flatTasks?.[id];
        if (t) return String(t?.root_id || t?.docId || '').trim();
        const snap = WhiteboardStore.getTask(id);
        if (!snap) return '';
        return String(snap?.docId || '').trim();
    }

    function __tmGetWhiteboardCardSnapshotMap() {
        try { WhiteboardStore.normalize(); } catch (e) {}
        const raw = WhiteboardStore.data?.cards;
        if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return {};
        return raw;
    }

    function __tmGetWhiteboardCardSnapshot(taskId) {
        const id = String(taskId || '').trim();
        if (!id) return null;
        const map = __tmGetWhiteboardCardSnapshotMap();
        const item = map[id];
        return (item && typeof item === 'object') ? item : null;
    }

    function __tmUpsertWhiteboardTaskSnapshot(task, opts = {}) {
        WhiteboardStore.upsertTask(task, opts);
    }

    function __tmUpsertWhiteboardTaskSnapshots(tasks, opts = {}) {
        WhiteboardStore.upsertTasks(tasks, opts);
    }

    function __tmDeleteWhiteboardSnapshotTasks(taskIds) {
        const list = Array.isArray(taskIds) ? taskIds : [];
        const ids = list.map((x) => String(x || '').trim()).filter(Boolean);
        if (!ids.length) return;
        const idSet = new Set(ids);
        try { WhiteboardStore.normalize(); } catch (e) {}
        try {
            const cards = (WhiteboardStore.data && WhiteboardStore.data.cards && typeof WhiteboardStore.data.cards === 'object')
                ? WhiteboardStore.data.cards
                : {};
            let changed = false;
            ids.forEach((id) => {
                if (cards[id]) {
                    delete cards[id];
                    changed = true;
                }
            });
            if (changed) {
                const links0 = Array.isArray(WhiteboardStore.data.links) ? WhiteboardStore.data.links : [];
                WhiteboardStore.data.links = links0.filter((ln) => {
                    const from = String(ln?.from || '').trim();
                    const to = String(ln?.to || '').trim();
                    return !idSet.has(from) && !idSet.has(to);
                });
                WhiteboardStore.scheduleSave();
            }
        } catch (e) {}
        try {
            const pos0 = __tmGetWhiteboardNodePosMap();
            const pos = { ...pos0 };
            let dirty = false;
            ids.forEach((id) => {
                if (id in pos) {
                    delete pos[id];
                    dirty = true;
                }
            });
            if (dirty) SettingsStore.data.whiteboardNodePos = pos;
        } catch (e) {}
        try {
            const placed0 = __tmGetWhiteboardPlacedTaskMap();
            const placed = { ...placed0 };
            let dirty = false;
            ids.forEach((id) => {
                if (id in placed) {
                    delete placed[id];
                    dirty = true;
                }
            });
            if (dirty) SettingsStore.data.whiteboardPlacedTaskIds = placed;
        } catch (e) {}
        try { SettingsStore.syncToLocal(); } catch (e) {}
    }

    function __tmSyncWhiteboardFrozenTasksWithLiveTasks() {
        const flat = (state.flatTasks && typeof state.flatTasks === 'object') ? state.flatTasks : {};
        const liveIdSet = new Set(Object.keys(flat).map((x) => String(x || '').trim()).filter(Boolean));
        const snapMap = __tmGetWhiteboardCardSnapshotMap();
        const scopeDocSet = new Set(
            (Array.isArray(state.taskTree) ? state.taskTree : [])
                .map((d) => String(d?.id || '').trim())
                .filter(Boolean)
        );
        if (!scopeDocSet.size) return 0;
        const staleIds = Object.keys(snapMap || {})
            .map((x) => String(x || '').trim())
            .filter((id) => {
                if (!id || liveIdSet.has(id)) return false;
                const snap = snapMap?.[id];
                const docId = String(snap?.docId || __tmGetTaskDocIdById(id) || '').trim();
                if (!docId) return false;
                // 仅清理“当前加载文档范围”内的冻结任务，避免跨分组误删
                return scopeDocSet.has(docId);
            });
        if (!staleIds.length) return 0;
        const staleSet = new Set(staleIds);
        __tmDeleteWhiteboardSnapshotTasks(staleIds);
        try {
            const links = __tmGetManualTaskLinks();
            const nextLinks = links.filter((ln) => !staleSet.has(String(ln?.from || '').trim()) && !staleSet.has(String(ln?.to || '').trim()));
            __tmSetManualTaskLinks(nextLinks);
        } catch (e) {}
        try {
            const detached0 = __tmGetDetachedChildrenMap();
            const detached = { ...detached0 };
            let dirty = false;
            staleIds.forEach((id) => {
                if (id in detached) {
                    delete detached[id];
                    dirty = true;
                }
            });
            if (dirty) SettingsStore.data.whiteboardDetachedChildren = detached;
        } catch (e) {}
        try {
            if (staleSet.has(String(state.whiteboardSelectedTaskId || '').trim())) state.whiteboardSelectedTaskId = '';
            const multiTaskIds = Array.isArray(state.whiteboardMultiSelectedTaskIds) ? state.whiteboardMultiSelectedTaskIds : [];
            state.whiteboardMultiSelectedTaskIds = multiTaskIds.filter((id) => !staleSet.has(String(id || '').trim()));
        } catch (e) {}
        try { SettingsStore.syncToLocal(); } catch (e) {}
        return staleIds.length;
    }

    function __tmTaskCreatedOrderValue(task) {
        const raw = String(task?.created || '').trim();
        if (!raw) return Number.MAX_SAFE_INTEGER;
        if (/^\d{14}$/.test(raw)) return Number(raw);
        const ts = __tmParseTimeToTs(raw);
        return ts > 0 ? ts : Number.MAX_SAFE_INTEGER;
    }

    function __tmNormalizeTaskLinkEntry(link, index) {
        const item = (link && typeof link === 'object') ? link : {};
        const from = String(item.from || '').trim();
        const to = String(item.to || '').trim();
        if (!from || !to || from === to) return null;
        const docFrom = __tmGetTaskDocIdById(from);
        const docTo = __tmGetTaskDocIdById(to);
        const docId = String(item.docId || docFrom || docTo || '').trim();
        if (!docId) return null;
        if (docFrom && docTo && docFrom !== docTo) return null;
        if ((docFrom && docFrom !== docId) || (docTo && docTo !== docId)) return null;
        const createdAt = String(item.createdAt || '').trim() || String(Date.now());
        const idRaw = String(item.id || '').trim();
        const id = idRaw || `link_${docId}_${from}_${to}_${index}`;
        return { id, from, to, docId, createdAt, manual: true };
    }

    function __tmGetManualTaskLinks() {
        const srcA = Array.isArray(SettingsStore.data.whiteboardLinks) ? SettingsStore.data.whiteboardLinks : [];
        const srcB = Array.isArray(WhiteboardStore.data?.links) ? WhiteboardStore.data.links : [];
        if (srcA.length > 0 && srcB.length === 0) {
            try {
                WhiteboardStore.data.links = srcA.slice();
                WhiteboardStore.scheduleSave();
            } catch (e) {}
        }
        const src = [...srcA, ...srcB];
        const out = [];
        const seen = new Set();
        src.forEach((link, index) => {
            const normalized = __tmNormalizeTaskLinkEntry(link, index);
            if (!normalized) return;
            const key = `${normalized.docId}::${normalized.from}->${normalized.to}`;
            if (seen.has(key)) return;
            seen.add(key);
            out.push(normalized);
        });
        return out;
    }

    function __tmGetAutoTaskLinks() {
        return [];
    }

    function __tmGetAllTaskLinks(options = {}) {
        const opt = (options && typeof options === 'object') ? options : {};
        const includeAuto = opt.includeAuto !== false;
        const onlyDocId = String(opt.docId || '').trim();
        const links = [...__tmGetManualTaskLinks(), ...(includeAuto ? __tmGetAutoTaskLinks() : [])];
        const seen = new Set();
        return links.filter((link) => {
            if (!link || typeof link !== 'object') return false;
            const fromId = String(link.from || '').trim();
            const toId = String(link.to || '').trim();
            const docId = String(link.docId || '').trim();
            if (!fromId || !toId || !docId || fromId === toId) return false;
            if (onlyDocId && docId !== onlyDocId) return false;
            const fromDoc = __tmGetTaskDocIdById(fromId);
            const toDoc = __tmGetTaskDocIdById(toId);
            if (fromDoc && fromDoc !== docId) return false;
            if (toDoc && toDoc !== docId) return false;
            const key = `${docId}::${fromId}->${toId}`;
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
        });
    }

    function __tmCanLinkTasks(fromTaskId, toTaskId) {
        const fromId = String(fromTaskId || '').trim();
        const toId = String(toTaskId || '').trim();
        if (!fromId || !toId || fromId === toId) return { ok: false, reason: '无效任务' };
        const fromDocId = __tmGetTaskDocIdById(fromId);
        const toDocId = __tmGetTaskDocIdById(toId);
        if (!fromDocId || !toDocId) return { ok: false, reason: '任务不存在' };
        if (fromDocId !== toDocId) return { ok: false, reason: '不支持跨文档连线' };
        return { ok: true, docId: fromDocId };
    }

    function __tmSetManualTaskLinks(nextLinks) {
        const list = Array.isArray(nextLinks) ? nextLinks : [];
        const normalized = list.map((it, i) => {
            const x = __tmNormalizeTaskLinkEntry(it, i);
            return x ? { id: x.id, from: x.from, to: x.to, docId: x.docId, createdAt: x.createdAt } : null;
        }).filter(Boolean);
        SettingsStore.data.whiteboardLinks = normalized;
        try {
            WhiteboardStore.data.links = normalized;
            WhiteboardStore.scheduleSave();
        } catch (e) {}
        try { SettingsStore.syncToLocal(); } catch (e) {}
    }

    function __tmGetTaskLinkStats(taskId, options = {}) {
        const id = String(taskId || '').trim();
        if (!id) return { incoming: 0, outgoing: 0 };
        let incoming = 0;
        let outgoing = 0;
        __tmGetAllTaskLinks(options).forEach((link) => {
            if (String(link.from || '') === id) outgoing += 1;
            if (String(link.to || '') === id) incoming += 1;
        });
        return { incoming, outgoing };
    }

    function __tmGetDetachedChildrenMap() {
        const map0 = SettingsStore.data.whiteboardDetachedChildren;
        if (!map0 || typeof map0 !== 'object' || Array.isArray(map0)) return {};
        const next = {};
        let changed = false;
        Object.keys(map0).forEach((k) => {
            const id = String(k || '').trim();
            if (!id) {
                changed = true;
                return;
            }
            const v = map0[k];
            const taskPid = String(state.flatTasks?.[id]?.parentTaskId || '').trim();
            const snapPid = String(__tmGetWhiteboardCardSnapshot(id)?.parentTaskId || '').trim();
            if (v && typeof v === 'object' && v.detached === true) {
                const parentTaskId = String(v.parentTaskId || taskPid || snapPid || '').trim();
                const normalized = { ...v, detached: true, parentTaskId };
                next[id] = normalized;
                if (String(v.parentTaskId || '').trim() !== parentTaskId) changed = true;
                return;
            }
            if (v === true) {
                next[id] = { detached: true, manual: true, updatedAt: String(Date.now()), parentTaskId: String(taskPid || snapPid || '').trim() };
                changed = true;
                return;
            }
            changed = true;
        });
        if (changed) {
            SettingsStore.data.whiteboardDetachedChildren = next;
            try { SettingsStore.syncToLocal(); } catch (e) {}
        }
        return changed ? next : map0;
    }

    function __tmIsWhiteboardChildDetached(taskId) {
        const id = String(taskId || '').trim();
        if (!id) return false;
        const map = __tmGetDetachedChildrenMap();
        const item = map[id];
        return !!(item && typeof item === 'object' && item.detached === true);
    }

    function __tmResolveWhiteboardTaskParentId(taskId) {
        const id = String(taskId || '').trim();
        if (!id) return '';
        const task = state.flatTasks?.[id];
        const fromTask = String(task?.parentTaskId || '').trim();
        if (fromTask) return fromTask;
        const detachedMap = __tmGetDetachedChildrenMap();
        const detachedItem = detachedMap[id];
        const fromDetached = String(detachedItem?.parentTaskId || '').trim();
        if (fromDetached) return fromDetached;
        const snap = __tmGetWhiteboardCardSnapshot(id);
        return String(snap?.parentTaskId || '').trim();
    }

    function __tmSetWhiteboardChildDetached(taskId, detached, parentTaskId = '') {
        const id = String(taskId || '').trim();
        if (!id) return;
        const next = { ...__tmGetDetachedChildrenMap() };
        if (detached) {
            const pid = String(parentTaskId || __tmResolveWhiteboardTaskParentId(id) || '').trim();
            next[id] = { detached: true, manual: true, updatedAt: String(Date.now()), parentTaskId: pid };
        } else delete next[id];
        SettingsStore.data.whiteboardDetachedChildren = next;
        try { SettingsStore.syncToLocal(); } catch (e) {}
    }

    function __tmWhiteboardCollectTaskTreeIds(rootId, opts = {}) {
        const id0 = String(rootId || '').trim();
        if (!id0) return [];
        const o = (opts && typeof opts === 'object') ? opts : {};
        const includeRoot = o.includeRoot !== false;
        const includeDetached = o.includeDetached === true;
        const includeSnapshotTree = o.includeSnapshotTree !== false;
        const snapMap = includeSnapshotTree ? __tmGetWhiteboardCardSnapshotMap() : {};
        const snapChildrenMap = new Map();
        if (includeSnapshotTree && snapMap && typeof snapMap === 'object') {
            Object.keys(snapMap).forEach((idRaw) => {
                const sid = String(idRaw || '').trim();
                if (!sid) return;
                const s = snapMap[sid];
                if (!s || typeof s !== 'object') return;
                const pid = String(s.parentTaskId || '').trim();
                if (!pid) return;
                if (!snapChildrenMap.has(pid)) snapChildrenMap.set(pid, []);
                snapChildrenMap.get(pid).push(sid);
            });
        }
        const out = [];
        const seen = new Set();
        const stack = [id0];
        while (stack.length) {
            const cur = String(stack.pop() || '').trim();
            if (!cur || seen.has(cur)) continue;
            seen.add(cur);
            if (includeRoot || cur !== id0) out.push(cur);
            const task = state.flatTasks?.[cur];
            const kids = Array.isArray(task?.children) ? task.children : [];
            kids.forEach((k) => {
                const cid = String(k?.id || '').trim();
                if (!cid) return;
                if (!includeDetached && __tmIsWhiteboardChildDetached(cid)) return;
                stack.push(cid);
            });
            if (includeSnapshotTree) {
                const skids = snapChildrenMap.get(cur) || [];
                skids.forEach((sid) => {
                    const cid = String(sid || '').trim();
                    if (!cid) return;
                    if (!includeDetached && __tmIsWhiteboardChildDetached(cid)) return;
                    stack.push(cid);
                });
            }
        }
        return out;
    }

    function __tmFindWhiteboardCollapsedProxyTaskId(taskId, docId) {
        const id0 = String(taskId || '').trim();
        const did = String(docId || '').trim();
        if (!id0 || !did) return '';
        const collapsed = __tmKanbanGetCollapsedSet();
        const getParentId = (id) => {
            const tid = String(id || '').trim();
            if (!tid) return '';
            const t = state.flatTasks?.[tid];
            if (t) return String(t?.parentTaskId || '').trim();
            const snap = __tmGetWhiteboardCardSnapshot(tid);
            return String(snap?.parentTaskId || '').trim();
        };
        let cur = id0;
        const seen = new Set();
        while (cur && !seen.has(cur)) {
            seen.add(cur);
            const parentId = getParentId(cur);
            if (!parentId) return '';
            if (__tmIsWhiteboardChildDetached(cur)) return '';
            if (collapsed.has(parentId) && __tmIsWhiteboardTaskPlaced(parentId) && __tmGetTaskDocIdById(parentId) === did) {
                return parentId;
            }
            cur = parentId;
        }
        return '';
    }

    function __tmGetWhiteboardView() {
        const raw = (SettingsStore.data.whiteboardView && typeof SettingsStore.data.whiteboardView === 'object')
            ? SettingsStore.data.whiteboardView
            : {};
        const x = Number(raw.x);
        const y = Number(raw.y);
        const zoom = Number(raw.zoom);
        return {
            x: Number.isFinite(x) ? x : 64,
            y: Number.isFinite(y) ? y : 40,
            zoom: Number.isFinite(zoom) ? Math.max(0.35, Math.min(2.5, zoom)) : 1,
        };
    }

    function __tmSetWhiteboardView(patch, opts = {}) {
        const p = (patch && typeof patch === 'object') ? patch : {};
        const o = (opts && typeof opts === 'object') ? opts : {};
        const prev = __tmGetWhiteboardView();
        const x = Number.isFinite(Number(p.x)) ? Number(p.x) : prev.x;
        const y = Number.isFinite(Number(p.y)) ? Number(p.y) : prev.y;
        const zoom0 = Number.isFinite(Number(p.zoom)) ? Number(p.zoom) : prev.zoom;
        const zoom = Math.max(0.35, Math.min(2.5, zoom0));
        SettingsStore.data.whiteboardView = { x, y, zoom };
        try { SettingsStore.syncToLocal(); } catch (e) {}
        if (o.persist) {
            try { SettingsStore.save(); } catch (e) {}
        }
    }

    function __tmGetWhiteboardNodePosMap() {
        const raw = SettingsStore.data.whiteboardNodePos;
        if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return {};
        return raw;
    }

    function __tmGetWhiteboardNodePos(taskId, docId) {
        const id = String(taskId || '').trim();
        const did = String(docId || '').trim();
        if (!id || !did) return null;
        const map = __tmGetWhiteboardNodePosMap();
        const item = map[id];
        if (!item || typeof item !== 'object') return null;
        if (String(item.docId || '').trim() !== did) return null;
        const x = Number(item.x);
        const y = Number(item.y);
        if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
        return { x, y, docId: did };
    }

    function __tmSetWhiteboardNodePos(taskId, docId, x, y, opts = {}) {
        const id = String(taskId || '').trim();
        const did = String(docId || '').trim();
        if (!id || !did) return;
        const xx = Number(x);
        const yy = Number(y);
        if (!Number.isFinite(xx) || !Number.isFinite(yy)) return;
        const o = (opts && typeof opts === 'object') ? opts : {};
        const next = { ...__tmGetWhiteboardNodePosMap() };
        const prev = next[id];
        const manual = (typeof o.manual === 'boolean')
            ? o.manual
            : !!(prev && typeof prev === 'object' && prev.manual === true);
        next[id] = { docId: did, x: Math.round(xx), y: Math.round(yy), manual, updatedAt: String(Date.now()) };
        SettingsStore.data.whiteboardNodePos = next;
        try { SettingsStore.syncToLocal(); } catch (e) {}
        if (o.persist) {
            try { SettingsStore.save(); } catch (e) {}
        }
    }

    function __tmGetWhiteboardPlacedTaskMap() {
        const raw = SettingsStore.data.whiteboardPlacedTaskIds;
        if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return {};
        return raw;
    }

    function __tmIsWhiteboardTaskPlaced(taskId) {
        const id = String(taskId || '').trim();
        if (!id) return false;
        return !!__tmGetWhiteboardPlacedTaskMap()[id];
    }

    function __tmSetWhiteboardTaskPlaced(taskId, placed, opts = {}) {
        const id = String(taskId || '').trim();
        if (!id) return;
        const o = (opts && typeof opts === 'object') ? opts : {};
        const next = { ...__tmGetWhiteboardPlacedTaskMap() };
        if (placed) next[id] = true;
        else delete next[id];
        SettingsStore.data.whiteboardPlacedTaskIds = next;
        try { SettingsStore.syncToLocal(); } catch (e) {}
        if (o.persist) {
            try { SettingsStore.save(); } catch (e) {}
        }
    }

    function __tmGetWhiteboardDocFrameSizeMap() {
        const raw = SettingsStore.data.whiteboardDocFrameSize;
        if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return {};
        return raw;
    }

    function __tmGetWhiteboardDocFrameSize(docId) {
        const id = String(docId || '').trim();
        if (!id) return null;
        const map = __tmGetWhiteboardDocFrameSizeMap();
        const item = map[id];
        if (!item || typeof item !== 'object') return null;
        const w = Number(item.w);
        const h = Number(item.h);
        if (!Number.isFinite(w) || !Number.isFinite(h)) return null;
        return { w: Math.max(520, Math.round(w)), h: Math.max(220, Math.round(h)) };
    }

    function __tmSetWhiteboardDocFrameSize(docId, w, h, opts = {}) {
        const id = String(docId || '').trim();
        if (!id) return;
        const ww = Number(w);
        const hh = Number(h);
        if (!Number.isFinite(ww) || !Number.isFinite(hh)) return;
        const o = (opts && typeof opts === 'object') ? opts : {};
        const next = { ...__tmGetWhiteboardDocFrameSizeMap() };
        next[id] = { w: Math.max(520, Math.round(ww)), h: Math.max(220, Math.round(hh)), updatedAt: String(Date.now()) };
        SettingsStore.data.whiteboardDocFrameSize = next;
        try { SettingsStore.syncToLocal(); } catch (e) {}
        if (o.persist) {
            try { SettingsStore.save(); } catch (e) {}
        }
    }

    function __tmComputePriorityScore(task) {
        const cfg = (SettingsStore.data.priorityScoreConfig && typeof SettingsStore.data.priorityScoreConfig === 'object')
            ? SettingsStore.data.priorityScoreConfig
            : {};
        const base = Number.isFinite(Number(cfg.base)) ? Number(cfg.base) : 100;
        const weights = (cfg.weights && typeof cfg.weights === 'object') ? cfg.weights : {};
        const w = (k) => {
            const n = Number(weights[k]);
            return Number.isFinite(n) ? n : 1;
        };

        let score = base;

        const impDeltaMap = (cfg.importanceDelta && typeof cfg.importanceDelta === 'object') ? cfg.importanceDelta : {};
        const imp = String(task?.priority || 'none').trim() || 'none';
        const impDelta = Number(impDeltaMap[imp] ?? impDeltaMap.none ?? 0);
        if (Number.isFinite(impDelta)) score += w('importance') * impDelta;

        const statusDeltaMap = (cfg.statusDelta && typeof cfg.statusDelta === 'object') ? cfg.statusDelta : {};
        const st = String(task?.customStatus || 'todo').trim() || 'todo';
        const stDelta = Number(statusDeltaMap[st] ?? 0);
        if (Number.isFinite(stDelta)) score += w('status') * stDelta;

        const dueStr = String(task?.completionTime || '').trim();
        if (dueStr) {
            const dueTs = __tmParseTimeToTs(dueStr);
            if (dueTs) {
                const daysUntil = (dueTs - Date.now()) / 86400000;
                const ranges0 = Array.isArray(cfg.dueRanges) ? cfg.dueRanges : [];
                const ranges = ranges0
                    .map(r => ({ days: Number(r?.days), delta: Number(r?.delta) }))
                    .filter(r => Number.isFinite(r.days) && Number.isFinite(r.delta))
                    .sort((a, b) => a.days - b.days);
                let delta = 0;
                for (const r of ranges) {
                    if (daysUntil <= r.days) { delta = r.delta; break; }
                }
                score += w('due') * delta;
            }
        }

        const mins = __tmParseDurationMinutes(task?.duration);
        if (mins != null) {
            const buckets0 = Array.isArray(cfg.durationBuckets) ? cfg.durationBuckets : [];
            const buckets = buckets0
                .map(b => ({ maxMinutes: Number(b?.maxMinutes), delta: Number(b?.delta) }))
                .filter(b => Number.isFinite(b.maxMinutes) && Number.isFinite(b.delta))
                .sort((a, b) => a.maxMinutes - b.maxMinutes);
            let delta = 0;
            for (const b of buckets) {
                if (mins <= b.maxMinutes) { delta = b.delta; break; }
            }
            score += w('duration') * delta;
        }

        const docId = String(task?.docId || task?.root_id || '').trim();
        if (docId) {
            const docDeltas = (cfg.docDeltas && typeof cfg.docDeltas === 'object') ? cfg.docDeltas : {};
            const delta = Number(docDeltas[docId] ?? 0);
            if (Number.isFinite(delta)) score += w('doc') * delta;
        }

        return Number.isFinite(score) ? score : base;
    }

    let __tmCellEditorState = null;

    function __tmCloseCellEditor(shouldRerender) {
        const last = __tmCellEditorState;
        if (__tmCellEditorState?.cleanup) {
            try { __tmCellEditorState.cleanup(); } catch (e) {}
        }
        __tmCellEditorState = null;
        if (shouldRerender) {
            applyFilters();
            render();
        }
    }

    async function __tmCommitCellEdit(id, field, value) {
        const task = state.flatTasks[id];
        if (!task) return;
        try {
            if (field === 'priority') {
                const next = value === 'high' || value === 'medium' || value === 'low' ? value : '';
                task.priority = next;
                __tmPersistMetaAndAttrs(id, { priority: next });
                hint('✅ 优先级已更新', 'success');
                return;
            }
            if (field === 'duration') {
                const next = String(value || '').trim();
                task.duration = next;
                __tmPersistMetaAndAttrs(id, { duration: next });
                hint('✅ 时长已更新', 'success');
                return;
            }
            if (field === 'remark') {
                const next = String(value || '').trim();
                task.remark = next;
                __tmPersistMetaAndAttrs(id, { remark: next });
                hint('✅ 备注已更新', 'success');
                return;
            }
            if (field === 'completionTime') {
                const raw = String(value || '').trim();
                const next = raw ? __tmNormalizeDateOnly(raw) : '';
                task.completionTime = next;
                __tmPersistMetaAndAttrs(id, { completionTime: next });
                hint(next ? '✅ 完成日期已更新' : '✅ 完成日期已清空', 'success');
                return;
            }
            if (field === 'startDate') {
                const raw = String(value || '').trim();
                const next = raw ? __tmNormalizeDateOnly(raw) : '';
                task.startDate = next;
                __tmPersistMetaAndAttrs(id, { startDate: next });
                hint(next ? '✅ 开始日期已更新' : '✅ 开始日期已清空', 'success');
                return;
            }
            if (field === 'customTime') {
                const raw = String(value || '').trim();
                task.customTime = raw;
                __tmPersistMetaAndAttrs(id, { customTime: raw });
                hint(raw ? '✅ 任务时间已更新' : '✅ 任务时间已清空', 'success');
                return;
            }
        } catch (e) {
            hint(`❌ 更新失败: ${e.message}`, 'error');
        }
    }

    window.tmBeginCellEdit = function(id, field, td, ev) {
        try {
            if (ev) {
                if (typeof ev.stopPropagation === 'function') ev.stopPropagation();
                if (typeof ev.preventDefault === 'function') ev.preventDefault();
            }
        } catch (e) {}

        if (!td) return;
        const existingInput = td.querySelector?.('input,select');
        if (existingInput) {
            try { existingInput.focus?.(); } catch (e) {}
            return;
        }

        __tmCloseInlineEditor();
        __tmCloseCellEditor(false);

        const originalText = td.textContent;
        const cleanupFns = [];
        const cleanup = () => {
            while (cleanupFns.length) {
                const fn = cleanupFns.pop();
                try { fn(); } catch (e) {}
            }
        };
        __tmCellEditorState = { td, cleanup, taskId: id, field };

        const task = state.flatTasks[id];
        if (!task) return;

        const finish = (rerender) => __tmCloseCellEditor(rerender);
        const cancel = () => finish(true);

        const commitAndClose = async (val) => {
            await __tmCommitCellEdit(id, field, val);
            finish(true);
        };

        td.innerHTML = '';

        if (field === 'priority') {
            const select = document.createElement('select');
            select.className = 'tm-cell-editor-select';
            select.innerHTML = `
                <option value="high">高</option>
                <option value="medium">中</option>
                <option value="low">低</option>
            `;
            select.value = task.priority || 'medium';
            td.appendChild(select);

            select.onchange = () => commitAndClose(select.value);
            select.onblur = () => cancel();
            select.onkeydown = (e) => {
                if (e.key === 'Escape') cancel();
                if (e.key === 'Enter') commitAndClose(select.value);
            };
            try {
                select.focus();
                setTimeout(() => {
                    try { select.dispatchEvent(new MouseEvent('mousedown', { bubbles: true })); } catch (e) {}
                    try { select.click(); } catch (e) {}
                }, 0);
            } catch (e) {}
            return;
        }

        if (field === 'completionTime') {
            const input = document.createElement('input');
            input.type = 'date';
            input.className = 'tm-cell-editor-input';
            const val = String(task.completionTime || '').trim();
            input.value = val ? val.slice(0, 10) : '';
            td.appendChild(input);

            const initial = input.value;
            let committed = false;
            if (__tmIsMobileDevice()) {
                const onDocPointerDown = (e) => {
                    const t = e?.target;
                    if (!t) return;
                    if (td.contains(t)) return;
                    if (committed) return;
                    committed = true;
                    cancel();
                };
                document.addEventListener('pointerdown', onDocPointerDown, true);
                cleanupFns.push(() => document.removeEventListener('pointerdown', onDocPointerDown, true));
            }
            const save = () => {
                if (committed) return;
                const next = String(input.value || '').trim();
                if (next === String(initial || '').trim()) {
                    committed = true;
                    finish(false);
                    return;
                }
                committed = true;
                commitAndClose(next);
            };
            input.onchange = () => save();
            input.onblur = () => {
                if (__tmIsMobileDevice()) return;
                if (committed) return;
                committed = true;
                cancel();
            };
            input.onkeydown = (e) => {
                if (e.key === 'Escape') cancel();
                if (e.key === 'Enter') save();
            };
            input.onclick = () => {
                try { input.showPicker?.(); } catch (e) {}
            };
            try {
                input.focus();
                input.showPicker?.();
            } catch (e) {}
            return;
        }

        if (field === 'startDate') {
            const input = document.createElement('input');
            input.type = 'date';
            input.className = 'tm-cell-editor-input';
            const val = String(task.startDate || '').trim();
            input.value = val ? val.slice(0, 10) : '';
            td.appendChild(input);

            const initial = input.value;
            let committed = false;
            if (__tmIsMobileDevice()) {
                const onDocPointerDown = (e) => {
                    const t = e?.target;
                    if (!t) return;
                    if (td.contains(t)) return;
                    if (committed) return;
                    committed = true;
                    cancel();
                };
                document.addEventListener('pointerdown', onDocPointerDown, true);
                cleanupFns.push(() => document.removeEventListener('pointerdown', onDocPointerDown, true));
            }
            const save = () => {
                if (committed) return;
                const next = String(input.value || '').trim();
                if (next === String(initial || '').trim()) {
                    committed = true;
                    finish(false);
                    return;
                }
                committed = true;
                commitAndClose(next);
            };
            input.onchange = () => save();
            input.onblur = () => {
                if (__tmIsMobileDevice()) return;
                if (committed) return;
                committed = true;
                cancel();
            };
            input.onkeydown = (e) => {
                if (e.key === 'Escape') cancel();
                if (e.key === 'Enter') save();
            };
            input.onclick = () => {
                try { input.showPicker?.(); } catch (e) {}
            };
            try {
                input.focus();
                input.showPicker?.();
            } catch (e) {}
            return;
        }

        if (field === 'customTime') {
            const input = document.createElement('input');
            input.type = 'datetime-local';
            input.className = 'tm-cell-editor-input';
            const current = String(task.customTime || '').trim();
            if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(current)) input.value = current.slice(0, 16);
            else input.value = __tmToDatetimeLocalValue(current);
            td.appendChild(input);

            const initial = input.value;
            let committed = false;
            if (__tmIsMobileDevice()) {
                const onDocPointerDown = (e) => {
                    const t = e?.target;
                    if (!t) return;
                    if (td.contains(t)) return;
                    if (committed) return;
                    committed = true;
                    cancel();
                };
                document.addEventListener('pointerdown', onDocPointerDown, true);
                cleanupFns.push(() => document.removeEventListener('pointerdown', onDocPointerDown, true));
            }
            const save = () => {
                if (committed) return;
                const next = String(input.value || '').trim();
                if (next === String(initial || '').trim()) {
                    committed = true;
                    finish(false);
                    return;
                }
                committed = true;
                commitAndClose(next);
            };
            input.onchange = () => save();
            input.onblur = () => {
                if (__tmIsMobileDevice()) return;
                if (committed) return;
                committed = true;
                cancel();
            };
            input.onkeydown = (e) => {
                if (e.key === 'Escape') cancel();
                if (e.key === 'Enter') save();
            };
            input.onclick = () => {
                try { input.showPicker?.(); } catch (e) {}
            };
            try {
                input.focus();
                input.showPicker?.();
            } catch (e) {}
            return;
        }

        if (field === 'duration' || field === 'remark') {
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'tm-cell-editor-input';
            input.value = field === 'duration' ? String(task.duration || '') : String(task.remark || '');
            td.appendChild(input);
            const save = () => commitAndClose(input.value);
            input.onblur = () => save();
            input.onkeydown = (e) => {
                if (e.key === 'Escape') cancel();
                if (e.key === 'Enter') save();
            };
            try {
                input.focus();
                input.select?.();
            } catch (e) {}
            return;
        }

        td.textContent = originalText;
        finish(false);
    };

    let __tmInlineEditorState = null;

    function __tmCloseInlineEditor() {
        if (!__tmInlineEditorState) return;
        try { __tmInlineEditorState.cleanup?.(); } catch (e) {}
        try { __tmInlineEditorState.el?.remove?.(); } catch (e) {}
        __tmInlineEditorState = null;
    }

    function __tmOpenInlineEditor(anchorEl, build) {
        if (!anchorEl) return null;
        __tmCloseInlineEditor();

        const editor = document.createElement('div');
        editor.className = 'tm-inline-editor';
        editor.tabIndex = -1;
        document.body.appendChild(editor);

        const cleanupFns = [];
        const cleanup = () => {
            while (cleanupFns.length) {
                const fn = cleanupFns.pop();
                try { fn(); } catch (e) {}
            }
        };

        const api = {
            editor,
            close: __tmCloseInlineEditor,
            onCleanup: (fn) => cleanupFns.push(fn),
        };

        build(api);

        const rect = anchorEl.getBoundingClientRect();
        const vw = window.innerWidth || document.documentElement.clientWidth || 0;
        const vh = window.innerHeight || document.documentElement.clientHeight || 0;

        const ew = editor.offsetWidth || 240;
        const eh = editor.offsetHeight || 120;
        const gap = 6;

        let left = rect.left;
        let top = rect.bottom + gap;
        if (left + ew + 8 > vw) left = Math.max(8, vw - ew - 8);
        if (top + eh + 8 > vh) {
            const up = rect.top - eh - gap;
            if (up >= 8) top = up;
            else top = Math.max(8, vh - eh - 8);
        }
        left = Math.max(8, left);

        editor.style.left = `${Math.round(left)}px`;
        editor.style.top = `${Math.round(top)}px`;

        const onDocPointerDown = (e) => {
            const t = e.target;
            if (editor.contains(t)) return;
            if (anchorEl.contains && anchorEl.contains(t)) return;
            __tmCloseInlineEditor();
        };
        const onDocKeyDown = (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                __tmCloseInlineEditor();
            }
        };

        document.addEventListener('pointerdown', onDocPointerDown, true);
        document.addEventListener('keydown', onDocKeyDown, true);

        cleanupFns.push(() => document.removeEventListener('pointerdown', onDocPointerDown, true));
        cleanupFns.push(() => document.removeEventListener('keydown', onDocKeyDown, true));

        __tmInlineEditorState = { el: editor, cleanup };

        try {
            const focusable = editor.querySelector('input,select,button,textarea');
            focusable?.focus?.();
            focusable?.select?.();
        } catch (e) {}

        return api;
    }

    function __tmBuildActions(okLabel, onOk, onCancel, extraButtons) {
        const wrap = document.createElement('div');
        wrap.className = 'tm-inline-editor-actions';

        if (Array.isArray(extraButtons)) {
            extraButtons.forEach(btn => wrap.appendChild(btn));
        }

        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'tm-btn tm-btn-secondary';
        cancelBtn.textContent = '取消';
        cancelBtn.onclick = () => onCancel?.();

        const okBtn = document.createElement('button');
        okBtn.className = 'tm-btn tm-btn-primary';
        okBtn.textContent = okLabel || '确定';
        okBtn.onclick = () => onOk?.();

        wrap.appendChild(cancelBtn);
        wrap.appendChild(okBtn);
        return { wrap, okBtn, cancelBtn };
    }

    window.tmEditPriorityInline = function(id, el) {
        const task = state.flatTasks[id];
        if (!task) return;
        __tmOpenInlineEditor(el, ({ editor, close }) => {
            const select = document.createElement('select');
            const opts = [
                { value: '', label: '无' },
                { value: 'high', label: '高' },
                { value: 'medium', label: '中' },
                { value: 'low', label: '低' },
            ];
            select.innerHTML = opts.map(o => `<option value="${esc(o.value)}">${esc(o.label)}</option>`).join('');
            select.value = task.priority || '';
            select.onchange = async () => {
                const next = String(select.value || '');
                try {
                    task.priority = next;
                    __tmPersistMetaAndAttrs(id, { priority: next });
                    close();
                    applyFilters();
                    render();
                    hint('✅ 优先级已更新', 'success');
                } catch (e) {
                    hint(`❌ 更新失败: ${e.message}`, 'error');
                }
            };
            editor.appendChild(select);
        });
    };

    window.tmEditDurationInline = function(id, el) {
        const task = state.flatTasks[id];
        if (!task) return;
        __tmOpenInlineEditor(el, ({ editor, close }) => {
            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = '例如：30 或 30m';
            input.value = String(task.duration || '');
            editor.appendChild(input);
            const { wrap } = __tmBuildActions('保存', async () => {
                const next = String(input.value || '').trim();
                try {
                    task.duration = next;
                    __tmPersistMetaAndAttrs(id, { duration: next });
                    close();
                    applyFilters();
                    render();
                    hint('✅ 时长已更新', 'success');
                } catch (e) {
                    hint(`❌ 更新失败: ${e.message}`, 'error');
                }
            }, close);
            editor.appendChild(wrap);
            input.onkeydown = (e) => {
                if (e.key === 'Enter') wrap.querySelector('button.tm-btn-primary')?.click?.();
            };
        });
    };

    window.tmEditRemarkInline = function(id, el) {
        const task = state.flatTasks[id];
        if (!task) return;
        __tmOpenInlineEditor(el, ({ editor, close }) => {
            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = '输入备注（可留空）';
            input.value = String(task.remark || '');
            editor.appendChild(input);
            const { wrap } = __tmBuildActions('保存', async () => {
                const next = String(input.value || '').trim();
                try {
                    task.remark = next;
                    __tmPersistMetaAndAttrs(id, { remark: next });
                    close();
                    applyFilters();
                    render();
                    hint('✅ 备注已更新', 'success');
                } catch (e) {
                    hint(`❌ 更新失败: ${e.message}`, 'error');
                }
            }, close);
            editor.appendChild(wrap);
            input.onkeydown = (e) => {
                if (e.key === 'Enter') wrap.querySelector('button.tm-btn-primary')?.click?.();
            };
        });
    };

    window.tmEditCompletionTimeInline = function(id, el) {
        const task = state.flatTasks[id];
        if (!task) return;
        __tmOpenInlineEditor(el, ({ editor, close }) => {
            const input = document.createElement('input');
            input.type = 'date';
            input.value = __tmNormalizeDateOnly(task.completionTime || '');
            editor.appendChild(input);

            const clearBtn = document.createElement('button');
            clearBtn.className = 'tm-btn tm-btn-secondary';
            clearBtn.textContent = '清空';
            clearBtn.onclick = async () => {
                try {
                    task.completionTime = '';
                    __tmPersistMetaAndAttrs(id, { completionTime: '' });
                    close();
                    applyFilters();
                    render();
                    hint('✅ 完成日期已清空', 'success');
                } catch (e) {
                    hint(`❌ 更新失败: ${e.message}`, 'error');
                }
            };

            const save = async () => {
                const raw = String(input.value || '').trim();
                const next = raw ? __tmNormalizeDateOnly(raw) : '';
                try {
                    task.completionTime = next;
                    __tmPersistMetaAndAttrs(id, { completionTime: next });
                    close();
                    applyFilters();
                    render();
                    hint('✅ 完成日期已更新', 'success');
                } catch (e) {
                    hint(`❌ 更新失败: ${e.message}`, 'error');
                }
            };

            const actions = document.createElement('div');
            actions.className = 'tm-inline-editor-actions';
            actions.appendChild(clearBtn);
            editor.appendChild(actions);

            input.onchange = () => save();
            input.onkeydown = (e) => {
                if (e.key === 'Enter') save();
            };
        });
    };

    window.tmEditPriority = async function(id) {
        const task = state.flatTasks[id];
        if (!task) return;
        const next = await showSelectPrompt('设置优先级', [
            { value: '', label: '无' },
            { value: 'high', label: '高' },
            { value: 'medium', label: '中' },
            { value: 'low', label: '低' },
        ], task.priority || '');
        if (next == null) return;
        try {
            task.priority = next;
            __tmPersistMetaAndAttrs(id, { priority: next });
            applyFilters();
            render();
            hint('✅ 优先级已更新', 'success');
        } catch (e) {
            hint(`❌ 更新失败: ${e.message}`, 'error');
        }
    };

    window.tmEditDuration = async function(id) {
        const task = state.flatTasks[id];
        if (!task) return;
        const next = await showPrompt('设置时长', '例如：30 或 30m', String(task.duration || ''));
        if (next == null) return;
        try {
            task.duration = next;
            __tmPersistMetaAndAttrs(id, { duration: String(next || '').trim() });
            applyFilters();
            render();
            hint('✅ 时长已更新', 'success');
        } catch (e) {
            hint(`❌ 更新失败: ${e.message}`, 'error');
        }
    };

    window.tmEditRemark = async function(id) {
        const task = state.flatTasks[id];
        if (!task) return;
        const next = await showPrompt('设置备注', '输入备注（可留空）', String(task.remark || ''));
        if (next == null) return;
        try {
            task.remark = next;
            __tmPersistMetaAndAttrs(id, { remark: String(next || '').trim() });
            applyFilters();
            render();
            hint('✅ 备注已更新', 'success');
        } catch (e) {
            hint(`❌ 更新失败: ${e.message}`, 'error');
        }
    };

    window.tmEditCompletionTime = async function(id) {
        const task = state.flatTasks[id];
        if (!task) return;
        const next = await showDateTimePrompt('设置完成日期', task.completionTime || '');
        if (next == null) return;
        try {
            task.completionTime = next;
            __tmPersistMetaAndAttrs(id, { completionTime: String(next || '').trim() });
            applyFilters();
            render();
            hint('✅ 完成日期已更新', 'success');
        } catch (e) {
            hint(`❌ 更新失败: ${e.message}`, 'error');
        }
    };

    window.updateFontSize = async function(value) {
        const size = parseInt(value) || 14;
        await SettingsStore.updateFontSize(size);
        render();
    };

    window.updateFontSizeMobile = async function(value) {
        const size = parseInt(value) || 14;
        await SettingsStore.updateFontSizeMobile(size);
        render();
    };

    window.updateRowHeightMode = async function(value) {
        const mode = String(value || 'auto').trim() || 'auto';
        SettingsStore.data.rowHeightMode = mode;
        await SettingsStore.save();
        render();
    };

    window.updateRowHeightPx = async function(value) {
        const px = Math.max(0, Math.floor(Number(value) || 0));
        SettingsStore.data.rowHeightPx = px;
        await SettingsStore.save();
        render();
    };

    window.updateTaskHeadingLevel = async function(value) {
        const level = String(value || 'h2').trim();
        SettingsStore.data.taskHeadingLevel = level;
        await SettingsStore.save();
        render();
    };

    // 导航功能
    const __getPluginApp = () => globalThis.__taskHorizonPluginApp || globalThis.__tomatoPluginApp || (window.siyuan?.app) || null;
    
    // 尝试获取全局的 API 函数
    const getOpenTabFn = () => {
        return window.openTab || 
               window.siyuan?.openTab || 
               globalThis.__taskHorizonOpenTab ||
               globalThis.__tomatoOpenTab ||
               (window.siyuan?.ws?.openTab); // 某些版本可能在这里
    };

    const getOpenMobileFn = () => {
        return window.openMobileFileById || 
               window.siyuan?.openMobileFileById || 
               globalThis.__taskHorizonOpenMobileFileById ||
               globalThis.__tomatoOpenMobileFileById;
    };

    const __tmFindActiveProtyle = () => {
        const isVisible = (el) => {
            try { return !!el && el.offsetParent !== null; } catch (e) { return false; }
        };
        return (
            document.querySelector('.layout__wnd--active .protyle') ||
            Array.from(document.querySelectorAll('.protyle')).find(isVisible) ||
            null
        );
    };

    const __tmFindBlockElement = (blockId) => {
        if (!blockId) return null;
        const active = __tmFindActiveProtyle();
        const root = active?.querySelector?.('.protyle-wysiwyg') || active || document;
        const selectors = [
            `[data-node-id="${blockId}"]`,
            `.li[data-node-id="${blockId}"]`,
            `.p[data-node-id="${blockId}"]`
        ];
        for (const sel of selectors) {
            const el = root.querySelector(sel) || document.querySelector(sel);
            if (el) return el;
        }
        return null;
    };

    const __tmScrollToBlock = (blockId) => {
        if (!blockId) return false;
        try {
            if (window.siyuan?.block?.scrollToBlock) {
                window.siyuan.block.scrollToBlock(blockId);
            }
        } catch (e) {}
        const el = __tmFindBlockElement(blockId);
        if (el) {
            el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            el.classList.add('tm-block-highlight');
            setTimeout(() => {
                try { el.classList.remove('tm-block-highlight'); } catch (e) {}
            }, 1200);
            return true;
        }
        return false;
    };

    const __tmScheduleScrollToBlock = (blockId, retries = 12) => {
        let attempt = 0;
        const run = () => {
            attempt += 1;
            const ok = __tmScrollToBlock(blockId);
            if (!ok && attempt < retries) {
                setTimeout(run, 300);
            }
        };
        setTimeout(run, 200);
    };

    window.tmOpenDocById = async function(docId) {
        const id = String(docId || '').trim();
        if (!id || id === 'all') return false;
        const app = __getPluginApp();
        const isMobile = __tmIsMobileDevice();
        const closeAfterOpen = () => {
            if (!isMobile) return;
            setTimeout(() => {
                try { window.tmClose?.(); } catch (e) {}
            }, 120);
        };

        if (isMobile) {
            const openMobile = getOpenMobileFn();
            if (typeof openMobile === 'function') {
                try {
                    openMobile(app, id);
                    closeAfterOpen();
                    return true;
                } catch (e) {}
            }
        }

        const openTab = getOpenTabFn();
        if (typeof openTab === 'function') {
            try {
                openTab({ app, doc: { id } });
                closeAfterOpen();
                return true;
            } catch (e) {}
        }

        try {
            window.open(`siyuan://blocks/${id}`);
            closeAfterOpen();
            return true;
        } catch (e) {}
        return false;
    };

    window.tmJumpToTask = async function(id, event) {
        if (event) {
            event.preventDefault();
            event.stopPropagation();
        }
        const app = __getPluginApp();
        const closeAfterJump = () => {
            if (!__tmIsMobileDevice()) return;
            setTimeout(() => {
                try { window.tmClose?.(); } catch (e) {}
            }, 120);
        };

        // 1. 优先尝试移动端 API (如果在移动端环境下)
        const openMobile = getOpenMobileFn();
        if (typeof openMobile === 'function') {
            try {
                let docId = id;
                try {
                    const sql = `SELECT root_id FROM blocks WHERE id = '${id}' LIMIT 1`;
                    const res = await API.call('/api/query/sql', { stmt: sql });
                    const rows = (res && res.code === 0) ? res.data : [];
                    docId = (rows && rows[0] && rows[0].root_id) ? rows[0].root_id : id;
                } catch (e) {}
                openMobile(app, docId);
                setTimeout(() => __tmScheduleScrollToBlock(id, 24), 650);
                closeAfterJump();
                return;
            } catch (e) {}
        }
        
        // 2. 桌面端优先尝试 findDocumentIdByBlockId + openTab (参照 tomato.js)
        const openTab = getOpenTabFn();
        if (typeof openTab === 'function') {
            try {
                // 获取所在文档ID
                const sql = `SELECT root_id FROM blocks WHERE id = '${id}' LIMIT 1`;
                const res = await API.call('/api/query/sql', { stmt: sql });
                // API.call 返回的是 {code:0, data: [...]}
                const rows = (res && res.code === 0) ? res.data : [];
                const docId = (rows && rows[0]) ? rows[0].root_id : id;

                // 使用 openTab 打开文档
                // 构造参数：打开文档 root_id
                const params = { 
                    app, 
                    doc: { id: docId }
                };
                
                // 如果目标块不是文档本身，尝试通过 block 参数定位（注意：不同版本思源对 block 参数支持不同）
                // 另一种常见的定位方式是先打开文档，再通过 hash 定位，但 openTab 封装了这些
                if (docId !== id) {
                    // 尝试同时传入 block 信息，这通常会触发滚动高亮
                    params.block = { id: id, mode: 0 }; // mode: 0 可能表示不高亮聚焦？尝试一下
                }

                openTab(params);
                __tmScheduleScrollToBlock(id);
                closeAfterJump();
                // 补充：如果 openTab 不支持直接定位到块，可能需要发送消息或执行脚本
                // 但通常 openTab({doc:{id: rootId}}) 会打开文档，如果我们要定位到块，
                // 在新版思源中，可能需要 openFileById 风格的参数
                
                return;
            } catch (e) {}
        }

        // 3. 兜底：模拟点击 block-ref
        try {
            const tempSpan = document.createElement('span');
            tempSpan.setAttribute('data-type', 'block-ref');
            tempSpan.setAttribute('data-id', id);
            // 使用对布局无影响但可被交互的样式
            tempSpan.style.position = 'fixed';
            tempSpan.style.top = '-9999px';
            tempSpan.style.left = '-9999px';
            tempSpan.style.opacity = '0';
            tempSpan.style.pointerEvents = 'none';
            document.body.appendChild(tempSpan);
            
            const opts = {
                view: window,
                bubbles: true,
                cancelable: true,
                buttons: 1
            };
            tempSpan.dispatchEvent(new MouseEvent('mousedown', opts));
            tempSpan.dispatchEvent(new MouseEvent('mouseup', opts));
            tempSpan.dispatchEvent(new MouseEvent('click', opts));
            
            setTimeout(() => tempSpan.remove(), 100);
            closeAfterJump();
            return;
        } catch (e) {}

        // 4. 兜底：使用 URL Scheme
        window.open(`siyuan://blocks/${id}`);
        closeAfterJump();
    };

    function __tmBuildTaskRowModel() {
        if (!Array.isArray(state.filteredTasks) || state.filteredTasks.length === 0) return [];

        const isDark = __tmIsDarkMode();
        const timeBaseColor = isDark
            ? __tmNormalizeHexColor(SettingsStore.data.timeGroupBaseColorDark, '#6ba5ff')
            : __tmNormalizeHexColor(SettingsStore.data.timeGroupBaseColorLight, '#1a73e8');
        const timeOverdueColor = isDark
            ? __tmNormalizeHexColor(SettingsStore.data.timeGroupOverdueColorDark, '#ff6b6b')
            : __tmNormalizeHexColor(SettingsStore.data.timeGroupOverdueColorLight, '#d93025');
        const __tmGetTimeGroupLabelColor = (groupInfo) => {
            const key = String(groupInfo?.key || '');
            const sortValue = Number(groupInfo?.sortValue);
            if (key === 'pending' || !Number.isFinite(sortValue)) return 'var(--tm-secondary-text)';
            if (sortValue < 0) return timeOverdueColor || 'var(--tm-danger-color)';
            const minA = isDark ? 0.52 : 0.42;
            const step = isDark ? 0.085 : 0.11;
            const alpha = __tmClamp(1 - sortValue * step, minA, 1);
            return __tmWithAlpha(timeBaseColor || 'var(--tm-primary-color)', alpha);
        };

        const rows = [];

        const filteredIdSet = new Set(state.filteredTasks.map(t => t.id));
        let orderMap = new Map(state.filteredTasks.map((t, i) => [t.id, i]));
        if (SettingsStore.data.timelineForceSortByCompletionNearToday) {
            const now = new Date();
            const todayTs = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 12, 0, 0, 0).getTime();
            const docsInOrder = __tmSortDocEntriesByPinned(
                state.taskTree || [],
                String(SettingsStore.data.currentGroupId || 'all').trim() || 'all'
            ).map((d) => String(d?.id || '').trim()).filter(Boolean);
            const docRankMap = new Map();
            docsInOrder.forEach((did, idx) => docRankMap.set(did, idx));

            const h2BucketRank = new Map();
            docsInOrder.forEach((did) => {
                const seen = new Set();
                let rank = 0;
                const pushByTask = (task) => {
                    const bucket = __tmGetDocHeadingBucket(task, '无标题');
                    const key = `${did}::${String(bucket?.key || 'label:__none__')}`;
                    if (seen.has(key)) return;
                    seen.add(key);
                    const rk = Number(task?.h2Rank);
                    if (Number.isFinite(rk)) {
                        h2BucketRank.set(key, rk);
                    } else {
                        h2BucketRank.set(key, rank++);
                    }
                };
                state.filteredTasks
                    .filter((t) => String(t?.root_id || t?.docId || '').trim() === did)
                    .slice()
                    .sort(__tmCompareTasksByDocFlow)
                    .forEach(pushByTask);
            });
            const items = state.filteredTasks.map((t, i) => {
                const docId = String(t?.root_id || t?.docId || '').trim();
                const bucket = __tmGetDocHeadingBucket(t, '无标题');
                const h2Key = `${docId}::${String(bucket?.key || 'label:__none__')}`;
                const ts = __tmParseTimeToTs(t?.completionTime);
                // 计算任务日期距离今天的天数（正数表示未来，负数表示过去，0表示今天）
                const daysDiff = ts ? Math.round((ts - todayTs) / (1000 * 60 * 60 * 24)) : Infinity;
                // 排序：今天之前的按倒序（越早过期的越靠前），今天及之后的按正序（越晚完成的越靠后）
                const sortKey = Number.isFinite(daysDiff) ? daysDiff : (daysDiff < 0 ? -Infinity : Infinity);
                const docRank = Number(docRankMap.has(docId) ? docRankMap.get(docId) : 999999);
                const h2Rank = Number(h2BucketRank.get(h2Key) ?? 999999);
                return { id: String(t?.id || ''), docRank, h2Rank, daysDiff, sortKey, ts, i };
            }).filter(x => x.id);
            items.sort((a, b) => (a.docRank - b.docRank) || (a.h2Rank - b.h2Rank) || (a.sortKey - b.sortKey) || (a.ts - b.ts) || (a.i - b.i));
            orderMap = new Map(items.map((x, idx) => [x.id, idx]));
        }
        const getTaskOrder = (taskId) => orderMap.get(taskId) ?? Infinity;

        const rootTasks = state.filteredTasks.filter(t => {
            if (!t.parentTaskId) return true;
            return !filteredIdSet.has(t.parentTaskId);
        });
        const timelineKeepH2Order = (state.viewMode === 'timeline')
            && !!state.groupByDocName
            && (SettingsStore.data.docH2SubgroupEnabled !== false);
        const pinnedRoots = timelineKeepH2Order ? [] : rootTasks.filter(t => t.pinned);
        const normalRoots = timelineKeepH2Order ? rootTasks.slice() : rootTasks.filter(t => !t.pinned);
        pinnedRoots.sort((a, b) => getTaskOrder(a.id) - getTaskOrder(b.id));
        normalRoots.sort((a, b) => getTaskOrder(a.id) - getTaskOrder(b.id));

        const emitTask = (task, depth, hasChildren, collapsed) => {
            rows.push({
                type: 'task',
                id: String(task?.id || ''),
                depth: Math.max(0, Number(depth) || 0),
                hasChildren: !!hasChildren,
                collapsed: !!collapsed,
            });
        };

        const walkTaskTree = (task, depth) => {
            const childTasks = (task.children || []).filter(c => filteredIdSet.has(c.id));
            childTasks.sort((a, b) => getTaskOrder(a.id) - getTaskOrder(b.id));
            const hasChildren = childTasks.length > 0;
            const collapsed = state.collapsedTaskIds.has(String(task.id));
            const showChildren = hasChildren && !task.done;
            emitTask(task, depth, showChildren, collapsed);
            if (showChildren && !collapsed) {
                childTasks.forEach(child => walkTaskTree(child, depth + 1));
            }
        };

        pinnedRoots.forEach(task => walkTaskTree(task, 0));

        if (state.quadrantEnabled && normalRoots.length > 0) {
            const quadrantRules = (SettingsStore.data.quadrantConfig && SettingsStore.data.quadrantConfig.rules) || [];
            const getImportanceLevel = (task) => {
                const priority = String(task.priority || '').toLowerCase();
                if (priority === 'a' || priority === '高' || priority === 'high') return 'high';
                if (priority === 'b' || priority === '中' || priority === 'medium') return 'medium';
                if (priority === 'c' || priority === '低' || priority === 'low') return 'low';
                return 'none';
            };
            const getTimeRange = (task) => {
                const timeStr = task.completionTime;
                if (!timeStr) return 'nodate';
                const taskDate = new Date(timeStr);
                if (isNaN(taskDate.getTime())) return 'nodate';
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const target = new Date(taskDate.getFullYear(), taskDate.getMonth(), taskDate.getDate());
                const diffDays = Math.ceil((target - today) / (1000 * 60 * 60 * 24));
                if (diffDays < 0) return 'overdue';
                if (diffDays <= 7) return 'within7days';
                if (diffDays <= 15) return 'within15days';
                if (diffDays <= 30) return 'within30days';
                return 'beyond30days';
            };
            const getTaskDays = (task) => {
                const timeStr = task.completionTime;
                if (!timeStr) return Infinity;
                const taskDate = new Date(timeStr);
                if (isNaN(taskDate.getTime())) return Infinity;
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const target = new Date(taskDate.getFullYear(), taskDate.getMonth(), taskDate.getDate());
                return Math.ceil((target - today) / (1000 * 60 * 60 * 24));
            };

            const quadrantGroups = {};
            quadrantRules.forEach(rule => {
                quadrantGroups[rule.id] = { ...rule, items: [] };
            });
            const quadrantOrder = ['urgent-important', 'not-urgent-important', 'urgent-not-important', 'not-urgent-not-important'];

            normalRoots.forEach(task => {
                const importance = getImportanceLevel(task);
                const timeRange = getTimeRange(task);
                const taskDays = getTaskDays(task);
                let matchedRule = null;
                for (const rule of quadrantRules) {
                    const importanceMatch = rule.importance.includes(importance);
                    let timeRangeMatch = rule.timeRanges.includes(timeRange);
                    if (!timeRangeMatch) {
                        for (const range of rule.timeRanges) {
                            if (range.startsWith('beyond') && range !== 'beyond30days') {
                                const days = parseInt(range.replace('beyond', '').replace('days', ''));
                                if (!isNaN(days) && taskDays > days) { timeRangeMatch = true; break; }
                            }
                        }
                    }
                    if (importanceMatch && timeRangeMatch) { matchedRule = rule; break; }
                }
                if (matchedRule && quadrantGroups[matchedRule.id]) {
                    quadrantGroups[matchedRule.id].items.push(task);
                }
            });

            const calculateDuration = (items) => {
                const durationFormat = SettingsStore.data.durationFormat || 'hours';
                let totalMinutes = 0;
                items.forEach(task => {
                    const durationStr = String(task.duration || '').trim();
                    if (!durationStr) return;
                    let minutes = 0;
                    if (durationStr.toLowerCase().endsWith('h')) {
                        const hours = parseFloat(durationStr.toLowerCase().replace('h', ''));
                        if (!isNaN(hours)) minutes = hours * 60;
                    } else if (durationStr.toLowerCase().endsWith('min')) {
                        const mins = parseFloat(durationStr.toLowerCase().replace('min', ''));
                        if (!isNaN(mins)) minutes = mins;
                    } else {
                        const num = parseFloat(durationStr);
                        if (!isNaN(num)) minutes = num > 100 ? num : num * 60;
                    }
                    totalMinutes += minutes;
                });
                if (totalMinutes === 0) return '';
                if (durationFormat === 'hours') {
                    const hours = Math.round(totalMinutes / 60 * 10) / 10;
                    return `${hours}h`;
                }
                return `${totalMinutes}min`;
            };

            quadrantOrder.forEach((quadrantId) => {
                const group = quadrantGroups[quadrantId];
                if (!group || !Array.isArray(group.items) || group.items.length === 0) return;
                const groupKey = `quadrant_${quadrantId}`;
                const isCollapsed = state.collapsedGroups?.has(groupKey);
                rows.push({
                    type: 'group',
                    kind: 'quadrant',
                    key: groupKey,
                    label: String(group.name || ''),
                    color: String(group.color || ''),
                    count: group.items.length,
                    durationSum: calculateDuration(group.items),
                    collapsed: !!isCollapsed,
                });
                if (!isCollapsed) {
                    group.items.forEach(task => walkTaskTree(task, 0));
                }
            });
            return rows;
        }

        if (state.groupByDocName) {
            const enableDocH2Subgroup = SettingsStore.data.docH2SubgroupEnabled !== false;
            const headingLevel = String(SettingsStore.data.taskHeadingLevel || 'h2').trim() || 'h2';
            const headingLabelMap = { h1: '一级标题', h2: '二级标题', h3: '三级标题', h4: '四级标题', h5: '五级标题', h6: '六级标题' };
            const noHeadingLabel = `无${headingLabelMap[headingLevel] || '标题'}`;
            const docsInOrder = __tmSortDocEntriesByPinned(
                state.taskTree || [],
                String(SettingsStore.data.currentGroupId || 'all').trim() || 'all'
            ).map(d => d.id).filter(Boolean);
            docsInOrder.forEach(docId => {
                const docEntry = state.taskTree.find(d => d.id === docId);
                if (!docEntry) return;
                const docTasks = state.filteredTasks.filter(t => t.root_id === docId);
                if (docTasks.length === 0) return;
                const docRootTasks = docTasks.filter(t => {
                    if (!t.parentTaskId) return true;
                    return !filteredIdSet.has(t.parentTaskId);
                });
                const docNormal = timelineKeepH2Order ? docRootTasks.slice() : docRootTasks.filter(t => !t.pinned);
                docNormal.sort((a, b) => getTaskOrder(a.id) - getTaskOrder(b.id));
                const docName = docEntry.name || '未知文档';
                const groupKey = `doc_${docId}`;
                const isCollapsed = state.collapsedGroups?.has(groupKey);
                const labelColor = __tmGetDocColorHex(docId, isDark) || 'var(--tm-group-doc-label-color)';
                rows.push({
                    type: 'group',
                    kind: 'doc',
                    key: groupKey,
                    label: String(docName),
                    count: docTasks.length,
                    labelColor,
                    collapsed: !!isCollapsed,
                });
                if (!isCollapsed) {
                    if (!enableDocH2Subgroup) {
                        docNormal.forEach(task => walkTaskTree(task, 0));
                        return;
                    }
                    const h2Groups = new Map();
                    const h2Buckets = __tmBuildDocHeadingBuckets(docNormal, noHeadingLabel);
                    docNormal.forEach(task => {
                        const b = __tmGetDocHeadingBucket(task, noHeadingLabel);
                        if (!h2Groups.has(b.key)) h2Groups.set(b.key, { label: b.label, items: [] });
                        h2Groups.get(b.key).items.push(task);
                    });
                    h2Buckets.forEach((bucket) => {
                        const g = h2Groups.get(bucket.key) || { label: String(bucket.label || ''), items: [] };
                        const items = Array.isArray(g.items) ? g.items : [];
                        const h2Key = `doc_${docId}__h2_${encodeURIComponent(String(bucket.key || 'label:__none__'))}`;
                        const h2Collapsed = state.collapsedGroups?.has(h2Key);
                        rows.push({
                            type: 'group',
                            kind: 'h2',
                            key: h2Key,
                            label: String(g.label || ''),
                            count: Array.isArray(items) ? items.length : 0,
                            collapsed: !!h2Collapsed,
                        });
                        if (!h2Collapsed) {
                            items.forEach(task => walkTaskTree(task, 0));
                        }
                    });
                }
            });
            return rows;
        }

        // 按任务名分组
        if (state.groupByTaskName && normalRoots.length > 0) {
            const tasksByContent = {};
            normalRoots.forEach(task => {
                const content = String(task.content || '').trim();
                if (!content) return;
                if (!tasksByContent[content]) {
                    tasksByContent[content] = [];
                }
                tasksByContent[content].push(task);
            });

            // 按任务名称升序排序
            const sortedGroups = Object.entries(tasksByContent)
                .sort((a, b) => String(a[0] || '').localeCompare(String(b[0] || ''), 'zh-CN'));

            sortedGroups.forEach(([content, tasks]) => {
                if (tasks.length === 0) return;

                const safeContent = String(content || '').replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, '_');
                const groupKey = `task_${safeContent}`;
                const isCollapsed = state.collapsedGroups?.has(groupKey);
                const labelColor = 'var(--tm-primary-color)';
                
                // 计算该分组中所有任务的文档颜色
                const docIds = [...new Set(tasks.map(t => t.root_id).filter(Boolean))];
                let groupDocColor = '';
                if (docIds.length === 1) {
                    groupDocColor = __tmGetDocColorHex(docIds[0], isDark) || '';
                }

                rows.push({
                    type: 'group',
                    kind: 'task',
                    key: groupKey,
                    label: String(content),
                    count: tasks.length,
                    labelColor,
                    groupDocColor,
                    collapsed: !!isCollapsed,
                });

                if (!isCollapsed) {
                    tasks.sort((a, b) => getTaskOrder(a.id) - getTaskOrder(b.id));
                    tasks.forEach(task => walkTaskTree(task, 0));
                }
            });
            return rows;
        }

        if (state.groupByTime && normalRoots.length > 0) {
            const getTimeGroup = (task) => {
                const timeStr = task.completionTime;
                if (!timeStr) return { key: 'pending', label: '待定', sortValue: Infinity };
                const taskDate = new Date(timeStr);
                if (isNaN(taskDate.getTime())) return { key: 'pending', label: '待定', sortValue: Infinity };
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const target = new Date(taskDate.getFullYear(), taskDate.getMonth(), taskDate.getDate());
                const diffDays = Math.ceil((target - today) / (1000 * 60 * 60 * 24));
                if (diffDays < 0) return { key: 'overdue', label: '已过期', sortValue: diffDays };
                if (diffDays === 0) return { key: 'today', label: '今天', sortValue: 0 };
                if (diffDays === 1) return { key: 'tomorrow', label: '明天', sortValue: 1 };
                if (diffDays === 2) return { key: 'after_tomorrow', label: '后天', sortValue: 2 };
                return { key: `days_${diffDays}`, label: `余${diffDays}天`, sortValue: diffDays };
            };

            const timeGroups = new Map();
            normalRoots.forEach(task => {
                const groupInfo = getTimeGroup(task);
                if (!timeGroups.has(groupInfo.key)) timeGroups.set(groupInfo.key, { ...groupInfo, items: [] });
                timeGroups.get(groupInfo.key).items.push(task);
            });

            const sortedGroups = [...timeGroups.values()].sort((a, b) => a.sortValue - b.sortValue);
            const calculateGroupDuration = (items) => {
                const durationFormat = SettingsStore.data.durationFormat || 'hours';
                let totalMinutes = 0;
                items.forEach(task => {
                    const durationStr = String(task.duration || '').trim();
                    if (!durationStr) return;
                    let minutes = 0;
                    if (durationStr.toLowerCase().endsWith('h')) {
                        const hours = parseFloat(durationStr.toLowerCase().replace('h', ''));
                        if (!isNaN(hours)) minutes = hours * 60;
                    } else if (durationStr.toLowerCase().endsWith('min')) {
                        const mins = parseFloat(durationStr.toLowerCase().replace('min', ''));
                        if (!isNaN(mins)) minutes = mins;
                    } else {
                        const num = parseFloat(durationStr);
                        if (!isNaN(num)) minutes = num > 100 ? num : num * 60;
                    }
                    totalMinutes += minutes;
                });
                if (totalMinutes <= 0) return '';
                if (durationFormat === 'hours') {
                    const hours = totalMinutes / 60;
                    if (hours < 1) return `${Math.round(totalMinutes)}min`;
                    if (hours === Math.floor(hours)) return `${Math.round(hours)}h`;
                    return `${hours.toFixed(1)}h`;
                }
                return `${totalMinutes}min`;
            };

            sortedGroups.forEach(group => {
                const isCollapsed = state.collapsedGroups?.has(group.key);
                rows.push({
                    type: 'group',
                    kind: 'time',
                    key: String(group.key),
                    label: String(group.label || ''),
                    count: Array.isArray(group.items) ? group.items.length : 0,
                    labelColor: __tmGetTimeGroupLabelColor(group),
                    durationSum: calculateGroupDuration(group.items || []),
                    collapsed: !!isCollapsed,
                });
                if (!isCollapsed) {
                    group.items.sort((a, b) => getTaskOrder(a.id) - getTaskOrder(b.id));
                    group.items.forEach(task => walkTaskTree(task, 0));
                }
            });
            return rows;
        }

        normalRoots.forEach(task => walkTaskTree(task, 0));
        return rows;
    }

// 渲染任务列表（支持跨文档全局排序）
    function renderTaskList() {
        if (state.filteredTasks.length === 0) {
            const colCount = (SettingsStore.data.columnOrder || []).length || 7;
            return `<tr><td colspan="${colCount}" style="text-align: center; padding: 40px; color: var(--tm-secondary-text);">暂无任务</td></tr>`;
        }

        const isGloballyLocked = GlobalLock.isLocked();
        const colCount = (SettingsStore.data.columnOrder || []).length || 7;
        const isDark = __tmIsDarkMode();
        const enableGroupBg = !!SettingsStore.data.enableGroupTaskBgByGroupColor;
        let currentGroupBg = '';
        const timeBaseColor = isDark
            ? __tmNormalizeHexColor(SettingsStore.data.timeGroupBaseColorDark, '#6ba5ff')
            : __tmNormalizeHexColor(SettingsStore.data.timeGroupBaseColorLight, '#1a73e8');
        const timeOverdueColor = isDark
            ? __tmNormalizeHexColor(SettingsStore.data.timeGroupOverdueColorDark, '#ff6b6b')
            : __tmNormalizeHexColor(SettingsStore.data.timeGroupOverdueColorLight, '#d93025');
        const __tmGetTimeGroupLabelColor = (groupInfo) => {
            const key = String(groupInfo?.key || '');
            const sortValue = Number(groupInfo?.sortValue);
            if (key === 'pending' || !Number.isFinite(sortValue)) return 'var(--tm-secondary-text)';
            if (sortValue < 0) return timeOverdueColor || 'var(--tm-danger-color)';
            const minA = isDark ? 0.52 : 0.42;
            const step = isDark ? 0.085 : 0.11;
            const alpha = __tmClamp(1 - sortValue * step, minA, 1);
            return __tmWithAlpha(timeBaseColor || 'var(--tm-primary-color)', alpha);
        };

        // 构建全局 Filtered ID 集合和顺序映射（用于保持全局排序）
        const filteredIdSet = new Set(state.filteredTasks.map(t => t.id));
        const orderMap = new Map(state.filteredTasks.map((t, i) => [t.id, i]));

        // 获取任务在 filtered 中的排序索引
        const getTaskOrder = (taskId) => orderMap.get(taskId) ?? Infinity;

        // 识别全局根任务：父任务不在 filtered 集合中，或本身就是顶层
        const rootTasks = state.filteredTasks.filter(t => {
            if (!t.parentTaskId) return true;
            return !filteredIdSet.has(t.parentTaskId);
        });

        // 分离置顶和非置顶的根任务
        const pinnedRoots = rootTasks.filter(t => t.pinned);
        const normalRoots = rootTasks.filter(t => !t.pinned);

        // 对根任务按照在 filteredTasks 中的顺序排序（确保全局排序生效）
        pinnedRoots.sort((a, b) => getTaskOrder(a.id) - getTaskOrder(b.id));
        normalRoots.sort((a, b) => getTaskOrder(a.id) - getTaskOrder(b.id));

        // 渲染单行（保持原有 emitRow 逻辑）
        const emitRow = (task, depth, hasChildren, collapsed) => {
            const { done, content, priority, completionTime, duration, remark, docName, pinned, startDate } = task;
            
            // 计算子任务统计信息
            const allChildren = task.children || [];
            const totalChildren = allChildren.length;
            const completedChildren = allChildren.filter(c => c.done).length;
            const remainingChildren = totalChildren - completedChildren;
            const childStatsHtml = remainingChildren > 0 
                ? `<span style="font-size: 11px; color: var(--tm-secondary-text); margin-left: 4px; background: var(--tm-doc-count-bg); padding: 1px 5px; border-radius: 8px; display: inline-flex; align-items: center; justify-content: center; height: 14px;" title="共${totalChildren}个任务，已完成${completedChildren}个，剩余${remainingChildren}个">${remainingChildren}</span>`
                : '';
            
            const indent = Math.max(0, Number(depth) || 0) * 12;
            
            // 计算子任务进度条背景（复用已定义的 allChildren, totalChildren, completedChildren）
            const progressPercent = totalChildren > 0 ? Math.round((completedChildren / totalChildren) * 100) : 0;
            const isDark = __tmIsDarkMode();
            const progressBarColor = isDark 
                ? __tmNormalizeHexColor(SettingsStore.data.progressBarColorDark, '#81c784')
                : __tmNormalizeHexColor(SettingsStore.data.progressBarColorLight, '#4caf50');
            const groupBg = enableGroupBg ? currentGroupBg : '';
            const progressBgStyle = (hasChildren && progressPercent > 0)
                ? (enableGroupBg && groupBg
                    ? `background-image: linear-gradient(90deg, ${progressBarColor} ${progressPercent}%, transparent ${progressPercent}%);background-repeat:no-repeat;background-size:100% 3px;background-position:left bottom;`
                    : `background-image: linear-gradient(90deg, ${progressBarColor} ${progressPercent}%, transparent ${progressPercent}%);background-repeat:no-repeat;`)
                : '';
            
            const toggle = hasChildren
                ? `<span class="tm-tree-toggle" onclick="tmToggleCollapse('${task.id}', event)">${collapsed ? '▸' : '▾'}</span>`
                : `<span class="tm-tree-spacer"></span>`;

            const widths = SettingsStore.data.columnWidths || {};
            const colOrder = SettingsStore.data.columnOrder || ['pinned', 'content', 'status', 'score', 'doc', 'h2', 'priority', 'startDate', 'completionTime', 'duration', 'spent', 'remark'];

            const cells = {
                pinned: () => `
                    <td style="text-align: center; width: ${widths.pinned || 48}px; min-width: ${widths.pinned || 48}px; max-width: ${widths.pinned || 48}px;">
                        <input type="checkbox" ${pinned ? 'checked' : ''}
                               onchange="tmSetPinned('${task.id}', this.checked, event)"
                               title="置顶">
                    </td>`,
                content: () => `
                    <td style="width: ${widths.content || 360}px; min-width: ${widths.content || 360}px; max-width: ${widths.content || 360}px; ${progressBgStyle}">
                        <div class="tm-task-cell" style="padding-left:${indent}px">
                            ${toggle}
                            <input class="tm-task-checkbox ${isGloballyLocked ? 'tm-operating' : ''}"
                                   type="checkbox" ${done ? 'checked' : ''}
                                   ${isGloballyLocked ? 'disabled' : ''}
                                   onchange="tmSetDone('${task.id}', this.checked, event)">
                            <span class="tm-task-text ${done ? 'tm-task-done' : ''}"
                                  data-level="${depth}"
                                  title="${esc(content)}">
                                <span class="tm-task-content-clickable" onclick="tmJumpToTask('${task.id}', event)" title="${esc(content)}">${esc(content)}</span>
                            </span>
                            ${childStatsHtml}
                        </div>
                    </td>`,
                doc: () => `
                    <td style="width: ${widths.doc || 180}px; min-width: ${widths.doc || 180}px; max-width: ${widths.doc || 180}px;" title="${esc(docName || '')}">${esc(docName || '')}</td>`,
                h2: () => `
                    <td style="width: ${widths.h2 || 180}px; min-width: ${widths.h2 || 180}px; max-width: ${widths.h2 || 180}px;" title="${esc(task.h2 || '无')}">${esc(task.h2 || '无')}</td>`,
                score: () => {
                    const v = Number.isFinite(Number(task.priorityScore)) ? Math.round(Number(task.priorityScore)) : 0;
                    return `<td style="width: ${widths.score || 96}px; min-width: ${widths.score || 96}px; max-width: ${widths.score || 96}px; text-align: center; font-variant-numeric: tabular-nums;">${v}</td>`;
                },
                priority: () => {
                    const priorityClass = priority === 'high' ? 'tm-priority-high' : priority === 'low' ? 'tm-priority-low' : priority === 'medium' ? 'tm-priority-medium' : 'tm-priority-none';
                    const priorityText = priority ? ({ high: '高', medium: '中', low: '低' }[priority] || '无') : '无';
                    return `<td class="${priorityClass} tm-cell-editable" style="width: ${widths.priority || 96}px; min-width: ${widths.priority || 96}px; max-width: ${widths.priority || 96}px; text-align: center;" onclick="tmPickPriority('${task.id}', this, event)">${priorityText}</td>`;
                },
                startDate: () => `
                    <td class="tm-cell-editable" style="width: ${widths.startDate || 90}px; min-width: ${widths.startDate || 90}px; max-width: ${widths.startDate || 90}px;" onclick="tmBeginCellEdit('${task.id}','startDate',this,event)">${__tmFormatTaskTime(startDate)}</td>`,
                completionTime: () => `
                    <td class="tm-cell-editable" style="width: ${widths.completionTime || 170}px; min-width: ${widths.completionTime || 170}px; max-width: ${widths.completionTime || 170}px;" onclick="tmBeginCellEdit('${task.id}','completionTime',this,event)">${__tmFormatTaskTime(completionTime)}</td>`,
                duration: () => `
                    <td class="tm-cell-editable" style="width: ${widths.duration || 96}px; min-width: ${widths.duration || 96}px; max-width: ${widths.duration || 96}px;" onclick="tmBeginCellEdit('${task.id}','duration',this,event)">${esc(duration || '')}</td>`,
                spent: () => {
                    const mode = String(SettingsStore.data.tomatoSpentAttrMode || 'minutes').trim() || 'minutes';
                    const txt = (SettingsStore.data.enableTomatoIntegration && mode === 'hours')
                        ? __tmFormatSpentHours(__tmParseNumber(task?.tomatoHours))
                        : __tmFormatSpentMinutes(__tmGetTaskSpentMinutes(task));
                    return `<td style="width: ${widths.spent || 96}px; min-width: ${widths.spent || 96}px; max-width: ${widths.spent || 96}px; text-align:center; font-variant-numeric: tabular-nums;">${esc(txt)}</td>`;
                },
                remark: () => `
                    <td class="tm-cell-editable" style="width: ${widths.remark || 240}px; min-width: ${widths.remark || 240}px; max-width: ${widths.remark || 240}px;" title="${esc(remark || '')}" onclick="tmBeginCellEdit('${task.id}','remark',this,event)">${esc(remark || '')}</td>`,
                status: () => {
                     const statusOptions = SettingsStore.data.customStatusOptions || [];
                     const currentStatus = task.customStatus || 'todo';
                     const statusOption = statusOptions.find(o => o.id === currentStatus) || { name: currentStatus, color: '#757575' };
                     return `
                        <td style="width: ${widths.status || 96}px; min-width: ${widths.status || 96}px; max-width: ${widths.status || 96}px; text-align: center;" onclick="tmOpenStatusSelect('${task.id}', event)">
                            <span class="tm-status-tag" style="background-color: ${statusOption.color}; color: #fff; padding: 2px 6px; border-radius: 4px; font-size: 12px;">
                                ${statusOption.name}
                            </span>
                        </td>
                     `;
                }
            };

            const focusId = SettingsStore.data.enableTomatoIntegration ? String(state.timerFocusTaskId || '').trim() : '';
            const rowClass = focusId ? (focusId === String(task.id) ? 'tm-timer-focus' : 'tm-timer-dim') : '';
            let rowHtml = `<tr data-id="${task.id}" data-depth="${depth}" class="${rowClass}" ${groupBg ? `style="background-color:${groupBg};"` : ''} draggable="true" ondragstart="tmDragTaskStart(event, '${task.id}')" ondragend="tmDragTaskEnd(event)" onclick="tmRowClick(event, '${task.id}')" oncontextmenu="tmShowTaskContextMenu(event, '${task.id}')">`;
            colOrder.forEach(col => {
                if (cells[col]) rowHtml += cells[col]();
            });
            rowHtml += `</tr>`;
            return rowHtml;
        };

        // 递归渲染任务树，子任务按照全局 filteredTasks 顺序排列
        const renderTaskTree = (task, depth) => {
            const rows = [];

            // 获取该任务在 filtered 中的子任务
            const childTasks = (task.children || []).filter(c => filteredIdSet.has(c.id));

            // 按照全局排序顺序对子任务排序
            childTasks.sort((a, b) => getTaskOrder(a.id) - getTaskOrder(b.id));

            const hasChildren = childTasks.length > 0;
            const collapsed = state.collapsedTaskIds.has(String(task.id));
            const showChildren = hasChildren && !task.done;

            rows.push(emitRow(task, depth, showChildren, collapsed));

            if (showChildren && !collapsed) {
                childTasks.forEach(child => {
                    rows.push(...renderTaskTree(child, depth + 1));
                });
            }

            return rows;
        };

        const allRows = [];

        // 处理置顶任务（全局混排）
        if (pinnedRoots.length > 0) {
            currentGroupBg = '';
            pinnedRoots.forEach(task => {
                allRows.push(...renderTaskTree(task, 0));
            });
        }

        // 处理普通任务
        if (state.quadrantEnabled && normalRoots.length > 0) {
            // 四象限分组逻辑
            const quadrantRules = (SettingsStore.data.quadrantConfig && SettingsStore.data.quadrantConfig.rules) || [];
            
            // 获取任务的重要性等级
            const getImportanceLevel = (task) => {
                const priority = String(task.priority || '').toLowerCase();
                if (priority === 'a' || priority === '高' || priority === 'high') return 'high';
                if (priority === 'b' || priority === '中' || priority === 'medium') return 'medium';
                if (priority === 'c' || priority === '低' || priority === 'low') return 'low';
                return 'none';
            };
            
            // 获取任务的时间范围分类
            const getTimeRange = (task) => {
                const timeStr = task.completionTime;
                if (!timeStr) return 'nodate';
                
                const taskDate = new Date(timeStr);
                if (isNaN(taskDate.getTime())) return 'nodate';
                
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const target = new Date(taskDate.getFullYear(), taskDate.getMonth(), taskDate.getDate());
                
                const diffDays = Math.ceil((target - today) / (1000 * 60 * 60 * 24));
                
                if (diffDays < 0) return 'overdue';
                if (diffDays <= 7) return 'within7days';
                if (diffDays <= 15) return 'within15days';
                if (diffDays <= 30) return 'within30days';
                return 'beyond30days';
            };
            
            // 获取任务距离今天的天数
            const getTaskDays = (task) => {
                const timeStr = task.completionTime;
                if (!timeStr) return Infinity;
                const taskDate = new Date(timeStr);
                if (isNaN(taskDate.getTime())) return Infinity;
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const target = new Date(taskDate.getFullYear(), taskDate.getMonth(), taskDate.getDate());
                return Math.ceil((target - today) / (1000 * 60 * 60 * 24));
            };
            
            // 将任务分配到四象限
            const quadrantGroups = {};
            quadrantRules.forEach(rule => {
                quadrantGroups[rule.id] = {
                    ...rule,
                    items: [],
                    sortOrder: 0
                };
            });
            
            // 四象限排序：重要紧急 > 重要不紧急 > 不重要紧急 > 不重要不紧急
            const quadrantOrder = ['urgent-important', 'not-urgent-important', 'urgent-not-important', 'not-urgent-not-important'];
            
            normalRoots.forEach(task => {
                const importance = getImportanceLevel(task);
                const timeRange = getTimeRange(task);
                const taskDays = getTaskDays(task);
                
                // 查找匹配的四象限规则
                let matchedRule = null;
                for (const rule of quadrantRules) {
                    const importanceMatch = rule.importance.includes(importance);
                    
                    // 检查时间范围匹配（支持 beyondXdays 范围）
                    let timeRangeMatch = rule.timeRanges.includes(timeRange);
                    if (!timeRangeMatch) {
                        // 检查是否选择了 "余X天以上" 选项
                        for (const range of rule.timeRanges) {
                            if (range.startsWith('beyond') && range !== 'beyond30days') {
                                const days = parseInt(range.replace('beyond', '').replace('days', ''));
                                if (!isNaN(days) && taskDays > days) {
                                    timeRangeMatch = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (importanceMatch && timeRangeMatch) {
                        matchedRule = rule;
                        break;
                    }
                }
                
                if (matchedRule) {
                    quadrantGroups[matchedRule.id].items.push(task);
                }
            });
            
            // 渲染四象限分组
            const colorMap = {
                red: 'var(--tm-quadrant-red)',
                yellow: 'var(--tm-quadrant-yellow)',
                blue: 'var(--tm-quadrant-blue)',
                green: 'var(--tm-quadrant-green)'
            };
            
            const bgColorMap = {
                red: 'var(--tm-quadrant-bg-red)',
                yellow: 'var(--tm-quadrant-bg-yellow)',
                blue: 'var(--tm-quadrant-bg-blue)',
                green: 'var(--tm-quadrant-bg-green)'
            };
            
            quadrantOrder.forEach((quadrantId, index) => {
                const group = quadrantGroups[quadrantId];
                if (!group || group.items.length === 0) return;
                
                const color = colorMap[group.color] || 'var(--tm-text-color)';
                
                // 支持折叠
                const groupKey = `quadrant_${quadrantId}`;
                const isCollapsed = state.collapsedGroups?.has(groupKey);
                const toggle = `<span class="tm-group-toggle" onclick="tmToggleGroupCollapse('${groupKey}', event)" style="cursor:pointer;margin-right:8px;display:inline-block;width:12px;">${isCollapsed ? '▸' : '▾'}</span>`;
                
                // 计算时长总和
                const durationFormat = SettingsStore.data.durationFormat || 'hours';
                const calculateDuration = (items) => {
                    let totalMinutes = 0;
                    items.forEach(task => {
                        const durationStr = String(task.duration || '').trim();
                        if (!durationStr) return;
                        let minutes = 0;
                        if (durationStr.toLowerCase().endsWith('h')) {
                            const hours = parseFloat(durationStr.toLowerCase().replace('h', ''));
                            if (!isNaN(hours)) minutes = hours * 60;
                        } else if (durationStr.toLowerCase().endsWith('min')) {
                            const mins = parseFloat(durationStr.toLowerCase().replace('min', ''));
                            if (!isNaN(mins)) minutes = mins;
                        } else {
                            const num = parseFloat(durationStr);
                            if (!isNaN(num)) minutes = num > 100 ? num : num * 60;
                        }
                        totalMinutes += minutes;
                    });
                    if (totalMinutes === 0) return '';
                    if (durationFormat === 'hours') {
                        const hours = Math.round(totalMinutes / 60 * 10) / 10;
                        return `${hours}h`;
                    }
                    return `${totalMinutes}min`;
                };
                const durationSum = calculateDuration(group.items);
                
                allRows.push(`<tr class="tm-group-row" data-group-key="${groupKey}"><td colspan="${colCount}" onclick="tmToggleGroupCollapse('${groupKey}', event)" style="cursor:pointer;background:var(--tm-header-bg);font-weight:bold;color:${color};"><div class="tm-group-sticky">${toggle}${esc(group.name)}<span class="tm-badge tm-badge--count">${group.items.length}</span>${durationSum ? `<span class="tm-badge tm-badge--duration"><span class="tm-badge__icon">📊</span>${esc(durationSum)}</span>` : ''}</div></td></tr>`);
                
                // 如果未折叠，渲染任务
                if (!isCollapsed) {
                    currentGroupBg = enableGroupBg ? __tmGroupBgFromLabelColor(color, isDark) : '';
                    group.items.forEach(task => {
                        allRows.push(...renderTaskTree(task, 0));
                    });
                }
            });
        } else if (state.groupByDocName) {
            // 按文档分组模式：不应用全局混排，按文档顺序显示，支持折叠
            const enableDocH2Subgroup = SettingsStore.data.docH2SubgroupEnabled !== false;
            const headingLevel = String(SettingsStore.data.taskHeadingLevel || 'h2').trim() || 'h2';
            const headingLabelMap = { h1: '一级标题', h2: '二级标题', h3: '三级标题', h4: '四级标题', h5: '五级标题', h6: '六级标题' };
            const noHeadingLabel = `无${headingLabelMap[headingLevel] || '标题'}`;
            const docsInOrder = __tmSortDocEntriesByPinned(
                state.taskTree || [],
                String(SettingsStore.data.currentGroupId || 'all').trim() || 'all'
            ).map(d => d.id).filter(Boolean);

            docsInOrder.forEach(docId => {
                const docEntry = state.taskTree.find(d => d.id === docId);
                if (!docEntry) return;

                // 获取该文档在 filtered 中的任务
                const docTasks = state.filteredTasks.filter(t => t.root_id === docId);
                if (docTasks.length === 0) return;

                // 获取该文档的根任务
                const docRootTasks = docTasks.filter(t => {
                    if (!t.parentTaskId) return true;
                    return !filteredIdSet.has(t.parentTaskId);
                });

                // 分离置顶和非置顶
                const docNormal = docRootTasks.filter(t => !t.pinned);
                docNormal.sort((a, b) => getTaskOrder(a.id) - getTaskOrder(b.id));

                // 渲染文档标题（支持折叠）
                const docName = docEntry.name || '未知文档';
                const groupKey = `doc_${docId}`;
                const isCollapsed = state.collapsedGroups?.has(groupKey);
                const toggle = `<span class="tm-group-toggle" onclick="tmToggleGroupCollapse('${groupKey}', event)" style="cursor:pointer;margin-right:8px;display:inline-block;width:12px;">${isCollapsed ? '▸' : '▾'}</span>`;
                const labelColor = __tmGetDocColorHex(docId, isDark) || 'var(--tm-group-doc-label-color)';

                allRows.push(`<tr class="tm-group-row" data-group-key="${groupKey}"><td colspan="${colCount}" onclick="tmToggleGroupCollapse('${groupKey}', event)" style="cursor:pointer;background:var(--tm-header-bg);font-weight:bold;color:var(--tm-text-color);"><div class="tm-group-sticky">${toggle}<span class="tm-group-label" style="color:${labelColor};">📄 ${esc(docName)}</span><span class="tm-badge tm-badge--count">${docTasks.length}</span></div></td></tr>`);

                // 渲染该文档的任务（如果未折叠）
                if (!isCollapsed) {
                    currentGroupBg = enableGroupBg ? __tmGroupBgFromLabelColor(labelColor, isDark) : '';
                    if (!enableDocH2Subgroup) {
                        docNormal.forEach(task => {
                            allRows.push(...renderTaskTree(task, 0));
                        });
                    } else {
                        const h2Groups = new Map();
                        const h2Buckets = __tmBuildDocHeadingBuckets(docNormal, noHeadingLabel);
                        docNormal.forEach(task => {
                                const b = __tmGetDocHeadingBucket(task, noHeadingLabel);
                                if (!h2Groups.has(b.key)) h2Groups.set(b.key, { label: b.label, items: [] });
                                h2Groups.get(b.key).items.push(task);
                            });

                        h2Buckets.forEach((bucket) => {
                            const g = h2Groups.get(bucket.key) || { label: String(bucket.label || ''), items: [] };
                            const items = Array.isArray(g.items) ? g.items : [];
                            const h2Key = `doc_${docId}__h2_${encodeURIComponent(String(bucket.key || 'label:__none__'))}`;
                            const h2Collapsed = state.collapsedGroups?.has(h2Key);
                            const toggleH2 = `<span class="tm-group-toggle" onclick="tmToggleGroupCollapse('${h2Key}', event)" style="cursor:pointer;margin-right:8px;display:inline-block;width:12px;">${h2Collapsed ? '▸' : '▾'}</span>`;
                            allRows.push(`<tr class="tm-group-row" data-group-kind="h2" data-group-key="${esc(h2Key)}"><td colspan="${colCount}" onclick="tmToggleGroupCollapse('${h2Key}', event)" style="cursor:pointer;background:var(--tm-header-bg);font-weight:bold;color:var(--tm-secondary-text);"><div class="tm-group-sticky" style="padding-left:2ch;">${toggleH2}<span class="tm-group-label">🧩 ${esc(g.label || '')}</span><span class="tm-badge tm-badge--count">${Array.isArray(items) ? items.length : 0}</span></div></td></tr>`);
                            if (!h2Collapsed) {
                                items.forEach(task => {
                                    allRows.push(...renderTaskTree(task, 0));
                                });
                            }
                        });
                    }
                }
            });
        } else if (state.groupByTime && normalRoots.length > 0) {
            // 按时间分组逻辑（跨文档）
            const getTimeGroup = (task) => {
                const timeStr = task.completionTime;
                if (!timeStr) {
                    return { key: 'pending', label: '待定', sortValue: Infinity };
                }

                const taskDate = new Date(timeStr);
                if (isNaN(taskDate.getTime())) {
                    return { key: 'pending', label: '待定', sortValue: Infinity };
                }

                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const target = new Date(taskDate.getFullYear(), taskDate.getMonth(), taskDate.getDate());

                const diffDays = Math.ceil((target - today) / (1000 * 60 * 60 * 24));

                if (diffDays < 0) return { key: 'overdue', label: '已过期', sortValue: diffDays };
                if (diffDays === 0) return { key: 'today', label: '今天', sortValue: 0 };
                if (diffDays === 1) return { key: 'tomorrow', label: '明天', sortValue: 1 };
                if (diffDays === 2) return { key: 'after_tomorrow', label: '后天', sortValue: 2 };

                return { key: `days_${diffDays}`, label: `余${diffDays}天`, sortValue: diffDays };
            };

            // 按时间分组
            const timeGroups = new Map();
            normalRoots.forEach(task => {
                const groupInfo = getTimeGroup(task);
                if (!timeGroups.has(groupInfo.key)) {
                    timeGroups.set(groupInfo.key, { ...groupInfo, items: [] });
                }
                timeGroups.get(groupInfo.key).items.push(task);
            });

            // 按时间顺序渲染分组
            const sortedGroups = [...timeGroups.values()].sort((a, b) => a.sortValue - b.sortValue);

            // 计算时长总和的辅助函数
            const calculateGroupDuration = (items) => {
                const durationFormat = SettingsStore.data.durationFormat || 'hours';
                let totalMinutes = 0;
                
                items.forEach(task => {
                    // 获取任务的时长（可能是数字或字符串）
                    const durationStr = String(task.duration || '').trim();
                    if (!durationStr) return;
                    
                    // 尝试解析时长（支持 "1.5h", "90min", "90", "1.5" 等格式）
                    let minutes = 0;
                    
                    if (durationStr.toLowerCase().endsWith('h')) {
                        // 小时格式，如 "1.5h"
                        const hours = parseFloat(durationStr.toLowerCase().replace('h', ''));
                        if (!isNaN(hours)) minutes = hours * 60;
                    } else if (durationStr.toLowerCase().endsWith('min')) {
                        // 分钟格式，如 "90min"
                        const mins = parseFloat(durationStr.toLowerCase().replace('min', ''));
                        if (!isNaN(mins)) minutes = mins;
                    } else {
                        // 纯数字，可能是小时或分钟
                        const num = parseFloat(durationStr);
                        if (!isNaN(num)) {
                            // 如果数字大于100，认为是分钟，否则是小时
                            minutes = num > 100 ? num : num * 60;
                        }
                    }
                    
                    totalMinutes += minutes;
                });
                
                // 如果总时长为0，返回空字符串（不显示）
                if (totalMinutes <= 0) return '';
                
                // 根据设置格式化输出
                if (durationFormat === 'hours') {
                    const hours = totalMinutes / 60;
                    // 如果小于1小时，显示分钟；如果大于等于1小时，显示小时
                    if (hours < 1) {
                        return `${Math.round(totalMinutes)}min`;
                    } else if (hours === Math.floor(hours)) {
                        return `${Math.round(hours)}h`;
                    } else {
                        return `${hours.toFixed(1)}h`;
                    }
                } else {
                    return `${totalMinutes}min`;
                }
            };

            sortedGroups.forEach(group => {
                const isCollapsed = state.collapsedGroups?.has(group.key);
                const toggle = `<span class="tm-group-toggle" onclick="tmToggleGroupCollapse('${group.key}', event)" style="cursor:pointer;margin-right:8px;display:inline-block;width:12px;">${isCollapsed ? '▸' : '▾'}</span>`;
                const labelColor = __tmGetTimeGroupLabelColor(group);
                
                // 计算该分组下所有任务的时长总和
                const durationSum = calculateGroupDuration(group.items);
                
                allRows.push(`<tr class="tm-group-row" data-group-key="${esc(group.key)}"><td colspan="${colCount}" onclick="tmToggleGroupCollapse('${group.key}', event)" style="cursor:pointer;background:var(--tm-header-bg);font-weight:bold;color:var(--tm-text-color);"><div class="tm-group-sticky">${toggle}<span class="tm-group-label" style="color:${labelColor};">${esc(group.label)}</span><span class="tm-badge tm-badge--count">${group.items.length}</span>${durationSum ? `<span class="tm-badge tm-badge--duration"><span class="tm-badge__icon">📊</span>${esc(durationSum)}</span>` : ''}</div></td></tr>`);

                if (!isCollapsed) {
                    currentGroupBg = enableGroupBg ? __tmGroupBgFromLabelColor(labelColor, isDark) : '';
                    // 组内任务按照全局顺序排列
                    group.items.sort((a, b) => getTaskOrder(a.id) - getTaskOrder(b.id));
                    group.items.forEach(task => {
                        allRows.push(...renderTaskTree(task, 0));
                    });
                }
            });
        } else if (state.groupByTaskName) {
            // 按任务名分组模式：只对顶级任务分组，子任务跟随父任务
            // 1. 先找出所有顶级任务
            const topLevelTasks = state.filteredTasks.filter(t => !t.parentTaskId);
            
            // 2. 按任务内容分组顶级任务
            const tasksByContent = {};
            topLevelTasks.forEach(task => {
                const content = String(task.content || '').trim();
                if (!content) return;
                if (!tasksByContent[content]) {
                    tasksByContent[content] = [];
                }
                tasksByContent[content].push(task);
            });

            // 3. 按任务名称升序排序
            const sortedGroups = Object.entries(tasksByContent)
                .sort((a, b) => String(a[0] || '').localeCompare(String(b[0] || ''), 'zh-CN'));

            // 4. 渲染分组
            sortedGroups.forEach(([content, tasks]) => {
                if (tasks.length === 0) return;

                // 渲染分组标题
                const safeContent = String(content || '').replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, '_');
                const groupKey = `task_${safeContent}`;
                const isCollapsed = state.collapsedGroups?.has(groupKey);
                const toggle = `<span class="tm-group-toggle" onclick="tmToggleGroupCollapse('${groupKey}', event)" style="cursor:pointer;margin-right:8px;display:inline-block;width:12px;">${isCollapsed ? '▸' : '▾'}</span>`;
                const labelColor = 'var(--tm-primary-color)';

                allRows.push(`<tr class="tm-group-row" data-group-key="${groupKey}"><td colspan="${colCount}" onclick="tmToggleGroupCollapse('${groupKey}', event)" style="cursor:pointer;background:var(--tm-header-bg);font-weight:bold;color:var(--tm-text-color);"><div class="tm-group-sticky">${toggle}<span class="tm-group-label" style="color:${labelColor};">🧩 ${esc(content)}</span><span class="tm-badge tm-badge--count">${tasks.length}</span></div></td></tr>`);

                // 渲染该组的顶级任务及其子任务（如果未折叠）
                if (!isCollapsed) {
                    // 按任务名分组时，每个任务使用自己文档的颜色
                    tasks.forEach(task => {
                        if (task.root_id) {
                            const taskDocColor = __tmGetDocColorHex(task.root_id, isDark);
                            currentGroupBg = (enableGroupBg && taskDocColor) ? __tmGroupBgFromLabelColor(taskDocColor, isDark) : '';
                        } else {
                            currentGroupBg = '';
                        }
                        allRows.push(...renderTaskTree(task, 0));
                    });
                }
            });
        } else {
            // 普通全局混排（不按时间分组，不按文档分组，不按任务名分组）
            currentGroupBg = '';
            normalRoots.forEach(task => {
                allRows.push(...renderTaskTree(task, 0));
            });
        }

        if (allRows.length === 0) {
            return `<tr><td colspan="${colCount}" style="text-align: center; padding: 40px; color: var(--tm-secondary-text);">暂无任务</td></tr>`;
        }

        return allRows.join('');
    }

    // 切换任务状态
    window.tmToggle = async function(id) {
        const task = state.flatTasks[id];
        if (!task) return;

        await window.tmSetDone(id, !task.done);
    };

    function __tmUpdateDoneMarkdown(markdown, done) {
        const md = String(markdown || '');
        const replaced = md.replace(/^(\s*[\*\-]\s*)\[(?:\s|x|X)\]/, `$1[${done ? 'x' : ' '}]`);
        if (replaced === md) {
            const alt = md.replace(/^(\s*[\*\-]\s*)\[[xX ]\]\s*/, `$1[${done ? 'x' : ' '}] `);
            return alt;
        }
        return replaced;
    }

    let __tmRenderScheduled = false;
    let __tmRenderNeedFilters = false;
    function __tmScheduleRender(options = {}) {
        const withFilters = !(options && options.withFilters === false);
        __tmRenderNeedFilters = __tmRenderNeedFilters || withFilters;
        if (__tmRenderScheduled) return;
        __tmRenderScheduled = true;
        requestAnimationFrame(() => {
            __tmRenderScheduled = false;
            const needFilters = __tmRenderNeedFilters;
            __tmRenderNeedFilters = false;
            if (needFilters) applyFilters();
            render();
        });
    }

    // ========== 全局操作锁 ==========

    const GlobalLock = {
        locked: false,
        timer: null,

        lock() {
            this.locked = true;
            this.updateUI();

            // 清除之前的定时器
            if (this.timer) clearTimeout(this.timer);
            this.timer = null;

            // 不再使用自动解锁，而是等待 render() 完成后手动解锁
        },

        unlock() {
            this.locked = false;
            this.timer = null;
            this.updateUI();
        },

        updateUI() {
            // 更新所有复选框的禁用状态
            const checkboxes = document.querySelectorAll('.tm-task-checkbox');
            checkboxes.forEach(cb => {
                cb.disabled = this.locked;
                if (this.locked) {
                    cb.classList.add('tm-operating');
                } else {
                    cb.classList.remove('tm-operating');
                }
            });
        },

        isLocked() {
            return this.locked;
        }
    };

    // ============ 树形状态保护器（解决父子任务属性丢失） ============
    const TreeProtector = {
        // 操作前保存完整树状态：内容 -> {id, parentId, data, collapsed}
        snapshot: new Map(),
        idMapping: new Map(), // oldId -> newId
        collapsedState: new Map(), // oldId -> boolean

        // 递归保存树
        saveTree(tasks, parentId = null, level = 0) {
            tasks.forEach(task => {
                // 保存关键信息，以内容为key（因为ID会变，内容相对稳定）
                const key = `${level}:${parentId || 'root'}:${task.content}`;
                this.snapshot.set(key, {
                    oldId: task.id,
                    parentId: parentId,
                    level: level,
                    data: {
                        priority: task.priority || '',
                        duration: task.duration || '',
                        remark: task.remark || '',
                        completionTime: task.completionTime || '',
                        customTime: task.customTime || '',
                        customStatus: task.customStatus || ''
                    },
                    done: task.done
                });

                // 保存折叠状态
                this.collapsedState.set(task.id, state.collapsedTaskIds.has(task.id));

                // 递归保存子任务
                if (task.children && task.children.length > 0) {
                    this.saveTree(task.children, task.id, level + 1);
                }
            });
        },

        // 操作后恢复树属性
        restoreTree(tasks, parentId = null, level = 0) {
            tasks.forEach(task => {
                // 构建查找key
                const key = `${level}:${parentId || 'root'}:${task.content}`;
                const saved = this.snapshot.get(key);

                if (saved) {
                    // 建立ID映射
                    this.idMapping.set(saved.oldId, task.id);

                    // 恢复属性（优先使用保存的，除非新任务已有值）
                    if (!task.priority && saved.data.priority) task.priority = saved.data.priority;
                    if (!task.duration && saved.data.duration) task.duration = saved.data.duration;
                    if (!task.remark && saved.data.remark) task.remark = saved.data.remark;
                    if (!task.completionTime && saved.data.completionTime) task.completionTime = saved.data.completionTime;
                    if (!task.customTime && saved.data.customTime) task.customTime = saved.data.customTime;
                    if (!task.customStatus && saved.data.customStatus) task.customStatus = saved.data.customStatus;

                    // 恢复MetaStore映射
                    if (saved.oldId !== task.id) {
                        MetaStore.remapId(saved.oldId, task.id);
                    }
                }

                // 递归恢复子任务
                if (task.children && task.children.length > 0) {
                    this.restoreTree(task.children, task.id, level + 1);
                }
            });
        },

        // 恢复折叠状态（基于ID映射）
        restoreCollapsedState() {
            const newCollapsed = new Set();
            for (const [oldId, wasCollapsed] of this.collapsedState.entries()) {
                if (wasCollapsed) {
                    // 查找新ID
                    const newId = this.idMapping.get(oldId);
                    if (newId) {
                        newCollapsed.add(newId);
                    }
                }
            }
            state.collapsedTaskIds = newCollapsed;
            SettingsStore.data.collapsedTaskIds = [...newCollapsed];
            SettingsStore.save();
        },

        clear() {
            this.snapshot.clear();
            this.idMapping.clear();
            this.collapsedState.clear();
        }
    };

    // 保存任务完整状态到 MetaStore
    function saveTaskFullState(task) {
        if (!task?.id) return;

        const stateData = {
            priority: task.priority || '',
            duration: task.duration || '',
            remark: task.remark || '',
            completionTime: task.completionTime || '',
            customTime: task.customTime || '',
            content: task.content || '',
            done: task.done,
            parentTaskId: task.parentTaskId || null,
            timestamp: Date.now()
        };

        MetaStore.set(task.id, stateData);
    }

    // 从 MetaStore 恢复任务状态
    function restoreTaskFromMeta(task) {
        if (!task?.id) return task;

        const saved = MetaStore.get(task.id);
        if (!saved) return task;

        // 只有当当前值为空时才恢复（避免覆盖新输入）
        if (!task.priority && saved.priority) task.priority = saved.priority;
        if (!task.duration && saved.duration) task.duration = saved.duration;
        if (!task.remark && saved.remark) task.remark = saved.remark;
        if (!task.completionTime && saved.completionTime) task.completionTime = saved.completionTime;
        if (!task.customTime && saved.customTime) task.customTime = saved.customTime;

        return task;
    }

    async function __tmEnsureTaskInStateById(id) {
        const tid = String(id || '').trim();
        if (!tid) return null;
        const exists = state.flatTasks?.[tid];
        if (exists) return exists;
        let row = null;
        try { row = await API.getTaskById(tid); } catch (e) { row = null; }
        if (!row || typeof row !== 'object') return null;
        const task = { ...row };
        try {
            const parsed = API.parseTaskStatus(task.markdown);
            task.done = !!parsed.done;
            task.content = parsed.content;
        } catch (e) {}
        try { MetaStore.applyToTask(task); } catch (e) {}
        try { normalizeTaskFields(task, task.doc_name || task.docName || '未命名文档'); } catch (e) {}
        if (!state.flatTasks || typeof state.flatTasks !== 'object') state.flatTasks = {};
        state.flatTasks[tid] = task;
        return task;
    }

    async function __tmSetDoneByIdStateless(id, done) {
        const tid = String(id || '').trim();
        if (!tid) return false;
        const targetDone = !!done;
        let kramdown = '';
        try { kramdown = await API.getBlockKramdown(tid); } catch (e) { kramdown = ''; }
        if (!kramdown) return false;
        const statusRegex = /^(\s*(?:[\*\-]|\d+\.)\s*\[)([ xX])(\])/;
        const fallbackRegex = /(\[)([ xX])(\])/;
        let nextMd = '';
        if (statusRegex.test(kramdown)) {
            nextMd = kramdown.replace(statusRegex, `$1${targetDone ? 'x' : ' '}$3`);
        } else if (fallbackRegex.test(kramdown)) {
            nextMd = kramdown.replace(fallbackRegex, `$1${targetDone ? 'x' : ' '}$3`);
        } else {
            return false;
        }
        if (nextMd === kramdown) return true;
        try {
            const res = await API.call('/api/block/updateBlock', {
                dataType: 'markdown',
                data: nextMd,
                id: tid
            });
            return !!(res && res.code === 0);
        } catch (e) {
            return false;
        }
    }

    // 更新 markdown 中的完成状态
    function updateDoneInMarkdown(markdown, done) {
        if (!markdown) return '- [ ] ';
        // 匹配列表项开头
        return markdown.replace(/^(\s*[\*\-]\s*)\[[ xX]\]/, `$1[${done ? 'x' : ' '}]`);
    }

    // ========== 原有完成状态处理 ==========

    const __tmDoneDesired = new Map();
    const __tmDoneBase = new Map();
    const __tmDoneChain = new Map();

    function __tmRemapTaskId(oldId, newId) {
        try {
            if (!oldId || !newId || oldId === newId) return;
            const task = state.flatTasks[oldId];
            if (!task) return;
            delete state.flatTasks[oldId];
            task.id = newId;
            state.flatTasks[newId] = task;
            try { MetaStore.remapId(oldId, newId); } catch (e) {}
            
            const updateRecursive = (list) => {
                list.forEach(t => {
                    if (t.id === oldId) t.id = newId;
                    if (t.children && t.children.length > 0) updateRecursive(t.children);
                });
            };

            state.taskTree.forEach(doc => {
                updateRecursive(doc.tasks);
            });
            if (__tmDoneDesired.has(oldId)) {
                __tmDoneDesired.set(newId, __tmDoneDesired.get(oldId));
                __tmDoneDesired.delete(oldId);
            }
            if (__tmDoneBase.has(oldId)) {
                __tmDoneBase.set(newId, __tmDoneBase.get(oldId));
                __tmDoneBase.delete(oldId);
            }
            if (__tmDoneChain.has(oldId)) {
                __tmDoneChain.set(newId, __tmDoneChain.get(oldId));
                __tmDoneChain.delete(oldId);
            }
        } catch (e) {}
    }

    async function __tmUpdateDoneRemote(id) {
        const task = state.flatTasks[id];
        if (!task) return;
        const desired = __tmDoneDesired.get(id);
        if (typeof desired !== 'boolean') return;

        const base = __tmDoneBase.get(id) ?? task.markdown;
        const md = __tmUpdateDoneMarkdown(base, desired);
        if (md === base) return;

        const attempt = async () => {
            let effectiveId = id;
            const upd = await API.updateBlock(effectiveId, md);
            const updatedId = upd?.id || effectiveId;
            if (updatedId && updatedId !== effectiveId) {
                __tmRemapTaskId(effectiveId, updatedId);
                effectiveId = updatedId;
            }
            __tmDoneBase.set(effectiveId, md);
            task.markdown = md;
            task.done = desired;
        };

        try {
            await attempt();
        } catch (e) {
            await new Promise(r => setTimeout(r, 120));
            await attempt();
        }
    }

    // ============ 重写设置完成状态（带完整树保护） ============
    window.tmSetPinned = async function(id, pinned, ev) {
        if (ev) ev.stopPropagation();

        const task = state.flatTasks[id];
        if (!task) return;

        const val = !!pinned;
        try {
            // Update state
            task.pinned = val;
            
            // Update MetaStore (fast cache)
            __tmPersistMetaAndAttrs(id, { pinned: val });

            applyFilters();
            render();
            hint(`✅ ${val ? '已置顶' : '已取消置顶'}`, 'success');
        } catch (e) {
            hint(`❌ 操作失败: ${e.message}`, 'error');
            if (ev?.target) ev.target.checked = !val;
        }
    };

    window.tmSetDone = async function(id, done, ev) {
        if (ev) {
            ev.stopPropagation();
            ev.preventDefault();
        }

        let task = state.flatTasks[id];
        if (!task) {
            try { task = await __tmEnsureTaskInStateById(id); } catch (e) { task = null; }
        }
        if (!task) {
            const ok = await __tmSetDoneByIdStateless(id, done);
            if (ok) {
                try {
                    if (!state.doneOverrides || typeof state.doneOverrides !== 'object') state.doneOverrides = {};
                    state.doneOverrides[String(id)] = !!done;
                } catch (e) {}
                try { hint(done ? '✅ 任务已完成' : '✅ 已取消完成', 'success'); } catch (e) {}
                try { globalThis.__tmCalendar?.refreshInPlace?.({ hard: false }); } catch (e) {}
                return;
            }
            hint('❌ 任务不存在', 'error');
            if (ev?.target) ev.target.checked = !done;
            return;
        }

        const targetDone = !!done;

        // 检查全局锁
        if (GlobalLock.isLocked()) {
            hint('⚠ 操作频繁，请等待10ms后再试', 'warning');
            if (ev?.target) ev.target.checked = !targetDone;
            return;
        }

        if (task.done === targetDone) return;

        // 锁定
        GlobalLock.lock();
        const docId = task.root_id;

        // 关键：保存整个文档树的完整状态（包括所有子任务）
        const doc = state.taskTree.find(d => d.id === docId);
        if (doc) {
            TreeProtector.clear();
            TreeProtector.saveTree(doc.tasks);
        }

        // 关键修改：先保存原始状态，然后保存到 MetaStore（保持原始状态，等点击完成后再更新）
        const originalMarkdown = task.markdown;
        const originalDone = task.done;

        // 立即保存当前任务到 MetaStore（保持原始done状态）
        MetaStore.set(id, {
            priority: task.priority || '',
            duration: task.duration || '',
            remark: task.remark || '',
            completionTime: task.completionTime || '',
            customTime: task.customTime || '',
            done: originalDone,
            content: task.content
        });

        // 关键：同时保存整个文档树的所有任务的属性到 MetaStore
        // 这样即使思源重新解析列表块，MetaStore 中有完整备份
        let savedCount = 1;
        const saveAllTasksToMetaRecursive = (tasks) => {
            tasks.forEach(t => {
                savedCount++;
                MetaStore.set(t.id, {
                    priority: t.priority || '',
                    duration: t.duration || '',
                    remark: t.remark || '',
                    completionTime: t.completionTime || '',
                    customTime: t.customTime || '',
                    done: t.done,
                    content: t.content
                });
                if (t.children && t.children.length > 0) {
                    saveAllTasksToMetaRecursive(t.children);
                }
            });
        };
        // 从已经获取的 doc 中获取所有任务并保存
        if (doc && doc.tasks) {
            saveAllTasksToMetaRecursive(doc.tasks);
        }

        // 注意：不要在这里 render()，因为还没点击复选框
        // render() 会在从DOM读取实际状态后调用

        try {
            // 优先尝试 API 更新（解决文档未打开无法操作的问题）
            let apiSuccess = false;
            let clickSuccess = false;
            try {
                // 1. 获取 kramdown
                const kramdown = await API.getBlockKramdown(id);

                if (kramdown) {
                    // 2. 正则匹配：匹配行首的任务标记，容忍前面的空白
                    // 匹配：(任意空白)(*或-或数字.)(任意空白)[(空格或xX)](右括号)
                    const statusRegex = /^(\s*(?:[\*\-]|\d+\.)\s*\[)([ xX])(\])/;
                    const match = kramdown.match(statusRegex);
                    
                    if (match) {
                        const currentStatusChar = match[2];
                        const isCurrentlyDone = currentStatusChar !== ' ';

                        if (isCurrentlyDone === targetDone) {
                            apiSuccess = true;
                        } else {
                            // 3. 构造新的 kramdown
                            const newStatusChar = targetDone ? 'x' : ' ';
                            const newKramdown = kramdown.replace(statusRegex, `$1${newStatusChar}$3`);
                            // 4. 调用 updateBlock
                            const res = await API.call('/api/block/updateBlock', {
                                dataType: 'markdown',
                                data: newKramdown,
                                id: id
                            });
                            
                            if (res && res.code === 0) {
                                apiSuccess = true;
                            } else {
                                console.error('[完成状态] API更新失败:', res);
                            }
                        }
                    } else {
                        // Fallback: 尝试查找内容中的第一个复选框标记（即使不在行首）
                        const fallbackRegex = /(\[)([ xX])(\])/;
                        const fallbackMatch = kramdown.match(fallbackRegex);
                        if (fallbackMatch) {
                             const newStatusChar = targetDone ? 'x' : ' ';
                             // 只替换第一个匹配项
                             const newKramdown = kramdown.replace(fallbackRegex, `$1${newStatusChar}$3`);
                             
                             const res = await API.call('/api/block/updateBlock', {
                                dataType: 'markdown',
                                data: newKramdown,
                                id: id
                            });
                            if (res && res.code === 0) {
                                apiSuccess = true;
                            }
                        } else {
                            console.error('[完成状态] 无法在kramdown中找到任务标记');
                        }
                    }
                } else {
                    console.error('[完成状态] 未获取到kramdown内容');
                }
            } catch (e) {
                console.error('[完成状态] API处理异常:', e);
            }

            // 只有当 API 失败时才尝试查找 DOM（作为回退）
            let taskElement = null;
            if (!apiSuccess) {
                // 尝试多种方式找到复选框并点击
                // 方式1：通过 task.id 直接查询列表项
                taskElement = document.querySelector(`[data-type="NodeListItem"][data-node-id="${id}"]`);
                
                // 方式2：遍历所有任务列表项，通过内容匹配
                if (!taskElement) {
                    const allItems = document.querySelectorAll('[data-type="NodeListItem"]');
                    for (const item of allItems) {
                        const paragraph = item.querySelector('[data-type="NodeParagraph"] > div[contenteditable="true"]');
                        if (paragraph && paragraph.textContent?.trim() === task.content) {
                            taskElement = item;
                            break;
                        }
                    }
                }

                // 方式3：遍历所有 protyle-wysiwyg 下的列表项
                if (!taskElement) {
                    const allItems = document.querySelectorAll('.protyle-wysiwyg [data-type="NodeListItem"]');
                    for (const item of allItems) {
                        const paragraph = item.querySelector('[data-type="NodeParagraph"] > div[contenteditable="true"]');
                        if (paragraph && paragraph.textContent?.trim() === task.content) {
                            taskElement = item;
                            break;
                        }
                    }
                }
            }

            if (taskElement) {
                // 找到 protyle-action--task 元素并触发点击
                const actionElement = taskElement.querySelector('.protyle-action--task');
                if (actionElement) {
                    // 使用多种事件触发方式
                    const mouseEvents = ['mousedown', 'mouseup', 'click', 'pointerdown', 'pointerup'];
                    for (const eventType of mouseEvents) {
                        const event = new MouseEvent(eventType, {
                            bubbles: true,
                            cancelable: true,
                            view: window,
                            button: 0
                        });
                        actionElement.dispatchEvent(event);
                    }
                    // 也尝试在列表项元素上触发点击
                    const parentEvent = new MouseEvent('click', {
                        bubbles: true,
                        cancelable: true,
                        view: window
                    });
                    taskElement.dispatchEvent(parentEvent);

                    // 关键修复：直接点击真正的 checkbox input 元素并触发 change 事件
                    const checkboxInput = taskElement.querySelector('input[type="checkbox"]');
                    if (checkboxInput) {
                        // 直接修改 checkbox 状态
                        checkboxInput.checked = targetDone;
                        // 触发 change 事件
                        const changeEvent = new Event('change', {
                            bubbles: true,
                            cancelable: true
                        });
                        checkboxInput.dispatchEvent(changeEvent);
                    }

                    clickSuccess = true;
                }
            }

            // 等待思源处理完成
            await new Promise(r => setTimeout(r, 150));

            // 直接使用 targetDone 作为实际状态
            // 因为我们已经模拟点击了思源的复选框，思源会正确处理状态变化
            const actualDone = targetDone;

            // 保存到MetaStore
            MetaStore.set(id, {
                priority: task.priority || '',
                duration: task.duration || '',
                remark: task.remark || '',
                completionTime: task.completionTime || '',
                customTime: task.customTime || '',
                customStatus: task.customStatus || '',
                done: actualDone,
                content: task.content
            });

            // 更新本地状态
            task.done = actualDone;
            state.flatTasks[id] = task;
            try {
                if (!state.doneOverrides || typeof state.doneOverrides !== 'object') state.doneOverrides = {};
                state.doneOverrides[String(id)] = !!actualDone;
            } catch (e) {}

            // 递归更新所有子任务的done状态（如果需要）
            const updateChildrenDone = (tasks) => {
                tasks.forEach(t => {
                    t.done = t.done; // 保持不变
                    if (t.children && t.children.length > 0) {
                        updateChildrenDone(t.children);
                    }
                });
            };
            if (task.children && task.children.length > 0) {
                updateChildrenDone(task.children);
            }

            recalcStats();
            // 延迟 render() 确保思源原生处理完成
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    render();
                });
            });

            hint(actualDone ? '✅ 任务已完成' : '✅ 已取消完成', 'success');

        } catch (err) {
            console.error('[完成操作失败]', err);

            // 恢复
            task.markdown = originalMarkdown;
            task.done = !targetDone;
            try {
                if (!state.doneOverrides || typeof state.doneOverrides !== 'object') state.doneOverrides = {};
                state.doneOverrides[String(id)] = !targetDone;
            } catch (e) {}

            // 尝试恢复树状态
            if (doc) {
                TreeProtector.restoreTree(doc.tasks);
            }

            recalcStats();
            render();
            hint(`❌ 操作失败: ${err.message}`, 'error');
        } finally {
            // render() 完成后手动解锁
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    GlobalLock.unlock();
                });
            });
        }
    };

    // 保存所有任务到MetaStore（递归）
    async function saveAllTasksToMeta(docId) {
        const doc = state.taskTree.find(d => d.id === docId);
        if (!doc) return;

        const saveRecursive = (tasks) => {
            tasks.forEach(task => {
                MetaStore.set(task.id, {
                    priority: task.priority || '',
                    duration: task.duration || '',
                    remark: task.remark || '',
                    completionTime: task.completionTime || '',
                    customTime: task.customTime || '',
                    customStatus: task.customStatus || '',
                    done: task.done,
                    content: task.content
                });
                if (task.children && task.children.length > 0) {
                    saveRecursive(task.children);
                }
            });
        };

        saveRecursive(doc.tasks);
        await MetaStore.saveNow();
    }

    // 通过内容在任务树中查找任务（使用更灵活的匹配）
    function findTaskByContent(tasks, content, depth = 0) {
        for (const t of tasks) {
            // 使用模糊匹配：检查内容是否包含或被包含
            const oldContent = String(t.content || '').trim();
            const newContent = String(content || '').trim();
            // 精确匹配或新内容包含旧内容（旧内容更短）
            if (oldContent === newContent || (newContent.length > oldContent.length && newContent.includes(oldContent))) {
                return t;
            }
            if (t.children && t.children.length > 0) {
                const found = findTaskByContent(t.children, content, depth + 1);
                if (found) return found;
            }
        }
        return null;
    }

    // ============ 受保护的重载（带树恢复） ============
    // manualRelationships: 可选，Map<childId, parentTaskId>，用于在SQL索引未更新时强制指定父子关系
    // injectedTasks: 可选，Array<Task>，用于在SQL索引未更新时强制注入新任务（乐观更新）
    async function reloadDocTasksProtected(docId, expectId = null, manualRelationships = null, injectedTasks = null) {
        // 0. 备份旧的父子关系（用于容灾，当SQL索引失效时恢复现有结构）
        const oldRelationships = new Map(); // Map<childId, {parentId: string, listId: string}>
        const backupRelationships = (tasks) => {
            tasks.forEach(t => {
                if (t.parentTaskId) {
                    oldRelationships.set(t.id, {
                        parentId: t.parentTaskId,
                        listId: t.parent_id // 列表块ID，用于校验是否移动了位置
                    });
                }
                if (t.children && t.children.length > 0) {
                    backupRelationships(t.children);
                }
            });
        };
        const currentDoc = state.taskTree.find(d => d.id === docId);
        if (currentDoc && currentDoc.tasks) {
            backupRelationships(currentDoc.tasks);
        }

        // 1. 重新加载数据 (带重试机制，等待索引更新)
        let flatTasks = [];
        let queryTime = 0;

        if (expectId) {
            let retries = 0;
            const maxRetries = 20; // 最多等待 5秒 (250ms * 20)
            while (retries < maxRetries) {
                const res = await API.getTasksByDocuments([docId], state.queryLimit);
                
                // 检查是否包含期望的ID
                if (res.tasks && res.tasks.find(t => t.id === expectId)) {
                    flatTasks = res.tasks;
                    queryTime = res.queryTime;
                    break;
                }
                
                // 如果是最后一次重试，仍然使用当前结果
                if (retries === maxRetries - 1) {
                    flatTasks = res.tasks || [];
                    queryTime = res.queryTime || 0;
                    break;
                }
                
                // 如果没找到，等待后重试
                await new Promise(r => setTimeout(r, 250));
                retries++;
            }
        } else {
             const res = await API.getTasksByDocuments([docId], state.queryLimit);
             flatTasks = res.tasks || [];
             queryTime = res.queryTime || 0;
        }

        // 1.5 注入强制任务（乐观更新）
        if (injectedTasks && injectedTasks.length > 0) {
            injectedTasks.forEach(injected => {
                if (!flatTasks.find(t => t.id === injected.id)) {
                    flatTasks.push(injected);
                }
            });
        }

        // 2. 关键：先建立内容到 MetaStore 数据的映射
        // 因为思源操作后子任务ID可能改变，需要用内容匹配来找回旧ID的MetaStore数据
        const contentToMeta = new Map();

        // 遍历旧的任务树（如果有的话），建立内容到MetaStore的映射
        const oldDoc = state.taskTree.find(d => d.id === docId);
        if (oldDoc && oldDoc.tasks) {
            const traverseOld = (tasks) => {
                tasks.forEach(t => {
                    const key = (t.content || '').trim();
                    if (key) {
                        const meta = MetaStore.get(t.id);
                        if (meta && Object.keys(meta).length > 0) {
                            contentToMeta.set(key, meta);
                        }
                    }
                    if (t.children && t.children.length > 0) {
                        traverseOld(t.children);
                    }
                });
            };
            traverseOld(oldDoc.tasks);
        }

        // 3. 构建树（保持原有逻辑）
        const taskMap = new Map();
        const rootTasks = [];

        // 先创建所有节点（从 MetaStore 读取所有自定义属性，不依赖 SQL 查询）
        flatTasks.forEach(t => {
            const parsed = API.parseTaskStatus(t.markdown);

            // 关键：优先从内容映射读取 MetaStore 数据（因为ID可能已变化）
            const contentKey = (parsed.content || '').trim();
            let meta = MetaStore.get(t.id) || {};

            // 如果当前ID没有MetaStore数据，尝试从内容映射找回
            if (Object.keys(meta).length === 0 && contentKey && contentToMeta.has(contentKey)) {
                const oldMeta = contentToMeta.get(contentKey);
                meta = oldMeta;

                // 同时保存到当前ID下，确保后续能直接读取
                MetaStore.set(t.id, oldMeta);
            }

            taskMap.set(t.id, {
                id: t.id,
                content: parsed.content,
                // 关键：优先使用 MetaStore 中的 done 状态，而不是从 markdown 解析
                done: meta.done !== undefined ? meta.done : parsed.done,
                markdown: t.markdown,
                parent_id: t.parent_id,
                root_id: t.root_id,
                doc_name: t.doc_name,
                children: [],
                priority: (() => {
                    const mv = Object.prototype.hasOwnProperty.call(meta, 'priority') ? String(meta.priority ?? '') : '';
                    if (mv && mv !== 'null') return mv;
                    return String(t.priority ?? '');
                })(),
                duration: Object.prototype.hasOwnProperty.call(meta, 'duration')
                    ? String(meta.duration ?? '')
                    : String(t.duration ?? ''),
                remark: Object.prototype.hasOwnProperty.call(meta, 'remark')
                    ? String(meta.remark ?? '')
                    : String(t.remark ?? ''),
                completionTime: Object.prototype.hasOwnProperty.call(meta, 'completionTime')
                    ? String(meta.completionTime ?? '')
                    : String(t.completion_time ?? ''),
                customTime: Object.prototype.hasOwnProperty.call(meta, 'customTime')
                    ? String(meta.customTime ?? '')
                    : String(t.custom_time ?? ''),
                pinned: (() => {
                    const raw = Object.prototype.hasOwnProperty.call(meta, 'pinned') ? meta.pinned : t.pinned;
                    if (typeof raw === 'boolean') return raw;
                    const s = String(raw || '').trim().toLowerCase();
                    return s === 'true' || s === '1';
                })(),
                customStatus: Object.prototype.hasOwnProperty.call(meta, 'customStatus')
                    ? String(meta.customStatus ?? '')
                    : String(t.custom_status ?? '')
            });
        });

        // 建立父子关系
        flatTasks.forEach(t => {
            const task = taskMap.get(t.id);

            // 0. 最优先：使用手动指定的关系（用于处理刚插入但索引未更新的任务）
            if (manualRelationships && manualRelationships.has(t.id)) {
                const parentId = manualRelationships.get(t.id);
                const parentTask = taskMap.get(parentId);
                if (parentTask) {
                    task.parentTaskId = parentTask.id;
                    parentTask.children.push(task);
                    return;
                }
            }

            // 1. 优先尝试直接从 SQL 结果中获取父任务 ID (API 已经通过 JOIN 查好了)
            if (t.parent_task_id) {
                const parentTask = taskMap.get(t.parent_task_id);
                if (parentTask) {
                    task.parentTaskId = parentTask.id;
                    parentTask.children.push(task);
                    return;
                }
            }

            // 2. 如果 SQL 没有查到 parent_task_id（可能是旧版本 API 或查询失败降级），尝试手动查找
            // 查找父任务（通过parent_id找到父列表的父任务）
            const parentList = taskMap.get(t.parent_id);
            if (parentList && parentList.parent_id) {
                const parentTask = taskMap.get(parentList.parent_id);
                if (parentTask) {
                    task.parentTaskId = parentTask.id;
                    parentTask.children.push(task);
                    return;
                }
            }

            // 3. 最后尝试使用旧数据的父子关系（容灾）
            // 如果任务所在的列表ID(parent_id)没变，说明它没有移动位置，可以安全沿用旧的父子关系
            if (oldRelationships.has(t.id)) {
                const oldRel = oldRelationships.get(t.id);
                if (oldRel.listId === t.parent_id) {
                    const parentTask = taskMap.get(oldRel.parentId);
                    if (parentTask) {
                        task.parentTaskId = parentTask.id;
                        parentTask.children.push(task);
                        return;
                    }
                }
            }

            task.parentTaskId = null;
            rootTasks.push(task);
        });

        // 3. 关键：通过内容匹配恢复旧ID到新ID的映射，并更新MetaStore
        // 因为思源操作后子任务ID可能改变，需要用内容匹配来找回旧ID
        const oldIdToNewId = new Map();
        const newIdToOldId = new Map();

        // 遍历旧的任务树（如果有的话），建立ID映射
        // 注意：oldDoc 已在前面声明，这里直接使用
        if (oldDoc && oldDoc.tasks) {
            const traverseOld = (tasks) => {
                tasks.forEach(t => {
                    if (t.content) {
                        // 在新任务树中找内容相同的任务
                        const newTask = findTaskByContent(rootTasks, t.content);
                        if (newTask && newTask.id !== t.id) {
                            oldIdToNewId.set(t.id, newTask.id);
                            newIdToOldId.set(newTask.id, t.id);

                            // 如果MetaStore中有旧ID的数据，复制到新ID
                            const oldMeta = MetaStore.get(t.id);
                            if (oldMeta) {
                                // 不覆盖新ID已有的数据
                                const newMeta = MetaStore.get(newTask.id) || {};
                                const mergedMeta = { ...oldMeta, ...newMeta };
                                MetaStore.set(newTask.id, mergedMeta);
                            }
                        }
                    }
                    if (t.children && t.children.length > 0) {
                        traverseOld(t.children);
                    }
                });
            };
            traverseOld(oldDoc.tasks);
        }

        TreeProtector.restoreTree(rootTasks);

        // 4. 恢复折叠状态
        TreeProtector.restoreCollapsedState();

        // 5. 更新状态
        const docIndex = state.taskTree.findIndex(d => d.id === docId);
        const docInfo = state.allDocuments.find(d => d.id === docId);

        const newDoc = {
            id: docId,
            name: docInfo?.name || (docIndex >= 0 ? state.taskTree[docIndex].name : '未知文档'),
            tasks: rootTasks
        };

        if (docIndex >= 0) {
            state.taskTree[docIndex] = newDoc;
        } else {
            state.taskTree.push(newDoc);
        }

        // 6. 更新flatTasks
        const flatten = (tasks) => {
            tasks.forEach(t => {
                state.flatTasks[t.id] = t;
                if (t.children && t.children.length > 0) flatten(t.children);
            });
        };

        // 清理旧数据
        Object.keys(state.flatTasks).forEach(key => {
            if (state.flatTasks[key].root_id === docId) delete state.flatTasks[key];
        });
        flatten(rootTasks);

        state.stats.queryTime = queryTime || 0;
        recalcStats();
        applyFilters();

        render();

        // 7. 保存恢复后的数据
        await MetaStore.saveNow();
    }

    window.tmPickPriority = function(id, el, ev) {
        try {
            ev?.stopPropagation?.();
            ev?.preventDefault?.();
        } catch (e) {}
        const task = state.flatTasks[id];
        if (!task) return;
        __tmOpenInlineEditor(el, ({ editor, close }) => {
            editor.style.minWidth = '120px';
            editor.style.padding = '8px';
            const wrap = document.createElement('div');
            wrap.style.display = 'flex';
            wrap.style.flexDirection = 'column';
            wrap.style.gap = '6px';
            const mk = (value, label, color) => {
                const b = document.createElement('button');
                b.className = 'tm-btn tm-btn-secondary';
                b.style.padding = '4px 8px';
                b.style.fontSize = '12px';
                b.style.textAlign = 'left';
                b.style.background = 'transparent';
                b.style.border = `1px solid ${color}55`;
                b.style.color = color;
                b.textContent = label;
                b.onclick = async () => {
                    try {
                        task.priority = value;
                        __tmPersistMetaAndAttrs(id, { priority: value || '' });
                        close();
                        applyFilters();
                        render();
                    } catch (e) {
                        hint(`❌ 更新失败: ${e.message}`, 'error');
                    }
                };
                return b;
            };
            wrap.appendChild(mk('', '无', '#9e9e9e'));
            wrap.appendChild(mk('high', '高', '#ea4335'));
            wrap.appendChild(mk('medium', '中', '#f9ab00'));
            wrap.appendChild(mk('low', '低', '#4285f4'));
            editor.appendChild(wrap);
        });
    };

    window.tmOpenStatusSelect = function(id, ev) {
        try {
            ev?.stopPropagation?.();
            ev?.preventDefault?.();
        } catch (e) {}
        const el = ev.target.closest('td');
        const task = state.flatTasks[id];
        if (!task || !el) return;

        __tmOpenInlineEditor(el, ({ editor, close }) => {
            const options = SettingsStore.data.customStatusOptions || [];
            const maxLen = options.reduce((m, o) => Math.max(m, String(o?.name || '').length), 0);
            const w = Math.min(260, Math.max(110, maxLen * 14 + 38));
            editor.style.minWidth = '0';
            editor.style.width = `${w}px`;
            editor.style.padding = '8px';
            const wrap = document.createElement('div');
            wrap.style.display = 'flex';
            wrap.style.flexDirection = 'column';
            wrap.style.gap = '4px';
            options.forEach(opt => {
                const b = document.createElement('button');
                b.className = 'tm-btn';
                b.style.padding = '4px 8px';
                b.style.fontSize = '12px';
                b.style.textAlign = 'left';
                b.style.backgroundColor = opt.color;
                b.style.color = '#fff';
                b.style.border = 'none';
                b.textContent = opt.name;
                b.onclick = async () => {
                    try {
                        task.customStatus = opt.id;
                        __tmPersistMetaAndAttrs(id, { customStatus: opt.id });
                        close();
                        applyFilters();
                        render();
                    } catch (e) {
                        hint(`❌ 更新失败: ${e.message}`, 'error');
                    }
                };
                wrap.appendChild(b);
            });
            
            editor.appendChild(wrap);
        });
    };

    window.tmKanbanOpenStatusSelect = function(id, el, ev) {
        try {
            ev?.stopPropagation?.();
            ev?.preventDefault?.();
        } catch (e) {}
        const task = state.flatTasks[id];
        if (!task || !(el instanceof Element)) return;

        __tmOpenInlineEditor(el, ({ editor, close }) => {
            const options = SettingsStore.data.customStatusOptions || [];
            const maxLen = options.reduce((m, o) => Math.max(m, String(o?.name || '').length), 0);
            const w = Math.min(260, Math.max(110, maxLen * 14 + 38));
            editor.style.minWidth = '0';
            editor.style.width = `${w}px`;
            editor.style.padding = '8px';
            const wrap = document.createElement('div');
            wrap.style.display = 'flex';
            wrap.style.flexDirection = 'column';
            wrap.style.gap = '4px';
            options.forEach(opt => {
                const b = document.createElement('button');
                b.className = 'tm-btn';
                b.style.padding = '4px 8px';
                b.style.fontSize = '12px';
                b.style.textAlign = 'left';
                b.style.backgroundColor = opt.color;
                b.style.color = '#fff';
                b.style.border = 'none';
                b.textContent = opt.name;
                b.onclick = async () => {
                    try {
                        task.customStatus = opt.id;
                        __tmPersistMetaAndAttrs(id, { customStatus: opt.id });
                        close();
                        applyFilters();
                        render();
                    } catch (e) {
                        hint(`❌ 更新失败: ${e.message}`, 'error');
                    }
                };
                wrap.appendChild(b);
            });
            editor.appendChild(wrap);
        });
    };

    window.tmOpenTaskDetail = function(id, ev) {
        try {
            ev?.stopPropagation?.();
            ev?.preventDefault?.();
        } catch (e) {}
        const task = state.flatTasks[String(id || '').trim()];
        if (!task) return;

        __tmRemoveElementsById('tm-task-detail-overlay');

        const overlay = document.createElement('div');
        overlay.id = 'tm-task-detail-overlay';
        overlay.className = 'tm-task-detail-overlay';

        const statusOptionsRaw = Array.isArray(SettingsStore.data.customStatusOptions) ? SettingsStore.data.customStatusOptions : [];
        const statusOptions = statusOptionsRaw
            .map(o => ({ id: String(o?.id || '').trim(), name: String(o?.name || '').trim() }))
            .filter(o => o.id);
        if (!statusOptions.some(o => o.id === 'todo')) statusOptions.unshift({ id: 'todo', name: '待办' });

        const curStatus = String(task.customStatus || '').trim() || 'todo';
        const curPriority = String(task.priority || '').toLowerCase();
        const curPinned = !!task.pinned;

        overlay.innerHTML = `
            <div class="tm-task-detail" role="dialog" aria-modal="true">
                <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px;">
                    <div style="font-size:16px;font-weight:800;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">任务详情</div>
                    <button class="tm-btn tm-btn-gray" data-tm-detail="close" style="padding:0 10px;height:30px;display:inline-flex;align-items:center;justify-content:center;">✖</button>
                </div>

                <div class="tm-task-detail-row">
                    <div class="tm-task-detail-label">内容</div>
                    <div class="tm-task-detail-value" style="display:flex;gap:8px;align-items:center;">
                        <div style="flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="${esc(task.content || '')}">${esc(task.content || '') || '(无内容)'}</div>
                        <button class="tm-btn tm-btn-info" data-tm-detail="editContent" style="padding:0 10px;height:30px;">编辑</button>
                    </div>
                </div>

                <div class="tm-task-detail-row">
                    <div class="tm-task-detail-label">状态</div>
                    <div class="tm-task-detail-value">
                        <select class="tm-rule-select" data-tm-detail="status">
                            ${statusOptions.map(o => `<option value="${esc(o.id)}" ${o.id === curStatus ? 'selected' : ''}>${esc(o.name)}</option>`).join('')}
                        </select>
                    </div>
                </div>

                <div class="tm-task-detail-row">
                    <div class="tm-task-detail-label">重要性</div>
                    <div class="tm-task-detail-value">
                        <select class="tm-rule-select" data-tm-detail="priority">
                            <option value="" ${!curPriority ? 'selected' : ''}>无</option>
                            <option value="high" ${curPriority === 'high' ? 'selected' : ''}>高</option>
                            <option value="medium" ${curPriority === 'medium' ? 'selected' : ''}>中</option>
                            <option value="low" ${curPriority === 'low' ? 'selected' : ''}>低</option>
                        </select>
                    </div>
                </div>

                <div class="tm-task-detail-row">
                    <div class="tm-task-detail-label">置顶</div>
                    <div class="tm-task-detail-value">
                        <label style="display:inline-flex;align-items:center;gap:8px;">
                            <input type="checkbox" data-tm-detail="pinned" ${curPinned ? 'checked' : ''}>
                            <span style="color:var(--tm-secondary-text);font-size:12px;">在列表/看板中置顶</span>
                        </label>
                    </div>
                </div>

                <div class="tm-task-detail-row">
                    <div class="tm-task-detail-label">开始日期</div>
                    <div class="tm-task-detail-value">
                        <input class="tm-input" type="date" data-tm-detail="startDate" value="${esc(String(task.startDate || '').trim().slice(0, 10))}">
                    </div>
                </div>

                <div class="tm-task-detail-row">
                    <div class="tm-task-detail-label">完成日期</div>
                    <div class="tm-task-detail-value">
                        <input class="tm-input" type="date" data-tm-detail="completionTime" value="${esc(String(task.completionTime || '').trim().slice(0, 10))}">
                    </div>
                </div>

                <div class="tm-task-detail-row">
                    <div class="tm-task-detail-label">时长</div>
                    <div class="tm-task-detail-value">
                        <input class="tm-input" data-tm-detail="duration" placeholder="如 1h / 30min" value="${esc(task.duration || '')}">
                    </div>
                </div>

                <div class="tm-task-detail-row">
                    <div class="tm-task-detail-label">备注</div>
                    <div class="tm-task-detail-value">
                        <input class="tm-input" data-tm-detail="remark" value="${esc(task.remark || '')}">
                    </div>
                </div>

                <div class="tm-task-detail-actions">
                    <button class="tm-btn tm-btn-secondary" data-tm-detail="cancel" style="padding:0 12px;height:32px;">取消</button>
                    <button class="tm-btn tm-btn-primary" data-tm-detail="save" style="padding:0 12px;height:32px;">保存</button>
                </div>
            </div>
        `;

        const close = () => { try { overlay.remove(); } catch (e) {} };
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) close();
        });
        overlay.querySelector('[data-tm-detail="close"]')?.addEventListener('click', close);
        overlay.querySelector('[data-tm-detail="cancel"]')?.addEventListener('click', close);
        overlay.querySelector('[data-tm-detail="editContent"]')?.addEventListener('click', () => {
            close();
            tmEdit(id);
        });
        try {
            const dateInputs = overlay.querySelectorAll('input[type="date"][data-tm-detail]');
            dateInputs.forEach(inp => {
                inp.addEventListener('click', () => { try { inp.showPicker?.(); } catch (e) {} });
            });
        } catch (e) {}
        overlay.querySelector('[data-tm-detail="save"]')?.addEventListener('click', async () => {
            const normalize = (s) => {
                const v = String(s || '').trim();
                if (!v) return '';
                try { if (typeof __tmNormalizeDateOnly === 'function') return __tmNormalizeDateOnly(v); } catch (e) {}
                return v;
            };
            const nextStatus = String(overlay.querySelector('[data-tm-detail="status"]')?.value || '').trim() || 'todo';
            const nextPriority = String(overlay.querySelector('[data-tm-detail="priority"]')?.value || '').trim();
            const nextPinned = !!overlay.querySelector('[data-tm-detail="pinned"]')?.checked;
            const nextStart = normalize(overlay.querySelector('[data-tm-detail="startDate"]')?.value);
            const nextEnd = normalize(overlay.querySelector('[data-tm-detail="completionTime"]')?.value);
            const nextDuration = String(overlay.querySelector('[data-tm-detail="duration"]')?.value || '').trim();
            const nextRemark = String(overlay.querySelector('[data-tm-detail="remark"]')?.value || '').trim();

            const patch = {
                customStatus: nextStatus,
                priority: nextPriority,
                pinned: nextPinned ? '1' : '',
                startDate: nextStart,
                completionTime: nextEnd,
                duration: nextDuration,
                remark: nextRemark
            };

            try {
                task.customStatus = nextStatus;
                task.priority = nextPriority;
                task.pinned = nextPinned;
                task.startDate = nextStart;
                task.completionTime = nextEnd;
                task.duration = nextDuration;
                task.remark = nextRemark;
                await __tmPersistMetaAndAttrsAsync(String(id || '').trim(), patch);
                close();
                applyFilters();
                render();
                hint('✅ 已保存', 'success');
            } catch (e) {
                hint(`❌ 保存失败: ${e.message}`, 'error');
            }
        });

        document.body.appendChild(overlay);
    };

    // 辅助：手动插入任务到树中（支持位置控制）
    // position: 'before' | 'after' | 'child'
    // Removed manualInsertTaskToTree

    // Removed pollTaskInfo

    // Removed tmInsertSiblingAbove

    // Removed tmInsertSiblingBelow

    // Removed tmInsertChildTask

    // 编辑任务
    window.tmEdit = async function(id) {
        const task = state.flatTasks[id];
        if (!task) return;

        const newContent = await showPrompt('编辑任务', '请输入新任务内容', task.content);
        if (newContent === null || newContent === task.content) return;

        const prefix = task.markdown.match(/^(\s*[\*\-]\s*\[x?\])\s*/i)?.[1] || '- ';
        const newMarkdown = prefix + newContent;

        try {
            await API.updateBlock(id, newMarkdown);
            task.content = newContent;
            task.markdown = newMarkdown;
            applyFilters();
            render();
            hint('✅ 任务已更新', 'success');
        } catch (e) {
            hint(`❌ 更新失败: ${e.message}`, 'error');
        }
    };

    // 删除任务
    window.tmDelete = async function(id) {
        if (!confirm('确定要删除这个任务吗？此操作不可恢复。')) return;

        try {
            await API.deleteBlock(id);

            // 从本地数据中移除
            delete state.flatTasks[id];
            
            // 递归移除任务树中的任务
            const removeRecursive = (list) => {
                const idx = list.findIndex(t => t.id === id);
                if (idx !== -1) {
                    list.splice(idx, 1);
                    return true;
                }
                for (const t of list) {
                    if (t.children && removeRecursive(t.children)) return true;
                }
                return false;
            };

            state.taskTree.forEach(doc => {
                removeRecursive(doc.tasks);
            });

            recalcStats();
            applyFilters();
            render();
            hint('✅ 任务已删除', 'success');
        } catch (e) {
            hint(`❌ 删除失败: ${e.message}`, 'error');
        }
    };

    // 任务提醒
    window.tmReminder = async function(id) {
        if (!SettingsStore.data.enableTomatoIntegration) {
            hint('⚠ 番茄钟联动已关闭', 'warning');
            return;
        }
        const task = state.flatTasks[id];
        if (!task) return;
        const showDialog = globalThis.__tomatoReminder?.showDialog;
        if (typeof showDialog === 'function') {
            showDialog(id, task.content || '任务');
            return;
        }
        hint('⚠ 未检测到提醒功能，请确认番茄插件已启用', 'warning');
    };

    window.tmStartPomodoro = async function(id) {
        if (!SettingsStore.data.enableTomatoIntegration) {
            hint('⚠ 番茄钟联动已关闭', 'warning');
            return;
        }
        const task = state.flatTasks[id];
        if (!task) return;
        const timer = globalThis.__tomatoTimer;
        const startCountdown = timer?.startCountdown;
        const startPomodoro = timer?.startPomodoro;
        if (typeof startCountdown === 'function') {
            startCountdown(id, task.content || '任务', 30);
            return;
        }
        if (typeof startPomodoro === 'function') {
            startPomodoro(id, task.content || '任务', 30);
            return;
        }
        hint('⚠ 未检测到番茄计时功能，请确认番茄插件已启用', 'warning');
    };

    // 任务右键菜单
    window.tmShowTaskContextMenu = function(event, taskId) {
        event.preventDefault();
        event.stopPropagation();

        // Close any existing context menu
        const existingMenu = document.getElementById('tm-task-context-menu');
        if (existingMenu) existingMenu.remove();
        if (state.taskContextMenuCloseHandler) {
            try { document.removeEventListener('click', state.taskContextMenuCloseHandler); } catch (e) {}
            try { document.removeEventListener('contextmenu', state.taskContextMenuCloseHandler); } catch (e) {}
            state.taskContextMenuCloseHandler = null;
        }

        const menu = document.createElement('div');
        menu.id = 'tm-task-context-menu';
        menu.style.cssText = `
            position: fixed;
            top: ${event.clientY}px;
            left: ${event.clientX}px;
            background: var(--b3-theme-background);
            border: 1px solid var(--b3-theme-surface-light);
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            padding: 4px 0;
            z-index: 200000;
            min-width: 140px;
            user-select: none;
        `;

        const createItem = (label, onClick, isDanger) => {
            const item = document.createElement('div');
            item.textContent = label;
            item.style.cssText = `
                padding: 6px 12px;
                cursor: pointer;
                font-size: 13px;
                color: ${isDanger ? 'var(--b3-theme-error)' : 'var(--b3-theme-on-background)'};
                display: flex;
                align-items: center;
                gap: 8px;
            `;
            item.onmouseenter = () => item.style.backgroundColor = 'var(--b3-theme-surface-light)';
            item.onmouseleave = () => item.style.backgroundColor = 'transparent';
            item.onclick = (e) => {
                e.stopPropagation();
                menu.remove();
                onClick();
            };
            return item;
        };

        const task = state.flatTasks[taskId];
        const taskName = task?.content || '任务';
        const tomatoEnabled = !!SettingsStore.data.enableTomatoIntegration;
        const timer = tomatoEnabled ? globalThis.__tomatoTimer : null;
        if (tomatoEnabled && timer && typeof timer === 'object') {
            const durations = (() => {
                const list = timer?.getDurations?.();
                const arr = Array.isArray(list) ? list.map(n => parseInt(n, 10)).filter(n => Number.isFinite(n) && n > 0) : [];
                return arr.length > 0 ? arr.slice(0, 8) : [5, 15, 25, 30, 45, 60];
            })();

            const timerWrap = document.createElement('div');
            timerWrap.style.cssText = 'padding: 6px 10px 8px;';
            const title = document.createElement('div');
            title.textContent = '🍅 计时';
            title.style.cssText = 'font-size: 12px; opacity: 0.75; padding: 2px 0 6px;';
            timerWrap.appendChild(title);
            const btnRow = document.createElement('div');
            btnRow.style.cssText = 'display:flex;flex-wrap:wrap;gap:6px;';
            durations.forEach(min => {
                const b = document.createElement('button');
                b.className = 'tm-btn tm-btn-secondary';
                b.textContent = `${min}m`;
                b.style.cssText = 'padding: 2px 8px; font-size: 12px; line-height: 18px;';
                b.onclick = (e) => {
                    e.stopPropagation();
                    state.timerFocusTaskId = taskId;
                    render();
                    const startFromTaskBlock = timer?.startFromTaskBlock;
                    const startCountdown = timer?.startCountdown;
                    const p = (typeof startFromTaskBlock === 'function')
                        ? startFromTaskBlock(taskId, taskName, min, 'countdown')
                        : (typeof startCountdown === 'function' ? startCountdown(taskId, taskName, min) : null);
                    if (p && typeof p.finally === 'function') {
                        p.finally(() => setTimeout(() => { try { timer?.refreshUI?.(); } catch (e) {} }, 150));
                    }
                    else tmStartPomodoro(taskId);
                    menu.remove();
                };
                btnRow.appendChild(b);
            });
            const sw = document.createElement('button');
            sw.className = 'tm-btn tm-btn-secondary';
            sw.textContent = '⏱️ 正计时';
            sw.style.cssText = 'padding: 2px 8px; font-size: 12px; line-height: 18px;';
            sw.onclick = (e) => {
                e.stopPropagation();
                state.timerFocusTaskId = taskId;
                render();
                const startFromTaskBlock = timer?.startFromTaskBlock;
                const startStopwatch = timer?.startStopwatch;
                const p = (typeof startFromTaskBlock === 'function')
                    ? startFromTaskBlock(taskId, taskName, 0, 'stopwatch')
                    : (typeof startStopwatch === 'function' ? startStopwatch(taskId, taskName) : null);
                if (p && typeof p.finally === 'function') {
                    p.finally(() => setTimeout(() => { try { timer?.refreshUI?.(); } catch (e) {} }, 150));
                }
                else hint('⚠ 未检测到正计时功能，请确认番茄插件已启用', 'warning');
                menu.remove();
            };
            btnRow.appendChild(sw);
            timerWrap.appendChild(btnRow);
            menu.appendChild(timerWrap);

            const hrTimer = document.createElement('hr');
            hrTimer.style.cssText = 'margin: 4px 0; border: none; border-top: 1px solid var(--b3-theme-surface-light);';
            menu.appendChild(hrTimer);

            if (state.timerFocusTaskId) {
                menu.appendChild(createItem('👁️ 取消聚焦', () => {
                    state.timerFocusTaskId = '';
                    render();
                }));
            }
        }

        menu.appendChild(createItem('✏️ 编辑', () => tmEdit(taskId)));
        if (tomatoEnabled) {
            menu.appendChild(createItem('⏰ 提醒', () => tmReminder(taskId)));
        }
        menu.appendChild(createItem('🗑️ 删除', () => tmDelete(taskId), true));

        document.body.appendChild(menu);

        // Click outside to close
        const closeHandler = () => {
            menu.remove();
            try { document.removeEventListener('click', closeHandler); } catch (e) {}
            try { document.removeEventListener('contextmenu', closeHandler); } catch (e) {}
            if (state.taskContextMenuCloseHandler === closeHandler) state.taskContextMenuCloseHandler = null;
        };
        state.taskContextMenuCloseHandler = closeHandler;
        setTimeout(() => {
            document.addEventListener('click', closeHandler);
            document.addEventListener('contextmenu', closeHandler);
        }, 0);
    };

    function __tmResolveDefaultDocId() {
        if (state.activeDocId && state.activeDocId !== 'all') return state.activeDocId;
        if (state.taskTree && state.taskTree.length > 0) return state.taskTree[0].id;
        if (state.selectedDocIds && state.selectedDocIds.length > 0) return state.selectedDocIds[0];
        return null;
    }

    function __tmResolveQuickAddDocId() {
        const configured = String(SettingsStore.data.newTaskDocId || '').trim();
        if (configured) {
            const exists = state.taskTree.some(d => d.id === configured) || state.allDocuments.some(d => d.id === configured);
            if (exists) return configured;
        }
        return __tmResolveDefaultDocId();
    }

    async function __tmCreateTaskInDoc({ docId, content, priority, completionTime, pinned, customStatus, atTop } = {}) {
        const parentDocId = String(docId || '').trim();
        const text = String(content || '').trim();
        if (!parentDocId) throw new Error('未设置文档');
        if (!text) throw new Error('请输入任务内容');
        const md = '- [ ] ' + text;

        let nextID = '';
        if (atTop) {
            try { nextID = String(await API.getFirstDirectChildIdOfDoc(parentDocId) || '').trim(); } catch (e) { nextID = ''; }
        }
        const insertedId = await API.insertBlock(parentDocId, md, nextID || undefined);
        let taskId = insertedId;
        try {
            const rows = await API.getBlocksByIds([insertedId]);
            const row = Array.isArray(rows) && rows.length > 0 ? rows[0] : null;
            const t = String(row?.type || '').trim();
            const st = String(row?.subtype || '').trim();
            if (!(t === 'i' && st === 't')) {
                // 尝试多次获取子任务ID，应对索引延迟
                // 优化：使用短间隔高频重试，减少用户等待时间
                let childTaskId = null;
                for (let i = 0; i < 30; i++) {
                    childTaskId = await API.getFirstTaskIdUnderBlock(insertedId);
                    if (childTaskId) break;
                    await new Promise(r => setTimeout(r, 50));
                }

                if (childTaskId) taskId = childTaskId;
                else {
                    const deepTaskId = await API.getFirstTaskDescendantId(insertedId, 8);
                    if (deepTaskId) taskId = deepTaskId;
                }
            }
        } catch (e) {}

        const patch = {};
        const pin = pinned !== undefined ? !!pinned : !!SettingsStore.data.pinNewTasksByDefault;
        if (pin) patch.pinned = true;
        const pr0 = String(priority ?? '').trim();
        const prMap = {
            '高': 'high',
            '中': 'medium',
            '低': 'low',
            '无': '',
            'none': '',
        };
        const pr = prMap.hasOwnProperty(pr0) ? prMap[pr0] : pr0;
        if (pr === 'high' || pr === 'medium' || pr === 'low') patch.priority = pr;
        const ct = String(completionTime || '').trim();
        if (ct) patch.completionTime = ct;
        const st0 = String(customStatus || '').trim();
        if (st0) {
            const options = SettingsStore.data.customStatusOptions || [];
            const ok = options.some(o => String(o?.id || '').trim() === st0);
            if (ok) patch.customStatus = st0;
        }
        if (Object.keys(patch).length > 0) {
            // 异步保存属性，不阻塞UI，只要Meta写入成功即可先返回
            __tmPersistMetaAndAttrsAsync(taskId, patch).catch(e => {
                hint('⚠ 属性同步失败，但已保存到本地数据', 'warning');
            });
        }

        const docName = state.allDocuments.find(d => d.id === parentDocId)?.name || '未知文档';
        const newTask = {
            id: taskId,
            done: false,
            pinned: !!pin,
            content: text,
            markdown: md,
            priority: patch.priority || '',
            duration: '',
            remark: '',
            completionTime: patch.completionTime || '',
            customTime: '',
            customStatus: patch.customStatus || '',
            docName,
            root_id: parentDocId,
            docId: parentDocId,
            created: new Date().toISOString(),
            updated: new Date().toISOString(),
            children: [],
            level: 0,
        };
        try { normalizeTaskFields(newTask, docName); } catch (e) {}

        state.flatTasks[taskId] = newTask;
        const doc = state.taskTree.find(d => d.id === parentDocId);
        if (doc) {
            doc.tasks.push(newTask);
        }
        try { recalcStats(); } catch (e) {}
        try { applyFilters(); } catch (e) {}
        if (state.modal) render();
        return taskId;
    }

    // 注册全局刷新回调，供悬浮条调用
    globalThis.__taskHorizonRefresh = () => {
        try {
            if (!state.modal || !document.body.contains(state.modal)) return;
            // 重新加载当前文档或选中文档的任务数据（如果需要完全同步）
            // 但为了性能，这里先尝试只重新应用过滤器和渲染
            // 如果数据源是实时更新的（例如引用了同一个对象），这应该够了
            // 如果需要从 block 重新读取，可能需要更重的刷新
            // 考虑到悬浮条修改的是属性，而插件读取的是内存中的 state 或 block 属性
            // 我们可能需要触发一次轻量级的重载，或者直接调用 tmRefresh
            // 这里先试用 applyFilters + render，如果不行再调用 tmRefresh
            applyFilters();
            render();
        } catch (e) {
        }
    };

    window.tmQuickAddClose = function() {
        if (state.quickAddModal) {
            try { state.quickAddModal.remove(); } catch (e) {}
            state.quickAddModal = null;
        }
        if (state.quickAddDocPicker) {
            try { state.quickAddDocPicker.remove(); } catch (e) {}
            state.quickAddDocPicker = null;
        }
        state.quickAdd = null;
    };

    window.tmQuickAddOpen = function() {
        if (state.quickAddModal) {
            try { state.quickAddModal.remove(); } catch (e) {}
            state.quickAddModal = null;
        }
        if (state.quickAddDocPicker) {
            try { state.quickAddDocPicker.remove(); } catch (e) {}
            state.quickAddDocPicker = null;
        }

        const docId = __tmResolveQuickAddDocId();
        if (!docId) {
            hint('⚠ 请先在设置中选择文档', 'warning');
            showSettings();
            return;
        }

        const configuredNewTaskDoc = String(SettingsStore.data.newTaskDocId || '').trim();
        const initialMode = configuredNewTaskDoc === '__dailyNote__' ? 'dailyNote' : 'doc';
        const initialDocId = configuredNewTaskDoc === '__dailyNote__' ? __tmResolveDefaultDocId() : docId;

        const stOptions = SettingsStore.data.customStatusOptions || [];
        const defaultStatusId = String((stOptions[0] && stOptions[0].id) || 'todo').trim() || 'todo';
        state.quickAdd = {
            docId: initialDocId,
            docMode: initialMode,
            customStatus: defaultStatusId,
            priority: 'none',
            completionTime: '',
        };

        const modal = document.createElement('div');
        modal.className = 'tm-prompt-modal';
        modal.style.zIndex = '100010';
        
        // 优先级配置
        const prConfig = {
            'high': { label: '高', color: '#ea4335', bg: 'rgba(234, 67, 53, 0.1)' },
            'medium': { label: '中', color: '#f9ab00', bg: 'rgba(249, 171, 0, 0.1)' },
            'low': { label: '低', color: '#4285f4', bg: 'rgba(66, 133, 244, 0.1)' },
            'none': { label: '无', color: 'var(--tm-text-color)', bg: 'transparent' }
        };

        modal.innerHTML = `
            <div class="tm-prompt-box" style="width: min(92vw, 520px);">
                <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
                    <div class="tm-prompt-title" style="margin:0;">添加待办</div>
                    <button class="tm-btn tm-btn-primary" onclick="tmQuickAddSubmit()" style="padding: 6px 14px; font-size: 13px;">提交</button>
                </div>
                
                <input type="text" id="tmQuickAddInput" class="tm-prompt-input" placeholder="输入事项…" style="margin-top:16px; font-size: 16px; padding: 12px;">
                
                <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:16px;">
                    <button class="tm-btn tm-btn-secondary" onclick="tmQuickAddOpenDocPicker()" style="padding: 6px 12px; font-size: 13px; display:flex; align-items:center; gap:4px;">
                        📁 <span id="tmQuickAddDocName">文档</span>
                    </button>
                    
                    <button id="tmQuickAddPriorityBtn" class="tm-btn tm-btn-secondary" onclick="tmQuickAddCyclePriority()" style="padding: 6px 12px; font-size: 13px; display:flex; align-items:center; gap:4px;">
                        ⭐ 重要性: 无
                    </button>

                    <div style="display:flex;align-items:center;gap:6px;">
                        <span style="font-size:13px;">🏷</span>
                        <select id="tmQuickAddStatusSelect" onchange="tmQuickAddStatusChanged(this.value)" class="tm-btn tm-btn-secondary" style="padding: 6px 10px; font-size: 13px; height: 32px;">
                        </select>
                    </div>
                    
                    <div style="position:relative; display:inline-block;">
                        <!-- 桌面端/移动端通用的日期选择器 -->
                        <div style="position:relative; display:inline-block;">
                            <button class="tm-btn tm-btn-secondary" onclick="document.getElementById('tmQuickAddDateInput').showPicker ? document.getElementById('tmQuickAddDateInput').showPicker() : document.getElementById('tmQuickAddDateInput').click()" style="padding: 6px 12px; font-size: 13px; display:flex; align-items:center; gap:4px;">
                                🗓 <span id="tmQuickAddDateLabel">完成日期</span>
                            </button>
                            <input type="date" id="tmQuickAddDateInput" onchange="tmQuickAddDateChanged(this.value)" 
                                   style="position:fixed; opacity:0; width:1px; height:1px; left:0; top:0; pointer-events:none;">
                        </div>
                    </div>

                    <div style="flex:1;"></div>
                    <button class="tm-btn tm-btn-gray" id="tmQuickAddCloseBtn" onclick="tmQuickAddClose()" style="padding: 6px 12px; font-size: 13px;">关闭</button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        state.quickAddModal = modal;
        
        // 自动聚焦 (兼容移动端)
        const input = document.getElementById('tmQuickAddInput');
        if (input) {
            setTimeout(() => {
                input.focus();
                // 移动端尝试触发软键盘
                try { input.click(); } catch(e) {}
            }, 300);
        }

        window.tmQuickAddRenderMeta?.();
    };

    // 绑定全局点击事件，用于处理日期选择和关闭按钮（防止事件未被正确绑定）
    if (!window.tmQuickAddEventsBound) {
        window.tmQuickAddEventsBound = true;
        __tmQuickAddGlobalClickHandler = (e) => {
            const target = e.target;
            if (target.id === 'tmQuickAddCloseBtn' || (target.matches('.tm-btn-gray') && target.textContent.trim() === '关闭')) {
                if (state.quickAddModal) {
                    tmQuickAddClose();
                }
            }
        };
        document.addEventListener('click', __tmQuickAddGlobalClickHandler);
    }

    window.tmQuickAddRenderMeta = function() {
        try {
            const qa = state.quickAdd || {};
            
            // 更新文档按钮文字
            const docName = qa.docMode === 'dailyNote'
                ? '今天日记'
                : (state.allDocuments.find(d => d.id === qa.docId)?.name || '未知文档');
            const docBtn = document.getElementById('tmQuickAddDocName');
            if (docBtn) docBtn.textContent = docName;

            // 更新优先级按钮样式
            const prBtn = document.getElementById('tmQuickAddPriorityBtn');
            if (prBtn) {
                const prMap = {
                    'high': { label: '高', color: '#ea4335', icon: '🔴' },
                    'medium': { label: '中', color: '#f9ab00', icon: '🟠' },
                    'low': { label: '低', color: '#4285f4', icon: '🔵' },
                    'none': { label: '无', color: 'var(--tm-text-color)', icon: '⚪' }
                };
                const pr = qa.priority || 'none';
                const conf = prMap[pr] || prMap.none;
                
                prBtn.innerHTML = `${conf.icon} 重要性: <span style="font-weight:bold;">${conf.label}</span>`;
                prBtn.style.color = conf.color === 'var(--tm-text-color)' ? '' : conf.color;
                prBtn.style.borderColor = conf.color === 'var(--tm-text-color)' ? '' : conf.color;
                // prBtn.style.background = conf.bg; // 背景色可能太花，暂只改文字和边框颜色
            }

            const stSel = document.getElementById('tmQuickAddStatusSelect');
            if (stSel) {
                window.tmQuickAddRefreshStatusSelect?.();
                const options = SettingsStore.data.customStatusOptions || [];
                const id = String(qa.customStatus || '').trim() || 'todo';
                const opt = options.find(o => o && o.id === id) || options[0] || { id: 'todo', name: '待办', color: 'var(--tm-text-color)' };
                const c = String(opt.color || '').trim();
                stSel.style.color = c && c !== '#757575' ? c : '';
                stSel.style.borderColor = c && c !== '#757575' ? c : '';
            }

            // 更新日期显示
            const dateLabel = document.getElementById('tmQuickAddDateLabel');
            const dateInput = document.getElementById('tmQuickAddDateInput');
            if (dateLabel && dateInput) {
                const ct = qa.completionTime ? __tmFormatTaskTime(qa.completionTime) : '完成日期';
                dateLabel.textContent = ct;
                dateInput.value = qa.completionTime ? __tmNormalizeDateOnly(qa.completionTime) : '';
                
                if (qa.completionTime) {
                    const btn = document.getElementById('tmQuickAddDateLabel')?.parentElement;
                    if (btn) {
                        btn.style.color = 'var(--tm-primary-color)';
                        btn.style.borderColor = 'var(--tm-primary-color)';
                    }
                }
            }
        } catch (e) {}
    };

    window.tmQuickAddStatusChanged = function(value) {
        const qa = state.quickAdd;
        if (!qa) return;
        qa.customStatus = String(value || '').trim();
        window.tmQuickAddRenderMeta?.();
    };

    window.tmQuickAddRefreshStatusSelect = function() {
        const sel = document.getElementById('tmQuickAddStatusSelect');
        if (!sel) return;
        const options = SettingsStore.data.customStatusOptions || [];
        if (!Array.isArray(options) || options.length === 0) {
            sel.innerHTML = '';
            sel.disabled = true;
            return;
        }
        sel.disabled = false;
        const qa = state.quickAdd;
        let current = String(qa?.customStatus || '').trim();
        if (!options.some(o => String(o?.id || '').trim() === current)) {
            current = String(options[0]?.id || 'todo').trim() || 'todo';
            if (qa) qa.customStatus = current;
        }
        sel.innerHTML = options.map(o => {
            const id = String(o?.id || '').trim();
            const name = String(o?.name || id).trim() || id;
            if (!id) return '';
            return `<option value="${esc(id)}" ${id === current ? 'selected' : ''}>${esc(name)}</option>`;
        }).join('');
        try { sel.value = current; } catch (e) {}
    };

    window.tmQuickAddDateChanged = function(val) {
        const qa = state.quickAdd;
        if (!qa) return;
        qa.completionTime = String(val || '').trim();
        window.tmQuickAddRenderMeta?.();
    };
    // 确保该函数在全局可见
    window.tmQuickAddDateChanged = window.tmQuickAddDateChanged;

    window.tmQuickAddCyclePriority = function() {
        const qa = state.quickAdd;
        if (!qa) return;
        const order = ['none', 'low', 'medium', 'high'];
        const idx = Math.max(0, order.indexOf(String(qa.priority || 'none')));
        qa.priority = order[(idx + 1) % order.length];
        window.tmQuickAddRenderMeta?.();
    };

    window.tmQuickAddPickCompletion = async function() {
        const qa = state.quickAdd;
        if (!qa) return;
        const v = await showPrompt('完成日期', '输入日期，如 2026-02-07（留空清除）', String(qa.completionTime || ''));
        if (v === null) return;
        qa.completionTime = String(v || '').trim();
        window.tmQuickAddRenderMeta?.();
    };

    window.tmQuickAddOpenDocPicker = async function() {
        const qa = state.quickAdd;
        if (!qa) return;
        if (state.quickAddDocPicker) {
            try { state.quickAddDocPicker.remove(); } catch (e) {}
            state.quickAddDocPicker = null;
        }
        const groups = SettingsStore.data.docGroups || [];
        // 移除未分组逻辑
        
        const resolveDocName = (docId) => {
            if (!docId) return '未知文档';
            const found = state.allDocuments.find(d => d.id === docId);
            if (found) return found.name || '未命名文档';
            const entry = state.taskTree.find(d => d.id === docId);
            return entry?.name || '未命名文档';
        };
        const defaultDocId = __tmResolveDefaultDocId();
        const defaultDocName = defaultDocId ? resolveDocName(defaultDocId) : '未设置';

        const picker = document.createElement('div');
        picker.className = 'tm-prompt-modal';
        picker.style.zIndex = '100011';
        picker.innerHTML = `
            <div class="tm-prompt-box" style="width:min(92vw,520px);max-height:70vh;overflow:auto;">
                <div class="tm-prompt-title" style="margin:0 0 10px 0;">选择文档</div>
                <div style="border:1px solid var(--tm-border-color);border-radius:8px;margin-bottom:8px;overflow:hidden;">
                    <div style="padding:8px 10px;background:var(--tm-header-bg);font-weight:600;">快捷</div>
                    <div style="padding:6px 10px;">
                        <div style="display:flex;align-items:center;justify-content:space-between;padding:8px 0;cursor:pointer;" onclick="tmQuickAddUseTodayDiary();tmQuickAddCloseDocPicker();">
                            <div style="min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">今天日记</div>
                            <div style="margin-left:10px;">${qa.docMode === 'dailyNote' ? '✅' : '◻️'}</div>
                        </div>
                        <div style="display:flex;align-items:center;justify-content:space-between;padding:8px 0;cursor:${defaultDocId ? 'pointer' : 'not-allowed'};opacity:${defaultDocId ? 1 : 0.6};" onclick="${defaultDocId ? `tmQuickAddUseDefaultDoc();tmQuickAddCloseDocPicker();` : ''}">
                            <div style="min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">默认任务文档：${esc(defaultDocName)}</div>
                            <div style="margin-left:10px;">${qa.docMode !== 'dailyNote' && qa.docId === defaultDocId ? '✅' : '◻️'}</div>
                        </div>
                    </div>
                </div>
                <div id="tmQuickAddDocList"></div>
                <div style="display:flex;gap:8px;margin-top:10px;">
                    <button class="tm-btn tm-btn-gray" onclick="tmQuickAddCloseDocPicker()" style="padding: 6px 10px; font-size: 12px;">关闭</button>
                </div>
            </div>
        `;
        document.body.appendChild(picker);
        state.quickAddDocPicker = picker;

        const listEl = picker.querySelector('#tmQuickAddDocList');
        const renderGroup = (label, docs, groupKey, initialOpen = false) => {
            const wrap = document.createElement('div');
            wrap.style.cssText = 'border:1px solid var(--tm-border-color);border-radius:8px;margin-bottom:8px;overflow:hidden;';
            const head = document.createElement('div');
            head.style.cssText = 'display:flex;align-items:center;justify-content:space-between;padding:8px 10px;background:var(--tm-header-bg);cursor:pointer;';
            head.innerHTML = `<div style="font-weight:600;">${esc(label)}</div><div style="opacity:0.75;">${initialOpen ? '▾' : '▸'}</div>`;
            const body = document.createElement('div');
            body.style.cssText = `padding:6px 10px;display:${initialOpen ? 'block' : 'none'};`;
            
            // 渲染文档列表的辅助函数
            const renderDocs = (docList) => {
                body.innerHTML = '';
                if (docList.length === 0) {
                    body.innerHTML = '<div style="color:var(--tm-secondary-text);padding:8px 0;font-size:13px;">暂无文档</div>';
                    return;
                }
                docList.forEach(d => {
                    const id = String(d?.id || d || '').trim();
                    if (!id) return;
                    const row = document.createElement('div');
                    const checked = id === qa.docId;
                    row.style.cssText = 'display:flex;align-items:center;justify-content:space-between;padding:8px 0;cursor:pointer;';
                    row.innerHTML = `<div style="min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${esc(resolveDocName(id))}</div><div style="margin-left:10px;">${checked ? '✅' : '◻️'}</div>`;
                    row.onclick = () => window.tmQuickAddSelectDoc?.(id);
                    body.appendChild(row);
                });
            };

            // 初始状态下不渲染文档列表，或者渲染配置的文档（视需求而定）
            // 用户要求：点击后展示全部以查询到有任务的文档名，而不只是设置中的文档
            // 所以初始状态可以是空的或者只显示配置文档，展开时再动态加载
            if (initialOpen) {
                renderDocs(docs); // 初始展开时先显示配置的
            }

            // 点击分组标题展开/折叠
            head.onclick = async () => {
                const open = body.style.display !== 'none';
                if (!open) {
                    // 展开时
                    body.style.display = 'block';
                    head.lastElementChild.textContent = '▾';
                    
                    // 动态查询该分组下所有包含任务的文档
                    if (groupKey) {
                        // 显示加载中状态
                        body.innerHTML = '<div style="color:var(--tm-secondary-text);padding:8px 0;font-size:13px;">🔄 加载文档中...</div>';
                        try {
                            // 使用 SQL 查询：假设 docGroups 配置的是根文档或目录
                            // 但 docGroups 配置的是文档列表。
                            // 如果用户意图是：通过 SQL 查询该分组下（假设分组 ID 是目录 ID？）的文档
                            // 但 docGroups 的 ID 是随机生成的 UUID，不对应真实目录。
                            // 唯一关联真实目录的是 g.docs 里的文档 ID。
                            
                            // 另一种理解：用户希望在点击分组时，列出当前 state.taskTree 中加载的所有属于该分组的文档
                            // 即使它们不在 SettingsStore 的 g.docs 配置里（可能是递归加载进来的）
                            
                            // 1. 获取该分组配置的所有根文档 ID
                            const rootDocIds = new Set(docs.map(d => String(d?.id || d || '')));
                            
                            // 2. 遍历 state.taskTree，找到所有属于这些根文档（或其子文档）的文档
                            // state.taskTree 是扁平的文档列表（包含递归加载的子文档）
                            // 我们需要一种方法判断 taskTree 中的文档是否属于当前分组
                            // 这里的逻辑假设：如果 taskTree 中的文档是 g.docs 中某个文档的子孙，则属于该分组。
                            // 但 taskTree 结构中没有直接保留层级关系，只有 doc.id
                            // 幸好 resolveDocIdsFromGroups 会解析递归，加载到 taskTree
                            
                            // 所以，我们可以认为 state.taskTree 中目前加载的所有文档，
                            // 如果它是 g.docs 中某个文档的后代（或者就是它自己），那么它就属于该分组。
                            // 但我们如何判断“后代”关系？API.getSubDocIds 是异步的。
                            // state.allDocuments 包含了所有文档路径信息（如果有 path 字段）
                            // 但 state.allDocuments 只包含 ID 和 Name。
                            
                            // 简便方案：既然 resolveDocIdsFromGroups 已经处理了递归逻辑并将结果存入 state.taskTree
                            // 我们可以尝试重新运行一次 resolveDocIdsFromGroups 的逻辑（针对特定分组），
                            // 获取该分组应该包含的所有文档 ID（包括递归的）。
                            
                            // 获取该分组的所有目标文档（含递归标记）
                            const targetDocs = docs; 
                            const finalIds = new Set();
                            
                            const promises = targetDocs.map(async (doc) => {
                                const id = String(doc?.id || doc || '');
                                if (!id) return;
                                finalIds.add(id);
                                if (doc.recursive) {
                                    try {
                                        const subIds = await API.getSubDocIds(id);
                                        subIds.forEach(sid => finalIds.add(sid));
                                    } catch(e) {}
                                }
                            });
                            await Promise.all(promises);
                            
                            // 动态查询文档的任务状态（即使不在 taskTree 中）
                            const allIds = Array.from(finalIds);
                            // 1. 先从 taskTree 中检查
                            const tasksMap = new Map();
                            allIds.forEach(id => {
                                const treeDoc = state.taskTree.find(d => d.id === id);
                                if (treeDoc && treeDoc.tasks && treeDoc.tasks.length > 0) {
                                    tasksMap.set(id, true);
                                }
                            });
                            
                            // 2. 对于不在 taskTree 中或者 taskTree 显示无任务的文档，使用 SQL 查询
                            const uncheckedIds = allIds.filter(id => !tasksMap.has(id));
                            if (uncheckedIds.length > 0) {
                                // 批量查询：检查每个文档下是否有任务
                                // SELECT root_id FROM blocks WHERE type='i' AND subtype='t' AND root_id IN (...) GROUP BY root_id
                                const CHUNK_SIZE = 50; // 分批查询以避免 SQL 过长
                                for (let i = 0; i < uncheckedIds.length; i += CHUNK_SIZE) {
                                    const chunk = uncheckedIds.slice(i, i + CHUNK_SIZE);
                                    const idsStr = chunk.map(id => `'${id}'`).join(',');
                                    const sql = `SELECT DISTINCT root_id FROM blocks WHERE type='i' AND subtype='t' AND root_id IN (${idsStr})`;
                                    try {
                                        const res = await API.call('/api/query/sql', { stmt: sql });
                                        if (res.code === 0 && res.data) {
                                            res.data.forEach(row => tasksMap.set(row.root_id, true));
                                        }
                                    } catch(e) { console.error('SQL Query Error', e); }
                                }
                            }

                            // 过滤：只展示有任务的文档
                            const docList = allIds.map(id => {
                                return { id, hasTasks: tasksMap.has(id) };
                            }).filter(item => item.hasTasks);

                            // 排序：按名称
                            docList.sort((a, b) => {
                                return resolveDocName(a.id).localeCompare(resolveDocName(b.id));
                            });
                            
                            // 渲染
                            renderDocs(docList);
                            
                        } catch (e) {
                            console.error('[QuickAdd] 加载分组文档失败', e);
                            renderDocs(docs); // 回退
                        }
                    } else {
                        renderDocs(docs);
                    }
                } else {
                    body.style.display = 'none';
                    head.lastElementChild.textContent = '▸';
                }
            };

            wrap.appendChild(head);
            wrap.appendChild(body);
            return wrap;
        };

        groups.forEach(g => {
            const docs = Array.isArray(g?.docs) ? g.docs : [];
            if (docs.length === 0) return;
            // 传递 group.id 以便进行动态查询
            listEl.appendChild(renderGroup(String(g?.name || '分组'), docs, String(g?.id || '')));
        });
    };

    window.tmQuickAddCloseDocPicker = function() {
        if (state.quickAddDocPicker) {
            try { state.quickAddDocPicker.remove(); } catch (e) {}
            state.quickAddDocPicker = null;
        }
    };

    window.tmQuickAddSelectDoc = async function(docId) {
        const qa = state.quickAdd;
        if (!qa) return;
        const id = String(docId || '').trim();
        if (!id) return;
        // 仅更新本地状态，不修改全局设置
        qa.docId = id;
        qa.docMode = 'doc';
        // 移除对 updateNewTaskDocId 的调用，避免修改全局新建文档设置
        window.tmQuickAddRenderMeta?.();
        window.tmQuickAddCloseDocPicker?.();
    };

    window.tmQuickAddUseTodayDiary = function() {
        const qa = state.quickAdd;
        if (!qa) return;
        qa.docMode = 'dailyNote';
        try { window.tmQuickAddCloseDocPicker?.(); } catch (e) {}
        window.tmQuickAddRenderMeta?.();
    };

    window.tmQuickAddUseDefaultDoc = function() {
        const qa = state.quickAdd;
        if (!qa) return;
        const id = __tmResolveDefaultDocId();
        if (!id) {
            hint('⚠ 未设置默认任务文档', 'warning');
            return;
        }
        qa.docId = id;
        qa.docMode = 'doc';
        window.tmQuickAddRenderMeta?.();
    };

    window.tmQuickAddSubmit = async function() {
        const qa = state.quickAdd;
        if (!qa) return;
        const input = document.getElementById('tmQuickAddInput');
        const content = String(input?.value || '').trim();
        if (!content) return;
        try {
            let targetDocId = qa.docId;
            if (qa.docMode === 'dailyNote') {
                const notebook = await API.getDocNotebook(qa.docId);
                if (!notebook) throw new Error('无法确定日记所属笔记本');
                targetDocId = await API.createDailyNote(notebook);
                if (!String(targetDocId || '').trim()) throw new Error('获取日记文档失败');
            }
            await __tmCreateTaskInDoc({
                docId: targetDocId,
                content,
                priority: qa.priority,
                customStatus: qa.customStatus,
                completionTime: qa.completionTime,
            });
            hint('✅ 任务已创建', 'success');
            window.tmQuickAddClose?.();
        } catch (e) {
            hint(`❌ 创建失败: ${e.message}`, 'error');
        }
    };

    window.tmAdd = async function() {
        window.tmQuickAddOpen?.();
    };

    // 重新计算统计信息
    function recalcStats() {
        let total = 0, done = 0;
        const traverse = (tasks) => {
            tasks.forEach(task => {
                total++;
                if (task.done) done++;
                if (task.children && task.children.length > 0) {
                    traverse(task.children);
                }
            });
        };
        state.taskTree.forEach(doc => {
            traverse(doc.tasks);
        });
        state.stats.totalTasks = total;
        state.stats.doneTasks = done;
    }

    // 解析文档分组中的所有文档ID
    async function resolveDocIdsFromGroups() {
        const groups = SettingsStore.data.docGroups || [];
        const currentGroupId = SettingsStore.data.currentGroupId || 'all';
        const quickAddDocId = String(SettingsStore.data.newTaskDocId || '').trim();
        
        let targetDocs = [];
        
        if (currentGroupId === 'all') {
            // “全部”模式：包含旧版 selectedDocIds 和所有分组中的文档
            // 1. 旧版 selectedDocIds (视为无递归)
            const legacyIds = SettingsStore.data.selectedDocIds || [];
            legacyIds.forEach(id => targetDocs.push({ id, recursive: false }));
            
            // 2. 所有分组中的文档
            groups.forEach(g => {
                if (Array.isArray(g.docs)) {
                    targetDocs.push(...g.docs);
                }
            });
        } else {
            // 特定分组模式
            const group = groups.find(g => g.id === currentGroupId);
            if (group && Array.isArray(group.docs)) {
                targetDocs = group.docs;
            }
        }

        // 归一化文档项并按当前分组钉住顺序前置
        const normalizedDocs = (targetDocs || [])
            .map((doc) => {
                const id = String((typeof doc === 'object' ? doc?.id : doc) || '').trim();
                if (!id) return null;
                return { id, recursive: !!(typeof doc === 'object' ? doc?.recursive : false) };
            })
            .filter(Boolean);
        const docsInOrder = __tmSortDocEntriesByPinned(normalizedDocs, currentGroupId);

        // 解析递归文档（保持顺序去重）
        const finalIds = [];
        const seen = new Set();
        const pushId = (id0) => {
            const id = String(id0 || '').trim();
            if (!id || seen.has(id)) return;
            seen.add(id);
            finalIds.push(id);
        };
        if (quickAddDocId && quickAddDocId !== '__dailyNote__') pushId(quickAddDocId);

        const promises = docsInOrder.map(async (doc) => {
            pushId(doc.id);
            if (doc.recursive) {
                const subIds = await API.getSubDocIds(doc.id);
                (subIds || []).forEach(id => pushId(id));
            }
        });

        await Promise.all(promises);
        return finalIds;
    }

    // 加载所有选中文档的任务（带递归支持）
    async function loadSelectedDocuments(options = {}) {
        const token = Number(state.openToken) || 0;
        const skipRender = !!(options && options.skipRender);
        try { state.doneOverrides = {}; } catch (e) {}
        // 加载设置（包括文档ID列表）
        await SettingsStore.load();
        await MetaStore.load();
        await WhiteboardStore.load();
        try { globalThis.__taskHorizonQuickbarToggle?.(!!SettingsStore.data.enableQuickbar); } catch (e) {}
        const quickAddDocId = String(SettingsStore.data.newTaskDocId || '').trim();
        
        // 将设置同步到 state
        state.selectedDocIds = SettingsStore.data.selectedDocIds;
        state.queryLimit = SettingsStore.data.queryLimit;
        const gm0 = String(SettingsStore.data.groupMode || '').trim();
        const validModes = new Set(['none', 'doc', 'time', 'quadrant', 'task']);
        if (!validModes.has(gm0)) {
            // groupMode 无效时，根据标志位推导模式
            state.groupByDocName = SettingsStore.data.groupByDocName;
            state.groupByTaskName = SettingsStore.data.groupByTaskName;
            state.groupByTime = SettingsStore.data.groupByTime;
            state.quadrantEnabled = SettingsStore.data.quadrantConfig?.enabled || false;
        }
        // 根据 groupMode 设置标志位，但 groupByTaskName 只在 groupMode === 'task' 时才设置为 true
        if (gm0 === 'doc') {
            state.groupByDocName = true;
            state.groupByTime = false;
            state.quadrantEnabled = false;
        } else if (gm0 === 'time') {
            state.groupByDocName = false;
            state.groupByTime = true;
            state.quadrantEnabled = false;
        } else if (gm0 === 'task') {
            state.groupByDocName = false;
            state.groupByTaskName = true;
            state.groupByTime = false;
            state.quadrantEnabled = false;
        } else if (gm0 === 'quadrant') {
            state.groupByDocName = false;
            state.groupByTime = false;
            state.quadrantEnabled = true;
        } else {
            // 当 groupMode 为 'none' 时（用户选择了"不分组"），将 state.groupByTaskName 设置为 false
            // 这样可以正确显示"不分组"选项为选中状态
            // 注意：这里不检查 SettingsStore.data.groupByTaskName，因为它只控制开关显示，不影响当前分组模式
            state.groupByDocName = false;
            state.groupByTaskName = false;
            state.groupByTime = false;
            state.quadrantEnabled = false;
        }
        state.collapsedTaskIds = new Set(SettingsStore.data.collapsedTaskIds || []);
        state.collapsedGroups = new Set(SettingsStore.data.collapsedGroups || []);
        state.currentRule = SettingsStore.data.currentRule;
        state.columnWidths = SettingsStore.data.columnWidths;
        state.excludeCompletedTasks = !!SettingsStore.data.excludeCompletedTasks;

        // 加载筛选规则
        state.filterRules = await RuleManager.initRules();
        const currentRule = state.currentRule ? state.filterRules.find(r => r.id === state.currentRule) : null;
        state.__tmQueryDoneOnly = !!(currentRule && currentRule.conditions && currentRule.conditions.some(c => c && c.field === 'done' && c.operator === '=' && (c.value === true || String(c.value) === 'true' || c.value === '') && String(c.value) !== '__all__'));

        // 1. 解析所有需要查询的文档ID
        const allDocIds = await resolveDocIdsFromGroups();
        try {
            if (typeof window.tmCalendarWarmDocsToGroupCache === 'function') {
                await window.tmCalendarWarmDocsToGroupCache();
            }
        } catch (e) {}
        
        // 如果没有文档，打开设置
        if (allDocIds.length === 0) {
            state.taskTree = [];
            state.flatTasks = {};
            applyFilters();
            if (!skipRender && state.modal && token === (Number(state.openToken) || 0)) render();
            if (state.modal && token === (Number(state.openToken) || 0)) showSettings();
            return;
        }

        try {
            const startTime = Date.now();
            
            // 2. 批量获取任务
            const res = await API.getTasksByDocuments(allDocIds, state.queryLimit, { doneOnly: !!state.__tmQueryDoneOnly });
            
            if (token !== (Number(state.openToken) || 0)) return;
            // 更新统计信息
            state.stats.queryTime = res.queryTime || (Date.now() - startTime);
            state.stats.totalTasks = res.totalCount || 0;
            state.stats.doneTasks = res.doneCount || 0;

            const nextTaskTree = [];
            const nextFlatTasks = {};

            if (res.tasks) {
                let h2ContextMap = new Map();
                try {
                    h2ContextMap = await API.fetchH2Contexts(res.tasks.map(t => t.id));
                } catch (e) {
                    h2ContextMap = new Map();
                }
                let taskFlowRankMap = new Map();
                try {
                    taskFlowRankMap = await API.fetchTaskFlowRanks(res.tasks.map(t => t.id));
                } catch (e) {
                    taskFlowRankMap = new Map();
                }
                const missingPriorityIds = [];

                // 3. 获取层级信息（不再依赖，改用前端递归计算）
                // const taskIds = res.tasks.map(t => t.id);
                // const hierarchyCache = await API.getTasksHierarchy(taskIds);

                // 4. 构建任务树
                // 将任务按文档分组
                const tasksByDoc = new Map();
                res.tasks.forEach(task => {
                    // 确保任务有root_id
                    if (!task.root_id) return;
                    const flowRank = Number(taskFlowRankMap.get(String(task.id || '').trim()));
                    if (Number.isFinite(flowRank)) task.docSeq = flowRank;
                    
                    // 解析任务状态
                    const parsed = API.parseTaskStatus(task.markdown);
                    const correctDone = parsed.done;
                    task.done = correctDone;
                    task.content = parsed.content;

                    // 应用 MetaStore
                    MetaStore.applyToTask(task);
                    task.done = correctDone; // 恢复正确状态
                    
                    // 标准化字段
                    const docName = task.docName || '未命名文档';
                    normalizeTaskFields(task, docName);
                    const h2ctx = h2ContextMap.get(task.id);
                    if (h2ctx && typeof h2ctx === 'object') {
                        task.h2 = String(h2ctx.content || '').trim();
                        task.h2Id = String(h2ctx.id || '').trim();
                        task.h2Path = String(h2ctx.path || '').trim();
                        task.h2Sort = Number(h2ctx.sort);
                        task.h2Created = String(h2ctx.created || '').trim();
                        task.h2Rank = Number(h2ctx.rank);
                    } else {
                        task.h2 = String(h2ctx || '').trim();
                        task.h2Id = '';
                        task.h2Path = '';
                        task.h2Sort = Number.NaN;
                        task.h2Created = '';
                        task.h2Rank = Number.NaN;
                    }
                    if (!task.priority) missingPriorityIds.push(task.id);

                    // 初始化 MetaStore（如果不存在）
                    const existing = MetaStore.get(task.id);
                    if (!existing) {
                        MetaStore.set(task.id, {
                            priority: task.priority || '',
                            duration: task.duration || '',
                            remark: task.remark || '',
                            completionTime: task.completionTime || '',
                            customTime: task.customTime || '',
                            content: task.content
                        });
                    }
                    
                    // 初始化层级（后续递归计算覆盖）
                    task.level = 0;
                    task.children = [];

                    if (!tasksByDoc.has(task.root_id)) {
                        tasksByDoc.set(task.root_id, []);
                    }
                    tasksByDoc.get(task.root_id).push(task);
                    nextFlatTasks[task.id] = task;
                });

                try {
                    const ids = Array.from(new Set(missingPriorityIds)).filter(Boolean);
                    if (ids.length > 0) {
                        const map = await API.fetchNearestCustomPriority(ids, 10);
                        if (map && map.size > 0) {
                            ids.forEach(id => {
                                const v = map.get(id);
                                if (!v) return;
                                const t = nextFlatTasks?.[id];
                                if (!t) return;
                                t.priority = v;
                                try { normalizeTaskFields(t, t.docName || '未命名文档'); } catch (e) {}
                            });
                        }
                    }
                } catch (e) {}

                // 按文档顺序构建树
                for (const docId of allDocIds) {
                    // 获取该文档的所有任务
                    const rawTasks = tasksByDoc.get(docId) || [];
                    
                    // 获取文档名称
                    let docName = '未命名文档';
                    if (rawTasks.length > 0) {
                        docName = rawTasks[0].docName;
                    } else {
                        const cachedDoc = state.allDocuments.find(d => d.id === docId);
                        if (cachedDoc) docName = cachedDoc.name;
                    }

                    // 准备构建当前文档的任务树
                    const idMap = new Map();
                    rawTasks.forEach(t => idMap.set(t.id, t));

                    try {
                        const needListIds = new Set();
                        rawTasks.forEach(t => {
                            if (!t.parentTaskId && t.parent_id) needListIds.add(String(t.parent_id));
                        });
                        let frontier = Array.from(needListIds).filter(Boolean);
                        const blockInfoMap = new Map();
                        for (let depth = 0; depth < 6 && frontier.length > 0; depth++) {
                            const rows = await API.getBlocksByIds(frontier);
                            const next = [];
                            rows.forEach(r => {
                                const id = String(r?.id || '').trim();
                                if (!id) return;
                                const parentId = String(r?.parent_id || '').trim();
                                blockInfoMap.set(id, { parentId, type: r?.type, subtype: r?.subtype });
                                if (parentId && !blockInfoMap.has(parentId) && !idMap.has(parentId)) {
                                    next.push(parentId);
                                }
                            });
                            frontier = Array.from(new Set(next));
                        }

                        rawTasks.forEach(t => {
                            if (t.parentTaskId) return;
                            let cur = String(t.parent_id || '').trim();
                            if (!cur) return;
                            const seen = new Set();
                            for (let i = 0; i < 6 && cur; i++) {
                                if (seen.has(cur)) break;
                                seen.add(cur);
                                const info = blockInfoMap.get(cur);
                                const pid = String(info?.parentId || '').trim();
                                if (pid && idMap.has(pid)) {
                                    t.parentTaskId = pid;
                                    return;
                                }
                                cur = pid;
                            }
                        });
                    } catch (e) {}

                    // 建立父子关系
                    const rootTasks = [];
                    rawTasks.forEach(t => {
                        // 确保 children 是空的
                        if (!t.children) t.children = [];
                        
                        if (t.parentTaskId && idMap.has(t.parentTaskId)) {
                            const parent = idMap.get(t.parentTaskId);
                            if (!parent.children) parent.children = [];
                            parent.children.push(t);
                        } else {
                            rootTasks.push(t);
                        }
                    });

                    // 关键：前端递归计算层级（保证视图缩进正确）
                    const calcLevel = (tasks, level) => {
                        tasks.forEach(t => {
                            t.level = level;
                            if (t.children && t.children.length > 0) {
                                calcLevel(t.children, level + 1);
                            }
                        });
                    };
                    calcLevel(rootTasks, 0);

                    // 添加到任务树
                    if (rawTasks.length > 0 || state.selectedDocIds.includes(docId) || (quickAddDocId && docId === quickAddDocId)) { 
                         nextTaskTree.push({
                            id: docId,
                            name: docName,
                            tasks: rootTasks
                        });
                    }
                }
                if (token !== (Number(state.openToken) || 0)) return;
                state.taskTree = __tmSortDocEntriesByPinned(
                    nextTaskTree || [],
                    String(SettingsStore.data.currentGroupId || 'all').trim() || 'all'
                );
                state.flatTasks = nextFlatTasks;
                try { __tmUpsertWhiteboardTaskSnapshots(Object.values(state.flatTasks || {})); } catch (e) {}
                
                applyFilters();
                if (!skipRender && state.modal && token === (Number(state.openToken) || 0)) render();
            }
        } catch (e) {
            console.error('[加载] 获取任务失败:', e);
            hint('❌ 加载任务失败', 'error');
        }
    }

    let __tmAllDocumentsFetchedAt = 0;
    let __tmAllDocumentsFetchPromise = null;
    function __tmEnsureAllDocumentsLoaded(force = false) {
        const now = Date.now();
        if (!force && Array.isArray(state.allDocuments) && state.allDocuments.length > 0 && (now - (__tmAllDocumentsFetchedAt || 0) < 60000)) {
            return;
        }
        if (__tmAllDocumentsFetchPromise) return;
        __tmAllDocumentsFetchPromise = Promise.resolve()
            .then(() => API.getAllDocuments())
            .then((docs) => {
                if (Array.isArray(docs)) state.allDocuments = docs;
                __tmAllDocumentsFetchedAt = Date.now();
            })
            .catch((e) => {
                try { console.error('[设置] 刷新文档列表失败:', e); } catch (e2) {}
            })
            .finally(() => {
                __tmAllDocumentsFetchPromise = null;
            });
    }

    // 显示设置
    function showSettings() {
        try { __tmHideMobileMenu(); } catch (e) {}
        if (state.settingsModal) {
            try { state.settingsModal.remove(); } catch (e) {}
            state.settingsModal = null;
        }

        state.settingsModal = document.createElement('div');
        state.settingsModal.className = 'tm-settings-modal';

        const groups = SettingsStore.data.docGroups || [];
        const currentGroupId = SettingsStore.data.currentGroupId || 'all';
        
        // 渲染分组选择器
        const renderGroupSelector = () => {
            return `
                <div style="margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                    <select id="groupSelector" data-tm-call="switchDocGroup" 
                            style="flex: 1; padding: 6px 8px; border: 1px solid var(--tm-input-border); background: var(--tm-input-bg); color: var(--tm-text-color); border-radius: 4px;">
                        <option value="all" ${currentGroupId === 'all' ? 'selected' : ''}>全部文档</option>
                        ${groups.map(g => `<option value="${g.id}" ${currentGroupId === g.id ? 'selected' : ''}>${esc(g.name)}</option>`).join('')}
                    </select>
                    <button class="tm-btn tm-btn-primary" data-tm-action="createNewGroup" style="padding: 6px 10px; font-size: 12px;">+ 新建分组</button>
                    ${currentGroupId !== 'all' ? `<button class="tm-btn tm-btn-danger" data-tm-action="deleteCurrentGroup" style="padding: 6px 10px; font-size: 12px;">删除分组</button>
                        <button class="tm-btn tm-btn-success" data-tm-action="exportCurrentGroup" style="padding: 6px 10px; font-size: 12px;">导出任务</button>` : ''}
                </div>
            `;
        };

        // 获取当前显示的文档列表
        let currentDocs = [];
        if (currentGroupId === 'all') {
            // 显示所有（包括旧版和各分组）
            const legacyIds = SettingsStore.data.selectedDocIds || [];
            legacyIds.forEach(id => currentDocs.push({ id, recursive: false }));
            groups.forEach(g => {
                if (Array.isArray(g.docs)) currentDocs.push(...g.docs);
            });
            // 去重
            const seen = new Set();
            currentDocs = currentDocs.filter(d => {
                if (seen.has(d.id)) return false;
                seen.add(d.id);
                return true;
            });
        } else {
            const group = groups.find(g => g.id === currentGroupId);
            if (group) currentDocs = group.docs || [];
        }

        const resolveDocName = (docId) => {
            if (!docId) return '未知文档';
            let doc = state.allDocuments.find(d => d.id === docId);
            if (!doc) {
                const docEntry = state.taskTree.find(d => d.id === docId);
                if (docEntry) doc = { id: docId, name: docEntry.name };
            }
            return doc?.name || '未知文档';
        };

        const defaultDocIdByGroup = (SettingsStore.data.defaultDocIdByGroup && typeof SettingsStore.data.defaultDocIdByGroup === 'object')
            ? SettingsStore.data.defaultDocIdByGroup
            : {};
        const defaultDocId = String((currentGroupId === 'all' ? SettingsStore.data.defaultDocId : defaultDocIdByGroup[currentGroupId]) || '').trim();
        const currentDocIds = currentDocs.map(d => (typeof d === 'object' ? d.id : d));
        const defaultDocOptions = [
            `<option value="" ${defaultDocId ? '' : 'selected'}>跟随当前/第一个文档</option>`
        ];
        currentDocs.forEach(docItem => {
            const docId = typeof docItem === 'object' ? docItem.id : docItem;
            const docName = resolveDocName(docId);
            defaultDocOptions.push(`<option value="${docId}" ${defaultDocId === docId ? 'selected' : ''}>${esc(docName)}</option>`);
        });
        if (defaultDocId && !currentDocIds.includes(defaultDocId)) {
            const fallbackName = resolveDocName(defaultDocId);
            defaultDocOptions.push(`<option value="${defaultDocId}" selected>${esc(fallbackName)} (不在当前列表)</option>`);
        }
        const allDocsForNewTask = (() => {
            const list = [];
            const legacyIds = SettingsStore.data.selectedDocIds || [];
            legacyIds.forEach(id => list.push({ id, recursive: false }));
            (SettingsStore.data.docGroups || []).forEach(g => {
                if (Array.isArray(g?.docs)) list.push(...g.docs);
            });
            const seen = new Set();
            return list.filter(d => {
                const id = String(d?.id || '').trim();
                if (!id) return false;
                if (seen.has(id)) return false;
                seen.add(id);
                return true;
            });
        })();
        const allDocIdsForNewTask = allDocsForNewTask.map(d => String(d?.id || '').trim()).filter(Boolean);
        const newTaskDocId = String(SettingsStore.data.newTaskDocId || '').trim();
        const newTaskDocOptions = [
            `<option value="" ${newTaskDocId ? '' : 'selected'}>未设置</option>`,
            `<option value="__dailyNote__" ${newTaskDocId === '__dailyNote__' ? 'selected' : ''}>今天日记</option>`
        ];
        allDocsForNewTask.forEach(docItem => {
            const docId = typeof docItem === 'object' ? docItem.id : docItem;
            const docName = resolveDocName(docId);
            newTaskDocOptions.push(`<option value="${docId}" ${newTaskDocId === docId ? 'selected' : ''}>${esc(docName)}</option>`);
        });
        if (newTaskDocId && !allDocIdsForNewTask.includes(newTaskDocId)) {
            const fallbackName = resolveDocName(newTaskDocId);
            newTaskDocOptions.push(`<option value="${newTaskDocId}" selected>${esc(fallbackName)} (不在当前列表)</option>`);
        }
        let activeTab = 'main';
        if (state.settingsActiveTab === 'appearance') activeTab = 'appearance';
        if (state.settingsActiveTab === 'calendar') activeTab = 'calendar';
        if (state.settingsActiveTab === 'rules') activeTab = 'rules';
        if (state.settingsActiveTab === 'quadrant') activeTab = 'quadrant';
        if (state.settingsActiveTab === 'priority') activeTab = 'priority';
        if (activeTab === 'main') {
            try { __tmEnsureAllDocumentsLoaded(false); } catch (e) {}
        }

        state.settingsModal.innerHTML = `
            <div class="tm-settings-box" style="overflow: hidden;">
                <div class="tm-settings-header">
                    <div class="tm-settings-title">⚙️ 任务管理器设置</div>
                    <button class="tm-btn tm-btn-gray" data-tm-action="closeSettings">关闭</button>
                </div>

                <div class="tm-settings-tabs" style="display: flex; gap: 8px; margin-bottom: 16px; border-bottom: 1px solid var(--tm-border-color); padding-bottom: 8px;">
                    ${activeTab !== 'rule_editor' ? `
                    <button class="tm-btn ${activeTab === 'main' ? 'tm-btn-primary' : 'tm-btn-secondary'}" data-tm-action="tmSwitchSettingsTab" data-tab="main" style="padding: 6px 10px; font-size: 12px;">常规设置</button>
                    <button class="tm-btn ${activeTab === 'appearance' ? 'tm-btn-primary' : 'tm-btn-secondary'}" data-tm-action="tmSwitchSettingsTab" data-tab="appearance" style="padding: 6px 10px; font-size: 12px;">外观</button>
                    <button class="tm-btn ${activeTab === 'calendar' ? 'tm-btn-primary' : 'tm-btn-secondary'}" data-tm-action="tmSwitchSettingsTab" data-tab="calendar" style="padding: 6px 10px; font-size: 12px;">日历</button>
                    <button class="tm-btn ${activeTab === 'rules' ? 'tm-btn-primary' : 'tm-btn-secondary'}" data-tm-action="tmSwitchSettingsTab" data-tab="rules" style="padding: 6px 10px; font-size: 12px;">规则管理</button>
                    <button class="tm-btn ${activeTab === 'quadrant' ? 'tm-btn-primary' : 'tm-btn-secondary'}" data-tm-action="tmSwitchSettingsTab" data-tab="quadrant" style="padding: 6px 10px; font-size: 12px;">四象限</button>
                    <button class="tm-btn ${activeTab === 'priority' ? 'tm-btn-primary' : 'tm-btn-secondary'}" data-tm-action="tmSwitchSettingsTab" data-tab="priority" style="padding: 6px 10px; font-size: 12px;">优先级算法</button>
                    ` : `
                    <button class="tm-btn tm-btn-primary" style="padding: 6px 10px; font-size: 12px;">${state.editingRule ? '编辑规则' : '新建规则'}</button>
                    `}
                </div>

                <div style="flex: 1; overflow-y: auto; min-height: 0; padding-right: 4px; margin-bottom: 16px;">
                    ${activeTab === 'appearance' ? `
                        <div style="margin-bottom: 16px; padding: 12px; background: var(--tm-section-bg); border-radius: 8px;" class="tm-width-settings">
                            <div style="font-weight: 600; margin-bottom: 12px;">📏 列设置 (显示/排序/宽度)</div>
                            ${renderColumnWidthSettings()}
                        </div>
                        <div style="margin-bottom: 0; padding: 12px; background: var(--tm-section-bg); border-radius: 8px;">
                            <div style="font-weight: 600; margin-bottom: 12px;">🎨 配色</div>
                            ${renderAppearanceColorSettings()}
                        </div>
                    ` : ''}

                    ${activeTab === 'calendar' ? `
                        <div style="margin-bottom: 0; padding: 12px; background: var(--tm-section-bg); border-radius: 8px;">
                            <div style="font-weight: 600; margin-bottom: 12px;">🗓️ 日历</div>
                            <div id="tm-calendar-settings-root"></div>
                        </div>
                    ` : ''}

                    ${activeTab === 'rules' ? `
                        <div style="margin-bottom: 16px; padding: 12px; background: var(--tm-section-bg); border-radius: 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                <div style="font-weight: 600;">📋 筛选规则管理</div>
                                <div style="display:flex;gap:8px;align-items:center;">
                                    <button class="tm-btn tm-btn-secondary" data-tm-action="tmSwitchSettingsTab" data-tab="priority" style="padding: 4px 10px; font-size: 12px;">优先级算法</button>
                                    <button class="tm-btn tm-btn-primary" data-tm-action="addNewRule" style="padding: 4px 10px; font-size: 12px;">+ 新建规则</button>
                                </div>
                            </div>
                            <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px 12px; border:1px solid var(--tm-border-color); border-radius:8px; background: var(--tm-card-bg); margin-bottom: 12px;">
                                <div style="font-size:13px; color: var(--tm-text-color);">时间轴强制按完成日期排序（越近今天越靠前）</div>
                                <input type="checkbox" ${SettingsStore.data.timelineForceSortByCompletionNearToday ? 'checked' : ''} onchange="tmToggleTimelineForceSortByCompletionNearToday(this.checked)">
                            </div>
                            <div id="tm-rules-list" style="display: flex; flex-direction: column; gap: 8px;">
                                ${renderRulesList()}
                            </div>
                            <div style="font-size: 12px; color: var(--tm-secondary-text); margin-top: 12px; padding-top: 8px; border-top: 1px solid var(--tm-border-color);">
                                规则说明：支持多条件组合筛选，可设置“包含/不包含”关键词、“优先级”、“状态”等条件。
                            </div>
                        </div>
                    ` : ''}

                    ${activeTab === 'priority' ? `
                        <div style="margin-bottom: 16px; padding: 12px; background: var(--tm-section-bg); border-radius: 8px;">
                            <div id="tm-priority-settings">
                                ${__tmRenderPriorityScoreSettings(true)}
                            </div>
                        </div>
                    ` : ''}
                    
                    ${activeTab === 'quadrant' ? `
                        <div style="margin-bottom: 16px; padding: 12px; background: var(--tm-section-bg); border-radius: 8px;">
                            <div style="font-weight: 600; margin-bottom: 12px;">📊 四象限分组规则</div>
                            <div style="font-size: 12px; color: var(--tm-secondary-text); margin-bottom: 12px;">
                                根据任务的「重要性」和「完成日期」自动将任务分配到四个象限。
                            </div>
                            ${renderQuadrantSettings()}
                        </div>
                    ` : ''}
                    
                    ${activeTab === 'rule_editor' ? `
                        <div class="tm-rule-editor-inline">
                            ${state.editingRule ? RuleManager.renderEditorContent(state.editingRule) : ''}
                        </div>
                    ` : ''}

                    ${activeTab === 'main' ? `
                    <div style="margin-bottom: 16px; display: flex; gap: 12px; flex-wrap: wrap; align-items: flex-start;">
                        <label style="display: flex; flex-wrap: wrap; align-items: center; gap: 8px; row-gap: 6px; cursor: pointer; flex: 1 1 260px; min-width: 220px;">
                            <span>查询限制: </span>
                            <input type="number" value="${state.queryLimit}"
                                   onchange="updateQueryLimit(this.value)"
                                   style="width: 80px; padding: 4px 8px; border: 1px solid var(--tm-input-border); background: var(--tm-input-bg); color: var(--tm-text-color); border-radius: 4px;">
                            <span>条任务/文档</span>
                        </label>
                        
                        <label style="display: flex; flex-wrap: wrap; align-items: center; gap: 8px; row-gap: 6px; cursor: pointer; flex: 1 1 220px; min-width: 180px;">
                            <span>字体大小: </span>
                            <input type="number" value="${SettingsStore.data.fontSize}" min="10" max="30"
                                   onchange="updateFontSize(this.value)"
                                   style="width: 60px; padding: 4px 8px; border: 1px solid var(--tm-input-border); background: var(--tm-input-bg); color: var(--tm-text-color); border-radius: 4px;">
                            <span>px</span>
                        </label>

                        <label style="display: flex; flex-wrap: wrap; align-items: center; gap: 8px; row-gap: 6px; cursor: pointer; flex: 1 1 240px; min-width: 200px;">
                            <span>移动端字体: </span>
                            <input type="number" value="${SettingsStore.data.fontSizeMobile || SettingsStore.data.fontSize}" min="10" max="30"
                                   onchange="updateFontSizeMobile(this.value)"
                                   style="width: 60px; padding: 4px 8px; border: 1px solid var(--tm-input-border); background: var(--tm-input-bg); color: var(--tm-text-color); border-radius: 4px;">
                            <span>px</span>
                        </label>

                        <label style="display: flex; flex-wrap: wrap; align-items: center; gap: 8px; row-gap: 6px; cursor: pointer; flex: 1 1 240px; min-width: 200px;">
                            <span>行高: </span>
                            <select onchange="updateRowHeightMode(this.value)"
                                    style="padding: 4px 8px; border: 1px solid var(--tm-input-border); background: var(--tm-input-bg); color: var(--tm-text-color); border-radius: 4px;">
                                <option value="auto" ${String(SettingsStore.data.rowHeightMode || 'auto') === 'auto' ? 'selected' : ''}>自动</option>
                                <option value="compact" ${String(SettingsStore.data.rowHeightMode || '') === 'compact' ? 'selected' : ''}>紧凑</option>
                                <option value="normal" ${String(SettingsStore.data.rowHeightMode || '') === 'normal' ? 'selected' : ''}>标准</option>
                                <option value="comfortable" ${String(SettingsStore.data.rowHeightMode || '') === 'comfortable' ? 'selected' : ''}>宽松</option>
                            </select>
                        </label>

                        <label style="display: flex; flex-wrap: wrap; align-items: center; gap: 8px; row-gap: 6px; cursor: pointer; flex: 1 1 260px; min-width: 220px;">
                            <span>行高(px): </span>
                            <input type="number" value="${Number(SettingsStore.data.rowHeightPx) || 0}" min="0" max="120"
                                   onchange="updateRowHeightPx(this.value)"
                                   style="width: 70px; padding: 4px 8px; border: 1px solid var(--tm-input-border); background: var(--tm-input-bg); color: var(--tm-text-color); border-radius: 4px;">
                            <span style="font-size:12px;color:var(--tm-secondary-text);">(0=跟随)</span>
                        </label>

                        <label style="display: flex; flex-wrap: wrap; align-items: center; gap: 8px; row-gap: 6px; cursor: pointer; flex: 1 1 240px; min-width: 200px;">
                            <span>任务标题级别: </span>
                            <select onchange="updateTaskHeadingLevel(this.value)"
                                    style="padding: 4px 8px; border: 1px solid var(--tm-input-border); background: var(--tm-input-bg); color: var(--tm-text-color); border-radius: 4px;">
                                <option value="h1" ${SettingsStore.data.taskHeadingLevel === 'h1' ? 'selected' : ''}>H1 一级标题</option>
                                <option value="h2" ${SettingsStore.data.taskHeadingLevel === 'h2' ? 'selected' : ''}>H2 二级标题</option>
                                <option value="h3" ${SettingsStore.data.taskHeadingLevel === 'h3' ? 'selected' : ''}>H3 三级标题</option>
                                <option value="h4" ${SettingsStore.data.taskHeadingLevel === 'h4' ? 'selected' : ''}>H4 四级标题</option>
                                <option value="h5" ${SettingsStore.data.taskHeadingLevel === 'h5' ? 'selected' : ''}>H5 五级标题</option>
                                <option value="h6" ${SettingsStore.data.taskHeadingLevel === 'h6' ? 'selected' : ''}>H6 六级标题</option>
                            </select>
                        </label>
                    </div>

                    <div style="margin-bottom: 16px; padding: 12px; background: var(--tm-section-bg); border-radius: 8px;">
                        <div style="font-weight: 600; margin-bottom: 8px;">⚡ 性能与显示设置</div>
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                            <input type="checkbox" ${SettingsStore.data.excludeCompletedTasks ? 'checked' : ''} onchange="updateExcludeCompletedTasks(this.checked)">
                            不查找已完成父任务（提升搜索性能和长期使用性能）
                        </label>
                        <div style="font-size: 12px; color: var(--tm-secondary-text); margin-top: 6px; margin-bottom: 12px;">
                            开启后仅查找未完成任务。含有子任务的任务，如果父任务未完成，已完成的子任务仍会显示。
                            <br>示例：假设笔记中有 1000 条任务，其中 800 条已完成，则这 800 条任务在开启后不会被查找到。
                            <br>如需复盘已完成任务：在规则设置中添加/选择条件「完成状态」，将其设置为「所有状态」或「是」均可在筛选已完成任务时搜索到全部已完成任务。
                        </div>
                        <div style="display:flex;align-items:center;gap:8px;margin-bottom:10px;flex-wrap:wrap;">
                            <span style="font-size:12px;color:var(--tm-secondary-text);">默认视图:</span>
                            <select onchange="updateDefaultViewMode(this.value)" style="padding: 4px 8px; border: 1px solid var(--tm-input-border); background: var(--tm-input-bg); color: var(--tm-text-color); border-radius: 4px;">
                                <option value="list" ${String(SettingsStore.data.defaultViewMode || 'list') === 'list' ? 'selected' : ''}>表格视图</option>
                                <option value="timeline" ${String(SettingsStore.data.defaultViewMode || '') === 'timeline' ? 'selected' : ''}>时间轴视图</option>
                                <option value="kanban" ${String(SettingsStore.data.defaultViewMode || '') === 'kanban' ? 'selected' : ''}>看板视图</option>
                                <option value="calendar" ${String(SettingsStore.data.defaultViewMode || '') === 'calendar' ? 'selected' : ''}>日历视图</option>
                                <option value="whiteboard" ${String(SettingsStore.data.defaultViewMode || '') === 'whiteboard' ? 'selected' : ''}>白板视图</option>
                            </select>
                        </div>
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;margin-bottom:10px;">
                            <input type="checkbox" ${SettingsStore.data.kanbanCompactMode ? 'checked' : ''} onchange="updateKanbanCompactMode(this.checked)">
                            看板紧凑模式（更窄更矮，显示更多卡片）
                        </label>
                        <div style="display:flex;align-items:center;gap:8px;margin-bottom:10px;flex-wrap:wrap;">
                            <span style="font-size:12px;color:var(--tm-secondary-text);">看板宽度:</span>
                            <input type="range" min="220" max="520" step="10" value="${Number(SettingsStore.data.kanbanColumnWidth) || 320}" onchange="updateKanbanColumnWidth(this.value)" style="width: 180px;">
                            <span style="font-size:12px;min-width:52px;">${Math.max(220, Math.min(520, Number(SettingsStore.data.kanbanColumnWidth) || 320))}px</span>
                        </div>
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;margin-bottom:10px;">
                            <input type="checkbox" ${SettingsStore.data.kanbanShowDoneColumn ? 'checked' : ''} onchange="updateKanbanShowDoneColumn(this.checked)">
                            看板显示“已完成”列
                        </label>
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;margin-bottom:10px;">
                            <input type="checkbox" ${SettingsStore.data.kanbanDragSyncSubtasks ? 'checked' : ''} onchange="updateKanbanDragSyncSubtasks(this.checked)">
                            看板拖动父任务时同步更改子任务状态
                        </label>
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;margin-bottom:10px;">
                            <input type="checkbox" ${SettingsStore.data.docH2SubgroupEnabled !== false ? 'checked' : ''} onchange="updateDocH2SubgroupEnabled(this.checked)">
                            文档分组下按二级标题子分组（时间轴/表格/日历侧边栏）
                        </label>
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;margin-bottom:10px;">
                            <input type="checkbox" ${SettingsStore.data.groupByTaskName || SettingsStore.data.groupMode === 'task' ? 'checked' : ''} onchange="updateGroupByTaskName(this.checked)">
                            分组模式增加：按任务名分组（相同任务内容分为一组）
                        </label>
                        <div style="display:flex;align-items:center;gap:8px;">
                            <span style="font-size:12px;color:var(--tm-secondary-text);">时长显示格式:</span>
                            <select onchange="updateDurationFormat(this.value)" style="padding: 4px 8px; border: 1px solid var(--tm-input-border); background: var(--tm-input-bg); color: var(--tm-text-color); border-radius: 4px;">
                                <option value="hours" ${String(SettingsStore.data.durationFormat || 'hours') === 'hours' ? 'selected' : ''}>小时 (如 1.5h)</option>
                                <option value="minutes" ${String(SettingsStore.data.durationFormat || '') === 'minutes' ? 'selected' : ''}>分钟 (如 90min)</option>
                            </select>
                        </div>
                    </div>

                    <div style="margin-bottom: 16px; padding: 12px; background: var(--tm-section-bg); border-radius: 8px;">
                        <div style="font-weight: 600; margin-bottom: 8px;">🧷 任务悬浮条（quickbar）</div>
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                            <input type="checkbox" ${SettingsStore.data.enableQuickbar ? 'checked' : ''} onchange="updateEnableQuickbar(this.checked)">
                            启用任务悬浮条（点击任务块显示自定义字段）
                        </label>
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;margin-top:8px;">
                            <input type="checkbox" ${SettingsStore.data.pinNewTasksByDefault ? 'checked' : ''} onchange="updatePinNewTasksByDefault(this.checked)">
                            新建任务默认置顶
                        </label>
                        <div style="font-size: 12px; color: var(--tm-secondary-text); margin-top: 6px;">
                            关闭后将不再弹出悬浮条，也不会拦截点击/长按事件。
                        </div>
                    </div>

                    <div style="margin-bottom: 16px; padding: 12px; background: var(--tm-section-bg); border-radius: 8px;">
                        <div style="font-weight: 600; margin-bottom: 8px;">🍅 番茄钟联动</div>
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                            <input type="checkbox" ${SettingsStore.data.enableTomatoIntegration ? 'checked' : ''} onchange="updateEnableTomatoIntegration(this.checked)">
                            启用 tomato.js 相关功能（计时/提醒/耗时列）
                        </label>
                        <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:10px;opacity:${SettingsStore.data.enableTomatoIntegration ? 1 : 0.6};">
                            <div style="display:flex;align-items:center;gap:8px;">
                                <span style="font-size:12px;color:var(--tm-secondary-text);">耗时读取模式:</span>
                                <select onchange="updateTomatoSpentAttrMode(this.value)" ${SettingsStore.data.enableTomatoIntegration ? '' : 'disabled'} style="padding: 4px 8px; border: 1px solid var(--tm-input-border); background: var(--tm-input-bg); color: var(--tm-text-color); border-radius: 4px;">
                                    <option value="minutes" ${String(SettingsStore.data.tomatoSpentAttrMode || 'minutes') === 'minutes' ? 'selected' : ''}>分钟属性</option>
                                    <option value="hours" ${String(SettingsStore.data.tomatoSpentAttrMode || '') === 'hours' ? 'selected' : ''}>小时属性</option>
                                </select>
                            </div>
                            <div style="display:flex;align-items:center;gap:8px;flex:1;min-width:220px;">
                                <span style="font-size:12px;color:var(--tm-secondary-text);white-space:nowrap;">分钟属性名</span>
                                <input type="text" value="${esc(String(SettingsStore.data.tomatoSpentAttrKeyMinutes || 'custom-tomato-minutes'))}" ${SettingsStore.data.enableTomatoIntegration ? '' : 'disabled'} onchange="updateTomatoSpentAttrKeyMinutes(this.value)" style="flex:1; min-width:160px; padding: 6px 8px; border: 1px solid var(--tm-input-border); background: var(--tm-input-bg); color: var(--tm-text-color); border-radius: 4px;">
                            </div>
                            <div style="display:flex;align-items:center;gap:8px;flex:1;min-width:220px;">
                                <span style="font-size:12px;color:var(--tm-secondary-text);white-space:nowrap;">小时属性名</span>
                                <input type="text" value="${esc(String(SettingsStore.data.tomatoSpentAttrKeyHours || 'custom-tomato-time'))}" ${SettingsStore.data.enableTomatoIntegration ? '' : 'disabled'} onchange="updateTomatoSpentAttrKeyHours(this.value)" style="flex:1; min-width:160px; padding: 6px 8px; border: 1px solid var(--tm-input-border); background: var(--tm-input-bg); color: var(--tm-text-color); border-radius: 4px;">
                            </div>
                        </div>
                        <div style="font-size: 12px; color: var(--tm-secondary-text); margin-top: 6px;">
                            属性名指的是思源区块属性 name，例如 custom-tomato-minutes。
                        </div>
                    </div>

                    <div style="margin-bottom: 16px; padding: 12px; background: var(--tm-section-bg); border-radius: 8px;">
                        <div style="font-weight: 600; margin-bottom: 8px;">📍 全局新建文档位置设置</div>
                        <select onchange="updateNewTaskDocIdFromSelect(this.value)" 
                                style="width: 100%; padding: 6px 8px; border: 1px solid var(--tm-input-border); background: var(--tm-input-bg); color: var(--tm-text-color); border-radius: 4px;">
                            ${newTaskDocOptions.join('')}
                        </select>
                        <div style="display:flex; gap:8px; margin-top: 8px; align-items:center;">
                            <input id="tmNewTaskDocIdInput" class="tm-input" list="tmNewTaskDocIdList"
                                   value="${esc(newTaskDocId === '__dailyNote__' ? '' : (newTaskDocId || ''))}"
                                   placeholder="也可直接输入文档ID"
                                   style="flex: 1; padding: 6px 8px;">
                            <button class="tm-btn tm-btn-secondary" onclick="tmApplyNewTaskDocIdInput()" style="padding: 6px 10px; font-size: 12px;">应用</button>
                            <button class="tm-btn tm-btn-gray" onclick="tmClearNewTaskDocIdInput()" style="padding: 6px 10px; font-size: 12px;">清空</button>
                        </div>
                        <datalist id="tmNewTaskDocIdList">
                            ${allDocsForNewTask.map(docItem => {
                                const docId = typeof docItem === 'object' ? docItem.id : docItem;
                                const docName = resolveDocName(docId);
                                return `<option value="${docId}">${esc(docName)}</option>`;
                            }).join('')}
                            ${newTaskDocId && !allDocIdsForNewTask.includes(newTaskDocId) ? `<option value="${newTaskDocId}"></option>` : ''}
                        </datalist>
                        <div style="font-size: 12px; color: var(--tm-secondary-text); margin-top: 6px;">
                            用于“快速新建任务界面”的默认文档位置，可在新建界面临时切换。
                        </div>
                    </div>

                    <div style="margin-bottom: 16px; padding: 12px; background: var(--tm-section-bg); border-radius: 8px;">
                        <div style="font-weight: 600; margin-bottom: 12px;">🏷️ 状态选项设置</div>
                        <div id="tm-status-options-list">
                            ${renderStatusOptionsList()}
                        </div>
                        <button class="tm-btn tm-btn-primary" data-tm-action="addStatusOption" style="margin-top: 8px; font-size: 12px;">+ 添加状态</button>
                    </div>

                    <div style="margin-bottom: 16px; padding: 12px; background: var(--tm-section-bg); border-radius: 8px;">
                        <div style="font-weight: 600; margin-bottom: 8px;">📂 文档分组与管理</div>
                        ${renderGroupSelector()}
                        
                        <div style="display: flex; gap: 8px; margin-top: 12px;">
                            <input type="text" id="manualDocId" placeholder="输入文档ID"
                                   style="flex: 1; padding: 8px 12px; border: 1px solid var(--tm-input-border); background: var(--tm-input-bg); color: var(--tm-text-color); border-radius: 4px; font-size: 13px;">
                            <label style="display: flex; align-items: center; gap: 4px; font-size: 12px; cursor: pointer; user-select: none;">
                                <input type="checkbox" id="recursiveCheck">
                                包含子文档
                            </label>
                            <button class="tm-btn tm-btn-primary" data-tm-action="addManualDoc">添加</button>
                        </div>
                        <div style="font-size: 12px; color: var(--tm-secondary-text); margin-top: 8px;">
                            提示：在思源笔记中打开文档，文档菜单中复制ID即可得到文档ID
                        </div>
                    </div>

                    <div style="margin-bottom: 0;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-weight: 600;">📚 当前列表文档（${currentDocs.length} 个）</span>
                            ${currentGroupId !== 'all' ? `<button class="tm-btn tm-btn-danger" data-tm-action="clearCurrentGroupDocs" style="padding: 4px 8px; font-size: 12px;">清空当前分组</button>` : ''}
                        </div>
                        ${currentDocs.length > 0 ? `
                            <div style="max-height: 150px; overflow-y: auto; border: 1px solid var(--tm-border-color); border-radius: 8px; padding: 8px;">
                                ${currentDocs.map((docItem, index) => {
                                    // 尝试从 allDocuments 中查找
                                    const docId = typeof docItem === 'object' ? docItem.id : docItem;
                                    const isRecursive = typeof docItem === 'object' ? !!docItem.recursive : false;
                                    
                                    let doc = state.allDocuments.find(d => d.id === docId);

                                    // 如果找不到，尝试从 taskTree 中查找
                                    if (!doc) {
                                        const docEntry = state.taskTree.find(d => d.id === docId);
                                        if (docEntry) {
                                            doc = { id: docId, name: docEntry.name };
                                        }
                                    }

                                    const docName = doc ? doc.name : '未知文档';
                                    const displayName = docName.length > 25 ? docName.substring(0, 25) + '...' : docName;

                                    return `
                                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 6px 8px; background: var(--tm-card-bg); border-radius: 4px; margin-bottom: 4px;">
                                            <div style="display: flex; align-items: center; gap: 8px; min-width: 0;">
                                                <span style="color: var(--tm-primary-color); font-weight: 500;">${index + 1}.</span>
                                                <div style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                                    <span title="${esc(docName)}">${esc(displayName)}</span>
                                                    ${isRecursive ? '<span style="font-size: 10px; background: var(--tm-info-bg); color: var(--tm-primary-color); padding: 1px 4px; border-radius: 4px; margin-left: 4px;">+子文档</span>' : ''}
                                                </div>
                                                <span style="font-size: 11px; color: var(--tm-task-done-color); font-family: monospace;">${docId.slice(0, 8)}...</span>
                                            </div>
                                            ${currentGroupId !== 'all' ? `
                                                <button class="tm-btn tm-btn-danger" onclick="removeDocFromGroup(${index})" style="padding: 2px 6px; font-size: 11px;">移除</button>
                                            ` : `
                                                <button class="tm-btn tm-btn-danger" onclick="removeDocFromAll('${docId}')" style="padding: 2px 6px; font-size: 11px;">移除</button>
                                            `}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        ` : '<div style="color: var(--tm-secondary-text); font-size: 13px; padding: 10px; background: var(--tm-rule-group-bg); border-radius: 8px;">暂无文档，请添加</div>'}
                    </div>
                    ` : ''}
                </div>

                ${activeTab === 'priority' ? `
                <div class="tm-settings-footer">
                    <button class="tm-btn tm-btn-secondary" data-tm-action="closePriorityScoreSettings">取消</button>
                    <button class="tm-btn tm-btn-success" data-tm-action="savePriorityScoreSettings">保存算法</button>
                </div>
                ` : activeTab !== 'rule_editor' ? `
                <div class="tm-settings-footer">
                    <button class="tm-btn tm-btn-secondary" data-tm-action="closeSettings">取消</button>
                    <button class="tm-btn tm-btn-success" data-tm-action="saveSettings">保存设置</button>
                </div>
                ` : `
                <div class="tm-settings-footer">
                    <button class="tm-btn tm-btn-secondary" data-tm-action="cancelEditRule">取消</button>
                    <button class="tm-btn tm-btn-success" data-tm-action="saveEditRule">保存规则</button>
                </div>
                `}
            </div>
        `;

        document.body.appendChild(state.settingsModal);
        __tmBindRulesManagerEvents(state.settingsModal);
        try {
            if (activeTab === 'calendar') {
                const el = state.settingsModal.querySelector('#tm-calendar-settings-root');
                if (el && globalThis.__tmCalendar && typeof globalThis.__tmCalendar.renderSettings === 'function') {
                    globalThis.__tmCalendar.renderSettings(el, SettingsStore);
                }
            }
        } catch (e) {}
    }
    window.showSettings = showSettings;
    window.tmSwitchSettingsTab = function(tab) {
        const prev = state.settingsActiveTab || 'main';
        if (tab === 'rules') {
            state.settingsActiveTab = 'rules';
        } else if (tab === 'appearance') {
            state.settingsActiveTab = 'appearance';
        } else if (tab === 'calendar') {
            state.settingsActiveTab = 'calendar';
        } else if (tab === 'quadrant') {
            state.settingsActiveTab = 'quadrant';
        } else if (tab === 'priority') {
            state.priorityScoreDraft = state.priorityScoreDraft || __tmEnsurePriorityDraft();
            state.settingsActiveTab = 'priority';
        } else {
            state.settingsActiveTab = 'main';
        }
        if ((state.settingsActiveTab || 'main') === prev) return;
        showSettings();
    };

    // 移除独立的规则管理器弹窗逻辑
    // window.showRulesManager = function() {...}
    // 改为直接跳转到设置页的规则标签
    window.showRulesManager = function() {
        state.settingsActiveTab = 'rules';
        showSettings();
    };

    // 渲染列设置（显示/排序/宽度）
    function renderColumnWidthSettings() {
        const availableCols = [
            { key: 'pinned', label: '置顶' },
            { key: 'content', label: '任务内容' },
            { key: 'status', label: '状态' },
            { key: 'score', label: '优先级' },
            { key: 'doc', label: '文档' },
            { key: 'h2', label: (() => {
                const level = SettingsStore.data.taskHeadingLevel || 'h2';
                const labels = { h1: '一级标题', h2: '二级标题', h3: '三级标题', h4: '四级标题', h5: '五级标题', h6: '六级标题' };
                return labels[level] || '标题';
            })() },
            { key: 'priority', label: '重要性' },
            { key: 'startDate', label: '开始日期' },
            { key: 'completionTime', label: '完成日期' },
            { key: 'duration', label: '时长' },
            { key: 'spent', label: '耗时' },
            { key: 'remark', label: '备注' }
        ];

        const currentOrder = SettingsStore.data.columnOrder || ['pinned', 'content', 'status', 'score', 'doc', 'h2', 'priority', 'startDate', 'completionTime', 'duration', 'spent', 'remark'];
        const widths = SettingsStore.data.columnWidths || {};

        let html = '<div class="tm-column-list">';
        
        // Visible columns
        currentOrder.forEach((key, index) => {
            const colDef = availableCols.find(c => c.key === key) || { key, label: key };
            const width = widths[key] || 120;
            
            html += `
                <div class="tm-column-item" style="display: flex; align-items: center; gap: 8px; padding: 6px; background: var(--tm-input-bg); margin-bottom: 4px; border-radius: 4px;">
                    <input type="checkbox" checked onchange="toggleColumn('${key}', false)" title="显示/隐藏">
                    <span style="width: 70px; font-weight: bold; font-size: 13px;">${colDef.label}</span>
                    <div style="display: flex; gap: 2px;">
                        <button class="tm-btn" onclick="moveColumn('${key}', -1)" ${index === 0 ? 'disabled' : ''} style="padding: 2px 6px; font-size: 10px;">↑</button>
                        <button class="tm-btn" onclick="moveColumn('${key}', 1)" ${index === currentOrder.length - 1 ? 'disabled' : ''} style="padding: 2px 6px; font-size: 10px;">↓</button>
                    </div>
                    <input type="range" min="10" max="800" value="${width}" style="flex: 1; margin: 0 8px;" onchange="updateColumnWidth('${key}', parseInt(this.value))" title="宽度调整">
                    <span style="font-size: 12px; width: 52px; text-align: right;">${width}px</span>
                </div>
            `;
        });

        // Invisible columns
        const hiddenCols = availableCols.filter(c => !currentOrder.includes(c.key));
        if (hiddenCols.length > 0) {
            html += '<div style="margin-top: 12px; font-size: 12px; color: var(--tm-secondary-text); margin-bottom: 4px;">隐藏的列 (勾选以显示):</div>';
            hiddenCols.forEach(col => {
                html += `
                    <div class="tm-column-item" style="display: flex; align-items: center; gap: 8px; padding: 6px; opacity: 0.7;">
                        <input type="checkbox" onchange="toggleColumn('${col.key}', true)">
                        <span style="font-size: 13px;">${col.label}</span>
                    </div>
                `;
            });
        }
        
        html += '</div>';
        return html;
    }

    function renderAppearanceColorSettings() {
        const d = SettingsStore.data || {};
        const isMobile = __tmIsMobileDevice();
        const items = [
            {
                title: '插件顶栏渐变',
                rows: [
                    { label: '亮色 起始', key: 'topbarGradientLightStart', value: d.topbarGradientLightStart || '#667eea' },
                    { label: '亮色 结束', key: 'topbarGradientLightEnd', value: d.topbarGradientLightEnd || '#764ba2' },
                    { label: '夜间 起始', key: 'topbarGradientDarkStart', value: d.topbarGradientDarkStart || '#3b49b7' },
                    { label: '夜间 结束', key: 'topbarGradientDarkEnd', value: d.topbarGradientDarkEnd || '#5b2d7a' },
                    { label: '顶栏文字 亮色', key: 'topbarTextColorLight', value: d.topbarTextColorLight || '#ffffff' },
                    { label: '顶栏文字 夜间', key: 'topbarTextColorDark', value: d.topbarTextColorDark || '#ffffff' }
                ]
            },
            {
                title: '任务内容列字体颜色',
                rows: [
                    { label: '亮色', key: 'taskContentColorLight', value: d.taskContentColorLight || '#333333' },
                    { label: '夜间', key: 'taskContentColorDark', value: d.taskContentColorDark || '#e0e0e0' }
                ]
            },
            {
                title: '子任务进度条背景',
                rows: [
                    { label: '亮色', key: 'progressBarColorLight', value: d.progressBarColorLight || '#4caf50' },
                    { label: '夜间', key: 'progressBarColorDark', value: d.progressBarColorDark || '#81c784' }
                ]
            },
            {
                title: '表格边框线颜色',
                rows: [
                    { label: '亮色', key: 'tableBorderColorLight', value: d.tableBorderColorLight || '#e9ecef' },
                    { label: '夜间', key: 'tableBorderColorDark', value: d.tableBorderColorDark || '#333333' }
                ]
            },
            {
                title: '分组名称（按文档分组）',
                rows: [
                    { label: '亮色', key: 'groupDocLabelColorLight', value: d.groupDocLabelColorLight || '#333333' },
                    { label: '夜间', key: 'groupDocLabelColorDark', value: d.groupDocLabelColorDark || '#e0e0e0' }
                ]
            },
            {
                title: '分组名称（按时间分组）',
                rows: [
                    { label: '未来基础色 亮色', key: 'timeGroupBaseColorLight', value: d.timeGroupBaseColorLight || '#1a73e8' },
                    { label: '未来基础色 夜间', key: 'timeGroupBaseColorDark', value: d.timeGroupBaseColorDark || '#6ba5ff' },
                    { label: '已过期 亮色', key: 'timeGroupOverdueColorLight', value: d.timeGroupOverdueColorLight || '#d93025' },
                    { label: '已过期 夜间', key: 'timeGroupOverdueColorDark', value: d.timeGroupOverdueColorDark || '#ff6b6b' }
                ]
            }
        ];

        const renderRow = (row) => {
            const raw = __tmNormalizeHexColor(row.value, '#000000') || '#000000';
            if (isMobile) {
                const upper = String(raw || '').toUpperCase();
                return `
                    <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;padding:6px 8px;border:1px solid var(--tm-border-color);border-radius:8px;background:var(--tm-bg-color);">
                        <span style="font-size:12px;color:var(--tm-secondary-text);">${esc(row.label)}</span>
                        <button type="button" class="tm-color-btn" data-tm-color-key="${esc(row.key)}" data-tm-color-label="${esc(row.label)}" onclick="tmOpenAppearanceColorPicker(this)">
                            <span class="tm-color-swatch" style="background:${esc(raw)}"></span>
                            <span class="tm-color-text">${esc(upper)}</span>
                        </button>
                    </label>
                `;
            }
            return `
                <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;padding:6px 8px;border:1px solid var(--tm-border-color);border-radius:8px;background:var(--tm-bg-color);">
                    <span style="font-size:12px;color:var(--tm-secondary-text);">${esc(row.label)}</span>
                    <input type="color" value="${esc(raw)}" onchange="tmUpdateAppearanceColor('${esc(row.key)}', this.value)" style="width:44px;height:28px;padding:0;border:none;background:transparent;">
                </label>
            `;
        };

        const cards = items.map((it) => `
            <div style="padding:10px;border:1px solid var(--tm-border-color);border-radius:10px;background:var(--tm-card-bg);">
                <div style="font-weight:600;margin-bottom:10px;">${esc(it.title)}</div>
                <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:8px;">
                    ${(it.rows || []).map(renderRow).join('')}
                </div>
            </div>
        `).join('');

        const previewLight = `linear-gradient(135deg, ${esc(__tmNormalizeHexColor(d.topbarGradientLightStart, '#667eea') || '#667eea')} 0%, ${esc(__tmNormalizeHexColor(d.topbarGradientLightEnd, '#764ba2') || '#764ba2')} 100%)`;
        const previewDark = `linear-gradient(135deg, ${esc(__tmNormalizeHexColor(d.topbarGradientDarkStart, '#3b49b7') || '#3b49b7')} 0%, ${esc(__tmNormalizeHexColor(d.topbarGradientDarkEnd, '#5b2d7a') || '#5b2d7a')} 100%)`;

        return `
            <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-bottom:12px;">
                <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
                    <span style="font-size:12px;color:var(--tm-secondary-text);">预览(亮色):</span>
                    <div id="tmAppearancePreviewLight" style="width:180px;height:22px;border-radius:8px;background:${previewLight};border:1px solid rgba(0,0,0,0.06);"></div>
                </div>
                <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
                    <span style="font-size:12px;color:var(--tm-secondary-text);">预览(夜间):</span>
                    <div id="tmAppearancePreviewDark" style="width:180px;height:22px;border-radius:8px;background:${previewDark};border:1px solid rgba(0,0,0,0.06);"></div>
                </div>
                <div style="flex:1;"></div>
                <button class="tm-btn tm-btn-gray" onclick="tmResetAppearanceColors()" style="padding: 4px 10px; font-size: 12px;">恢复默认</button>
            </div>
            <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;padding:8px 10px;border:1px solid var(--tm-border-color);border-radius:10px;background:var(--tm-card-bg);margin-bottom:12px;">
                <span style="font-size:12px;color:var(--tm-secondary-text);">分组内任务行背景使用分组色</span>
                <input type="checkbox" ${d.enableGroupTaskBgByGroupColor ? 'checked' : ''} onchange="tmToggleGroupTaskBgByGroupColor(this.checked)">
            </label>
            <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px;">
                ${cards}
            </div>
            <div style="margin-top:10px;font-size:12px;color:var(--tm-secondary-text);line-height:1.5;">
                按时间分组的分组名称会根据“距离今天的天数”自动变淡，已过期固定使用“已过期颜色”，以保证可读性并适配夜间模式。
            </div>
        `;
    }

    window.tmOpenAppearanceColorPicker = function(el) {
        const btn = el && el.nodeType === 1 ? el : null;
        const k = String(btn?.dataset?.tmColorKey || '').trim();
        const label = String(btn?.dataset?.tmColorLabel || '选择颜色').trim() || '选择颜色';
        if (!k) return;
        const defaults = {
            topbarGradientLightStart: '#667eea',
            topbarGradientLightEnd: '#764ba2',
            topbarGradientDarkStart: '#3b49b7',
            topbarGradientDarkEnd: '#5b2d7a',
            topbarTextColorLight: '#ffffff',
            topbarTextColorDark: '#ffffff',
            taskContentColorLight: '#333333',
            taskContentColorDark: '#e0e0e0',
            groupDocLabelColorLight: '#333333',
            groupDocLabelColorDark: '#e0e0e0',
            timeGroupBaseColorLight: '#1a73e8',
            timeGroupBaseColorDark: '#6ba5ff',
            timeGroupOverdueColorLight: '#d93025',
            timeGroupOverdueColorDark: '#ff6b6b',
            progressBarColorLight: '#4caf50',
            progressBarColorDark: '#81c784',
            tableBorderColorLight: '#e9ecef',
            tableBorderColorDark: '#333333'
        };
        const initial = __tmNormalizeHexColor(SettingsStore.data[k], defaults[k] || '#f44336') || (defaults[k] || '#f44336');
        __tmOpenColorPickerDialog(label, initial, (next) => {
            tmUpdateAppearanceColor(k, next);
        }, { defaultColor: defaults[k] || '#f44336' });
    };

    window.tmUpdateAppearanceColor = async function(key, value) {
        const allowed = new Set([
            'topbarGradientLightStart', 'topbarGradientLightEnd', 'topbarGradientDarkStart', 'topbarGradientDarkEnd',
            'topbarTextColorLight', 'topbarTextColorDark',
            'taskContentColorLight', 'taskContentColorDark',
            'groupDocLabelColorLight', 'groupDocLabelColorDark',
            'timeGroupBaseColorLight', 'timeGroupBaseColorDark',
            'timeGroupOverdueColorLight', 'timeGroupOverdueColorDark',
            'progressBarColorLight', 'progressBarColorDark',
            'tableBorderColorLight', 'tableBorderColorDark'
        ]);
        const k = String(key || '').trim();
        if (!allowed.has(k)) return;
        const v = __tmNormalizeHexColor(value, '');
        if (!v) return;
        SettingsStore.data[k] = v;
        await SettingsStore.save();
        try { __tmApplyAppearanceThemeVars(); } catch (e) {}
        try {
            const buttons = Array.from(document.querySelectorAll(`[data-tm-color-key="${k}"]`));
            buttons.forEach((b) => {
                const sw = b.querySelector?.('.tm-color-swatch');
                const tx = b.querySelector?.('.tm-color-text');
                try { if (sw) sw.style.background = v; } catch (e) {}
                try { if (tx) tx.textContent = String(v || '').toUpperCase(); } catch (e) {}
            });
        } catch (e) {}
        try {
            const d = SettingsStore.data || {};
            const p1 = document.getElementById('tmAppearancePreviewLight');
            const p2 = document.getElementById('tmAppearancePreviewDark');
            const previewLight = `linear-gradient(135deg, ${__tmNormalizeHexColor(d.topbarGradientLightStart, '#667eea') || '#667eea'} 0%, ${__tmNormalizeHexColor(d.topbarGradientLightEnd, '#764ba2') || '#764ba2'} 100%)`;
            const previewDark = `linear-gradient(135deg, ${__tmNormalizeHexColor(d.topbarGradientDarkStart, '#3b49b7') || '#3b49b7'} 0%, ${__tmNormalizeHexColor(d.topbarGradientDarkEnd, '#5b2d7a') || '#5b2d7a'} 100%)`;
            if (p1) p1.style.background = previewLight;
            if (p2) p2.style.background = previewDark;
        } catch (e) {}
        render();
    };

    window.updateKanbanDragSyncSubtasks = async function(enabled) {
        SettingsStore.data.kanbanDragSyncSubtasks = !!enabled;
        await SettingsStore.save();
        render();
    };

    window.tmToggleGroupTaskBgByGroupColor = async function(enabled) {
        SettingsStore.data.enableGroupTaskBgByGroupColor = !!enabled;
        await SettingsStore.save();
        render();
    };

    window.tmToggleTimelineForceSortByCompletionNearToday = async function(enabled) {
        SettingsStore.data.timelineForceSortByCompletionNearToday = !!enabled;
        await SettingsStore.save();
        render();
    };

    window.tmResetAppearanceColors = async function() {
        SettingsStore.data.topbarGradientLightStart = '#667eea';
        SettingsStore.data.topbarGradientLightEnd = '#764ba2';
        SettingsStore.data.topbarGradientDarkStart = '#3b49b7';
        SettingsStore.data.topbarGradientDarkEnd = '#5b2d7a';
        SettingsStore.data.topbarTextColorLight = '#ffffff';
        SettingsStore.data.topbarTextColorDark = '#ffffff';
        SettingsStore.data.taskContentColorLight = '#333333';
        SettingsStore.data.taskContentColorDark = '#e0e0e0';
        SettingsStore.data.groupDocLabelColorLight = '#333333';
        SettingsStore.data.groupDocLabelColorDark = '#e0e0e0';
        SettingsStore.data.timeGroupBaseColorLight = '#1a73e8';
        SettingsStore.data.timeGroupBaseColorDark = '#6ba5ff';
        SettingsStore.data.timeGroupOverdueColorLight = '#d93025';
        SettingsStore.data.timeGroupOverdueColorDark = '#ff6b6b';
        SettingsStore.data.progressBarColorLight = '#4caf50';
        SettingsStore.data.progressBarColorDark = '#81c784';
        SettingsStore.data.tableBorderColorLight = '#e9ecef';
        SettingsStore.data.tableBorderColorDark = '#333333';
        await SettingsStore.save();
        try { __tmApplyAppearanceThemeVars(); } catch (e) {}
        showSettings();
        render();
    };

    window.toggleColumn = function(key, show) {
        let order = SettingsStore.data.columnOrder || [];
        if (show) {
            if (!order.includes(key)) {
                order.push(key);
            }
        } else {
            order = order.filter(k => k !== key);
        }
        SettingsStore.data.columnOrder = order;
        SettingsStore.save();
        showSettings(); 
        render(); 
    };

    window.moveColumn = function(key, direction) {
        let order = [...(SettingsStore.data.columnOrder || [])];
        const idx = order.indexOf(key);
        if (idx === -1) return;
        
        const newIdx = idx + direction;
        if (newIdx < 0 || newIdx >= order.length) return;
        
        [order[idx], order[newIdx]] = [order[newIdx], order[idx]];
        
        SettingsStore.data.columnOrder = order;
        SettingsStore.save();
        showSettings();
        render();
    };

    // ============ 状态选项管理 ============
    window.renderStatusOptionsList = function() {
        const options = SettingsStore.data.customStatusOptions || [];
        return options.map((opt, index) => `
            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 6px; flex-wrap: wrap;">
                <input type="color" value="${opt.color}" onchange="updateStatusOption(${index}, 'color', this.value)" style="width: 24px; height: 24px; border: none; padding: 0; background: none; cursor: pointer;" title="点击修改颜色">
                <input type="text" value="${opt.name}" onchange="updateStatusOption(${index}, 'name', this.value)" style="width: 100px; padding: 4px; border: 1px solid var(--tm-input-border); background: var(--tm-input-bg); color: var(--tm-text-color); border-radius: 4px; font-size: 13px;" title="修改名称">
                <input type="text" value="${opt.id}" onchange="updateStatusOption(${index}, 'id', this.value)" style="width: 120px; padding: 4px; border: 1px solid var(--tm-input-border); background: var(--tm-input-bg); color: var(--tm-text-color); border-radius: 4px; font-size: 12px; font-family: monospace;" title="修改ID（将同步更新任务状态）">
                <div style="display: flex; gap: 2px;">
                    <button class="tm-btn" onclick="moveStatusOption(${index}, -1)" ${index === 0 ? 'disabled' : ''} style="padding: 2px 6px; font-size: 11px;">↑</button>
                    <button class="tm-btn" onclick="moveStatusOption(${index}, 1)" ${index === options.length - 1 ? 'disabled' : ''} style="padding: 2px 6px; font-size: 11px;">↓</button>
                </div>
                <button class="tm-btn tm-btn-danger" onclick="deleteStatusOption(${index})" style="padding: 2px 6px; font-size: 11px;">删除</button>
            </div>
        `).join('');
    };

    window.addStatusOption = async function() {
        const id = await showPrompt('添加状态', '请输入状态ID (唯一标识, 如: waiting)', 'waiting_' + Date.now().toString().slice(-4));
        if (!id) return;
        
        const options = SettingsStore.data.customStatusOptions || [];
        if (options.some(o => o.id === id)) {
            hint('ID已存在，请使用其他ID', 'warning');
            return;
        }

        const name = await showPrompt('添加状态', '请输入显示名称', '新状态');
        if (!name) return;
        
        const color = await showPrompt('添加状态', '请输入颜色代码 (如: #FF0000)', '#66ccff');
        if (!color) return;

        options.push({ id, name, color });
        SettingsStore.data.customStatusOptions = options;
        await SettingsStore.save();
        showSettings();
        render();
        try { window.tmQuickAddRefreshStatusSelect?.(); } catch (e) {}
        try { window.tmQuickAddRenderMeta?.(); } catch (e) {}
    };

    // 绑定添加规则函数
    window.tmAddRule = function() {
        // 创建一个新规则模板
        state.editingRule = {
            id: 'r_' + Date.now(),
            name: '新规则',
            conditions: [{
                id: 'c_' + Date.now(),
                field: 'content',
                operator: 'contains',
                value: ''
            }]
        };
        state.settingsActiveTab = 'rule_editor';
        showSettings();
    };

    // 绑定编辑规则函数
    window.tmEditRule = function(ruleId) {
        const rule = state.filterRules.find(r => r.id === ruleId);
        if (!rule) return;
        
        // 克隆规则对象，避免直接修改
        state.editingRule = JSON.parse(JSON.stringify(rule));
        state.settingsActiveTab = 'rule_editor';
        showSettings();
    };

    // 绑定关闭规则编辑器函数
    window.tmCloseRuleEditor = function() {
        state.editingRule = null;
        state.settingsActiveTab = 'rules';
        showSettings();
    };
    
    // 绑定规则保存函数
    window.tmSaveRule = async function() {
        if (!state.editingRule) return;
        const nameInput = document.getElementById('tmRuleName');
        const name = nameInput ? nameInput.value.trim() : '';
        if (!name) {
            hint('请输入规则名称', 'warning');
            return;
        }
        
        // 获取所有条件
        const conditionRows = document.querySelectorAll('.tm-rule-condition-row');
        const conditions = [];
        conditionRows.forEach(row => {
            const field = row.querySelector('.tm-rule-field').value;
            const operator = row.querySelector('.tm-rule-operator').value;
            let value = '';
            
            // 根据字段类型获取值
            if (field === 'priority' || field === 'customStatus') {
                // 多选
                const checkboxes = row.querySelectorAll('input[type="checkbox"]:checked');
                const values = Array.from(checkboxes).map(cb => cb.value);
                if (values.length > 0) value = values;
            } else if (field === 'done') {
                value = row.querySelector('.tm-rule-value').value;
            } else {
                value = row.querySelector('.tm-rule-value').value;
            }
            
            // 简单校验
            if (value === '' || (Array.isArray(value) && value.length === 0)) return;
            
            conditions.push({
                id: 'c_' + Date.now() + Math.random().toString(36).slice(2),
                field,
                operator,
                value
            });
        });
        
        // 更新规则
        state.editingRule.name = name;
        state.editingRule.conditions = conditions;
        
        // 如果是新规则，添加到列表
        const existing = state.filterRules.find(r => r.id === state.editingRule.id);
        if (!existing) {
            state.filterRules.push(state.editingRule);
        } else {
            // 更新现有规则（对象引用已更新，只需确保在列表中）
            const idx = state.filterRules.findIndex(r => r.id === state.editingRule.id);
            if (idx !== -1) state.filterRules[idx] = state.editingRule;
        }
        
        // 保存到设置
        SettingsStore.data.filterRules = state.filterRules;
        await SettingsStore.save();
        
        // 关闭编辑器并刷新
        tmCloseRuleEditor();
        showSettings();
        render(); // 如果当前应用了该规则，需要刷新主界面
    };

    function __tmRemapStatusId(oldId, newId) {
        if (!oldId || !newId || oldId === newId) return;

        // 更新当前内存中的任务状态
        try {
            Object.values(state.flatTasks || {}).forEach(t => {
                if (t && t.customStatus === oldId) t.customStatus = newId;
            });
        } catch (e) {}

        // 更新 MetaStore 中的状态值
        try {
            if (MetaStore?.data && typeof MetaStore.data === 'object') {
                Object.keys(MetaStore.data).forEach(taskId => {
                    const meta = MetaStore.data[taskId];
                    if (meta && meta.customStatus === oldId) {
                        MetaStore.data[taskId] = { ...meta, customStatus: newId };
                    }
                });
                if (typeof MetaStore.scheduleSave === 'function') MetaStore.scheduleSave();
            }
        } catch (e) {}

        // 更新规则里引用的状态值
        const patchRules = (rules) => {
            if (!Array.isArray(rules)) return;
            rules.forEach(rule => {
                if (!Array.isArray(rule.conditions)) return;
                rule.conditions.forEach(c => {
                    if (c?.field !== 'customStatus') return;
                    if (Array.isArray(c.value)) {
                        c.value = c.value.map(v => (v === oldId ? newId : v));
                    } else if (c.value === oldId) {
                        c.value = newId;
                    }
                });
            });
        };
        try {
            patchRules(state.filterRules);
            patchRules(SettingsStore.data.filterRules);
        } catch (e) {}
    }

    window.updateStatusOption = async function(index, field, value) {
        const options = SettingsStore.data.customStatusOptions || [];
        if (!options[index]) return;

        if (field === 'id') {
            const nextId = String(value || '').trim();
            if (!nextId) {
                hint('ID 不能为空', 'warning');
                showSettings();
                return;
            }
            if (options.some((o, i) => i !== index && o.id === nextId)) {
                hint('ID 已存在，请使用其他ID', 'warning');
                showSettings();
                return;
            }
            const prevId = options[index].id;
            options[index].id = nextId;
            SettingsStore.data.customStatusOptions = options;
            __tmRemapStatusId(prevId, nextId);
            await SettingsStore.save();
            showSettings();
            render();
            try { window.tmQuickAddRefreshStatusSelect?.(); } catch (e) {}
            try { window.tmQuickAddRenderMeta?.(); } catch (e) {}
            return;
        }

        options[index][field] = value;
        SettingsStore.data.customStatusOptions = options;
        await SettingsStore.save();
        // 不刷新整个界面，以免输入焦点丢失
        render(); // 刷新主界面
        try { window.tmQuickAddRefreshStatusSelect?.(); } catch (e) {}
        try { window.tmQuickAddRenderMeta?.(); } catch (e) {}
    };

    window.moveStatusOption = async function(index, direction) {
        const options = [...(SettingsStore.data.customStatusOptions || [])];
        const newIndex = index + direction;
        if (newIndex < 0 || newIndex >= options.length) return;
        [options[index], options[newIndex]] = [options[newIndex], options[index]];
        SettingsStore.data.customStatusOptions = options;
        await SettingsStore.save();
        showSettings();
        render();
        try { window.tmQuickAddRefreshStatusSelect?.(); } catch (e) {}
        try { window.tmQuickAddRenderMeta?.(); } catch (e) {}
    };

    window.deleteStatusOption = async function(index) {
        const ok = await showConfirm('删除状态', '确定删除此状态吗？');
        if (!ok) return;
        const options = SettingsStore.data.customStatusOptions || [];
        options.splice(index, 1);
        SettingsStore.data.customStatusOptions = options;
        await SettingsStore.save();
        showSettings(); // 刷新界面
        render(); // 刷新主界面
        try { window.tmQuickAddRefreshStatusSelect?.(); } catch (e) {}
        try { window.tmQuickAddRenderMeta?.(); } catch (e) {}
    };

    // 更新列宽度
    window.updateColumnWidth = function(column, width) {
        if (!state.columnWidths) state.columnWidths = {};
        state.columnWidths[column] = width;
        SettingsStore.data.columnWidths = state.columnWidths;
        SettingsStore.save();
        render();
        // 更新设置界面的显示
        if (state.settingsModal) {
            const widthSettings = state.settingsModal.querySelector('.tm-width-settings');
            if (widthSettings) {
                widthSettings.innerHTML = renderColumnWidthSettings();
            }
        }
    };

    // 新增：切换分组
    window.switchDocGroup = async function(groupId) {
        await SettingsStore.updateCurrentGroupId(groupId);
        state.activeDocId = 'all';
        const firstRuleId = (state.filterRules || []).find(r => r && r.enabled)?.id || '';
        state.currentRule = firstRuleId || null;
        SettingsStore.data.currentRule = firstRuleId || null;
        await SettingsStore.save();
        await loadSelectedDocuments();
        render();
        showSettings();
    };

    // 新增：创建分组
    window.createNewGroup = async function() {
        const name = await showPrompt('新建分组', '请输入分组名称', '新分组');
        if (!name) return;
        
        const newGroup = {
            id: 'g_' + Date.now(),
            name: name,
            docs: []
        };
        
        const groups = SettingsStore.data.docGroups || [];
        groups.push(newGroup);
        await SettingsStore.updateDocGroups(groups);
        await SettingsStore.updateCurrentGroupId(newGroup.id);
        showSettings();
    };

    // 新增：删除当前分组
    window.deleteCurrentGroup = async function() {
        if (!confirm('确定要删除当前分组吗？')) return;
        
        const currentId = SettingsStore.data.currentGroupId;
        let groups = SettingsStore.data.docGroups || [];
        groups = groups.filter(g => g.id !== currentId);
        try {
            const pinMap = (SettingsStore.data.docPinnedByGroup && typeof SettingsStore.data.docPinnedByGroup === 'object')
                ? SettingsStore.data.docPinnedByGroup
                : {};
            if (Object.prototype.hasOwnProperty.call(pinMap, currentId)) {
                delete pinMap[currentId];
                SettingsStore.data.docPinnedByGroup = pinMap;
            }
        } catch (e) {}
        
        await SettingsStore.updateDocGroups(groups);
        await SettingsStore.updateCurrentGroupId('all');
        showSettings();
    };

    function __tmSummaryDateFmt(d) {
        if (!(d instanceof Date) || Number.isNaN(d.getTime())) return '';
        const pad = (n) => String(n).padStart(2, '0');
        return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
    }

    function __tmSummaryRangeFromPreset(preset) {
        const p = String(preset || '').trim();
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        if (p === 'today') {
            const s = __tmSummaryDateFmt(today);
            return { start: s, end: s };
        }
        if (p === 'this_week') {
            const day = (today.getDay() + 6) % 7;
            const s = new Date(today.getTime() - day * 86400000);
            const e = new Date(s.getTime() + 6 * 86400000);
            return { start: __tmSummaryDateFmt(s), end: __tmSummaryDateFmt(e) };
        }
        if (p === 'this_month') {
            const s = new Date(today.getFullYear(), today.getMonth(), 1);
            const e = new Date(today.getFullYear(), today.getMonth() + 1, 0);
            return { start: __tmSummaryDateFmt(s), end: __tmSummaryDateFmt(e) };
        }
        if (p === 'last_month') {
            const s = new Date(today.getFullYear(), today.getMonth() - 1, 1);
            const e = new Date(today.getFullYear(), today.getMonth(), 0);
            return { start: __tmSummaryDateFmt(s), end: __tmSummaryDateFmt(e) };
        }
        return { start: '', end: '' };
    }

    async function __tmBuildSummaryDocToGroupMap() {
        const groups = Array.isArray(SettingsStore.data.docGroups) ? SettingsStore.data.docGroups : [];
        const parts = [];
        for (const g of groups) {
            const gid = String(g?.id || '').trim();
            if (!gid) continue;
            const docs = Array.isArray(g?.docs) ? g.docs : [];
            const ds = docs.map((d) => {
                const did = String((typeof d === 'object' ? d?.id : d) || '').trim();
                const rec = !!(typeof d === 'object' && d && d.recursive);
                if (!did) return '';
                return did + (rec ? '*' : '');
            }).filter(Boolean);
            parts.push(`${gid}:${ds.join(',')}`);
        }
        const key = parts.join('|');
        const prev = window.__tmSummaryDocToGroupCache;
        if (prev && prev.key === key && prev.map instanceof Map) return prev.map;

        const map = new Map();
        for (const g of groups) {
            const gid = String(g?.id || '').trim();
            if (!gid) continue;
            const docs = Array.isArray(g?.docs) ? g.docs : [];
            for (const d of docs) {
                const did = String((typeof d === 'object' ? d?.id : d) || '').trim();
                const rec = !!(typeof d === 'object' && d && d.recursive);
                if (!did) continue;
                if (!map.has(did)) map.set(did, gid);
                if (rec && API && typeof API.getSubDocIds === 'function') {
                    try {
                        const subs = await API.getSubDocIds(did);
                        (Array.isArray(subs) ? subs : []).forEach((sid) => {
                            const s = String(sid || '').trim();
                            if (!s) return;
                            if (!map.has(s)) map.set(s, gid);
                        });
                    } catch (e) {}
                }
            }
        }
        window.__tmSummaryDocToGroupCache = { key, map };
        return map;
    }

    function __tmSummaryStatusName(task, statusMap) {
        if (task?.done) return '已完成';
        const sid = String(task?.customStatus || '').trim() || 'todo';
        return statusMap.get(sid) || sid || '未完成';
    }

    function __tmSummaryPriorityText(priority) {
        const p = String(priority || '').trim();
        if (p === 'high') return '高';
        if (p === 'medium') return '中';
        if (p === 'low') return '低';
        return '无';
    }

    function __tmSummaryDateKeyFromTs(ts) {
        const n = Number(ts);
        if (!Number.isFinite(n) || n <= 0) return '';
        const d = new Date(n);
        if (Number.isNaN(d.getTime())) return '';
        const pad = (x) => String(x).padStart(2, '0');
        return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
    }

    function __tmSummaryTaskDate(task) {
        const ts = __tmParseTimeToTs(task?.updated || '');
        return __tmSummaryDateKeyFromTs(ts);
    }

    async function __tmSummaryResolveAllDocIds() {
        const groups = Array.isArray(SettingsStore.data.docGroups) ? SettingsStore.data.docGroups : [];
        const set = new Set();
        for (const g of groups) {
            const docs = Array.isArray(g?.docs) ? g.docs : [];
            for (const d of docs) {
                const did = String((typeof d === 'object' ? d?.id : d) || '').trim();
                const rec = !!(typeof d === 'object' && d && d.recursive);
                if (!did) continue;
                set.add(did);
                if (rec && API && typeof API.getSubDocIds === 'function') {
                    try {
                        const subIds = await API.getSubDocIds(did);
                        (Array.isArray(subIds) ? subIds : []).forEach((sid) => {
                            const s = String(sid || '').trim();
                            if (s) set.add(s);
                        });
                    } catch (e) {}
                }
            }
        }
        if (set.size === 0) {
            Object.values(state.flatTasks || {}).forEach((t) => {
                const docId = String(t?.docId || t?.root_id || '').trim();
                if (docId) set.add(docId);
            });
        }
        return Array.from(set);
    }

    async function __tmSummaryLoadTasksByDocs(docIds) {
        const ids = Array.isArray(docIds) ? docIds.map(x => String(x || '').trim()).filter(Boolean) : [];
        if (!ids.length) return [];
        const limit = Math.max(2000, Number(SettingsStore.data.queryLimit) || 5000);
        let list = [];
        try {
            const res = await API.getTasksByDocuments(ids, limit, { doneOnly: false });
            list = Array.isArray(res?.tasks) ? res.tasks : [];
        } catch (e) {
            list = [];
        }
        let h2Map = new Map();
        try {
            h2Map = await API.fetchH2Contexts(list.map(t => t?.id).filter(Boolean));
        } catch (e) {
            h2Map = new Map();
        }
        return list.map((task) => {
            if (!task || typeof task !== 'object') return null;
            const t = { ...task };
            let parsedDone = !!t.done;
            try {
                const parsed = API.parseTaskStatus(t.markdown);
                parsedDone = !!parsed.done;
                t.done = parsedDone;
                t.content = parsed.content;
            } catch (e) {}
            try { MetaStore.applyToTask?.(t); } catch (e) {}
            t.done = parsedDone;
            const docName = String(t.docName || '未命名文档');
            try { normalizeTaskFields(t, docName); } catch (e) {}
            const h2ctx = h2Map.get(t.id);
            if (h2ctx && typeof h2ctx === 'object') {
                t.h2 = String(h2ctx.content || '').trim();
                t.h2Id = String(h2ctx.id || '').trim();
            }
            return t;
        }).filter(Boolean);
    }

    function __tmSummaryCollectTasks(ctx, filter) {
        const out = [];
        const arr = Array.isArray(ctx.summaryTasks) ? ctx.summaryTasks : [];
        const docNameMap = ctx.docNameMap || {};
        const docToGroup = ctx.docToGroup || new Map();
        const f = filter || {};
        const start = String(f.start || '').trim();
        const end = String(f.end || '').trim();
        const status = String(f.status || '__all__').trim();
        const priority = String(f.priority || '__all__').trim();
        const groupId = String(f.groupId || '__all__').trim();
        const docIdFilter = String(f.docId || '__all__').trim();
        const idMap = new Map();
        const levelMemo = new Map();

        arr.forEach((t) => {
            const id = String(t?.id || '').trim();
            if (id) idMap.set(id, t);
        });

        const resolveLevel = (task) => {
            const id = String(task?.id || '').trim();
            if (!id) return 0;
            if (levelMemo.has(id)) return levelMemo.get(id);
            const seen = new Set([id]);
            let level = 0;
            let pid = String(task?.parentTaskId || '').trim();
            while (pid && !seen.has(pid)) {
                seen.add(pid);
                const parent = idMap.get(pid);
                if (!parent) break;
                level += 1;
                pid = String(parent?.parentTaskId || '').trim();
            }
            levelMemo.set(id, level);
            return level;
        };

        arr.forEach((task) => {
            if (!task || !task.id) return;
            const docId = String(task.docId || task.root_id || '').trim();
            if (!docId) return;
            if (docIdFilter !== '__all__' && docId !== docIdFilter) return;
            const gid = String(docToGroup.get(docId) || '').trim();
            if (groupId === '__ungrouped__') {
                if (gid) return;
            } else if (groupId !== '__all__' && gid !== groupId) {
                return;
            }

            const dateKey = __tmSummaryTaskDate(task);
            if (start && (!dateKey || dateKey < start)) return;
            if (end && (!dateKey || dateKey > end)) return;

            if (status === '__done__' && !task.done) return;
            if (status === '__undone__' && task.done) return;
            if (status !== '__all__' && status !== '__done__' && status !== '__undone__') {
                const sid = String(task.customStatus || '').trim() || 'todo';
                if (status === 'done') {
                    if (!task.done && sid !== 'done') return;
                } else if (sid !== status) return;
            }

            const p = String(task.priority || '').trim() || 'none';
            if (priority !== '__all__' && p !== priority) return;

            out.push({
                id: String(task.id || '').trim(),
                content: String(task.content || '').trim() || '无内容',
                done: !!task.done,
                customStatus: String(task.customStatus || '').trim() || 'todo',
                priority: p,
                dateKey,
                docId,
                docName: String(docNameMap[docId] || task.docName || '未命名文档'),
                h2Id: String(task.h2Id || '').trim(),
                h2Name: String(task.h2 || task.h2Name || '').trim() || '无二级标题',
                level: resolveLevel(task),
            });
        });

        out.sort((a, b) => {
            const da = String(a.dateKey || '');
            const db = String(b.dateKey || '');
            if (da !== db) return da < db ? -1 : 1;
            return String(a.content || '').localeCompare(String(b.content || ''), 'zh-Hans-CN');
        });
        return out;
    }

    function __tmSummaryGenerateMarkdown(tasks, filter, ctx) {
        const lines = [];
        const now = new Date().toISOString().replace('T', ' ').slice(0, 19);
        const statusMap = ctx.statusMap || new Map();
        const groupName = ctx.groupNameMap?.[String(filter.groupId || '__all__')] || '全部分组';
        const docName = filter.docId === '__all__'
            ? (filter.groupId && filter.groupId !== '__all__' ? '当前分区全部文档' : '全部分区内文档')
            : (ctx.docNameMap?.[String(filter.docId || '')] || '指定文档');
        const statusName = String(filter.status || '__all__') === '__all__'
            ? '全部状态'
            : (String(filter.status) === '__done__' ? '已完成' : (String(filter.status) === '__undone__' ? '未完成' : (statusMap.get(String(filter.status || '')) || String(filter.status || ''))));
        const priorityName = String(filter.priority || '__all__') === '__all__' ? '全部优先级' : __tmSummaryPriorityText(filter.priority);
        const groupBy = String(filter.groupBy || 'status').trim() || 'status';
        const groupByName = groupBy === 'h2'
            ? '按二级标题'
            : (groupBy === 'priority' ? '按重要性' : (groupBy === 'doc' ? '按文档' : '按状态'));
        const fields = (filter.fields && typeof filter.fields === 'object') ? filter.fields : {};
        const showTaskName = fields.taskName !== false;
        const showDocName = fields.docName !== false;
        const showPriority = fields.priority !== false;
        const showStatus = fields.status !== false;
        const showDate = fields.date !== false;
        const rangeLabel = (filter.start || filter.end)
            ? `${filter.start || '最早'} ~ ${filter.end || '最晚'}`
            : '全部时间';

        lines.push('# 任务摘要');
        lines.push('');
        lines.push(`> 生成时间：${now}`);
        lines.push(`> 筛选：${rangeLabel} | ${groupName} | ${docName} | ${statusName} | ${priorityName} | ${groupByName}`);
        lines.push('');

        if (!tasks.length) {
            lines.push('> 没有匹配到任务。');
            return lines.join('\n');
        }

        const sectionMap = new Map();
        const sectionLabel = (t) => {
            if (groupBy === 'h2') return String(t.h2Name || '无二级标题');
            if (groupBy === 'priority') return `重要性：${__tmSummaryPriorityText(t.priority)}`;
            if (groupBy === 'doc') return String(t.docName || '未命名文档');
            return __tmSummaryStatusName(t, statusMap);
        };
        tasks.forEach((t) => {
            const key = sectionLabel(t);
            if (!sectionMap.has(key)) sectionMap.set(key, []);
            sectionMap.get(key).push(t);
        });

        const sectionOrder = Array.from(sectionMap.keys()).sort((a, b) => String(a).localeCompare(String(b), 'zh-Hans-CN'));
        sectionOrder.forEach((name) => {
            const arr = sectionMap.get(name) || [];
            lines.push(`## ${name}（${arr.length}）`);
            lines.push('');
            arr.forEach((t) => {
                const d = (showDate && t.dateKey) ? `[${t.dateKey}] ` : '';
                const pr = __tmSummaryPriorityText(t.priority);
                const checkbox = t.done ? '[x]' : '[ ]';
                const body = showTaskName ? t.content : '(任务)';
                const ext = [];
                const level = Math.max(0, Number(t.level) || 0);
                const indent = '  '.repeat(level);
                if (showDocName && groupBy !== 'doc') ext.push(t.docName);
                if (showPriority) ext.push(`优先级:${pr}`);
                if (showStatus) ext.push(__tmSummaryStatusName(t, statusMap));
                lines.push(`${indent}- ${checkbox} ${d}${body}${ext.length ? `（${ext.join('｜')}）` : ''}`);
            });
            lines.push('');
        });

        const doneCount = tasks.filter(t => t.done).length;
        lines.push('---');
        lines.push('');
        lines.push(`- 总计：${tasks.length}`);
        lines.push(`- 已完成：${doneCount}`);
        lines.push(`- 未完成：${tasks.length - doneCount}`);
        return lines.join('\n');
    }

    function __tmSummaryReadFilter(root) {
        const q = (sel) => root.querySelector(sel);
        const preset = String(q('[data-tm-summary="preset"]')?.value || 'all').trim();
        const startInput = q('[data-tm-summary="start"]');
        const endInput = q('[data-tm-summary="end"]');
        let start = String(startInput?.value || '').trim();
        let end = String(endInput?.value || '').trim();
        if (preset !== 'custom') {
            const r = __tmSummaryRangeFromPreset(preset);
            start = r.start;
            end = r.end;
            if (startInput) startInput.value = start;
            if (endInput) endInput.value = end;
        }
        return {
            preset,
            start: __tmNormalizeDateOnly(start),
            end: __tmNormalizeDateOnly(end),
            groupId: String(q('[data-tm-summary="group"]')?.value || '__all__').trim(),
            docId: String(q('[data-tm-summary="doc"]')?.value || '__all__').trim(),
            status: String(q('[data-tm-summary="status"]')?.value || '__all__').trim(),
            priority: String(q('[data-tm-summary="priority"]')?.value || '__all__').trim(),
            groupBy: String(q('[data-tm-summary="groupBy"]')?.value || 'status').trim(),
            fields: {
                taskName: q('[data-tm-summary="fieldTaskName"]')?.checked !== false,
                docName: q('[data-tm-summary="fieldDocName"]')?.checked !== false,
                priority: q('[data-tm-summary="fieldPriority"]')?.checked !== false,
                status: q('[data-tm-summary="fieldStatus"]')?.checked !== false,
                date: q('[data-tm-summary="fieldDate"]')?.checked !== false,
            },
        };
    }

    function __tmSummaryRefreshDocOptions(root, ctx) {
        const groupSel = root.querySelector('[data-tm-summary="group"]');
        const docSel = root.querySelector('[data-tm-summary="doc"]');
        if (!groupSel || !docSel) return;
        const prevDoc = String(docSel.value || '__all__').trim();
        const gid = String(groupSel.value || '__all__').trim();
        const docToGroup = ctx.docToGroup || new Map();
        const docTaskCount = (ctx.docTaskCount && typeof ctx.docTaskCount === 'object') ? ctx.docTaskCount : {};
        const allLabel = gid === '__all__' ? '全部分区内文档' : (gid === '__ungrouped__' ? '未分组全部文档' : '当前分区全部文档');
        const options = [{ id: '__all__', name: allLabel }];
        Object.entries(ctx.docNameMap || {}).forEach(([docId, name]) => {
            if (!Number(docTaskCount[String(docId)] || 0)) return;
            const g = String(docToGroup.get(String(docId)) || '').trim();
            if (gid === '__all__' || (gid === '__ungrouped__' ? !g : g === gid)) {
                options.push({ id: String(docId), name: String(name || docId) });
            }
        });
        docSel.innerHTML = options
            .sort((a, b) => String(a.name).localeCompare(String(b.name), 'zh-Hans-CN'))
            .map((it) => `<option value="${esc(it.id)}">${esc(it.name)}</option>`)
            .join('');
        docSel.value = options.some(it => it.id === prevDoc) ? prevDoc : '__all__';
    }

    function __tmSummaryUpdatePreview(root, ctx) {
        const filter = __tmSummaryReadFilter(root);
        const tasks = __tmSummaryCollectTasks(ctx, filter);
        const md = __tmSummaryGenerateMarkdown(tasks, filter, ctx);
        const textarea = root.querySelector('[data-tm-summary="preview"]');
        if (textarea) textarea.value = md;
    }

    function __tmCloseSummaryModal() {
        if (!state.summaryModal) return;
        try { state.summaryModal.remove(); } catch (e) {}
        state.summaryModal = null;
    }

    window.tmShowSummaryModal = async function() {
        try { __tmHideMobileMenu(); } catch (e) {}
        try { document.getElementById('tmDesktopMenu')?.remove?.(); } catch (e) {}
        __tmCloseSummaryModal();

        const docNameMap = {};
        (Array.isArray(state.taskTree) ? state.taskTree : []).forEach((d) => {
            const id = String(d?.id || '').trim();
            if (id) docNameMap[id] = String(d?.name || '').trim() || id;
        });
        (Array.isArray(state.allDocuments) ? state.allDocuments : []).forEach((d) => {
            const id = String(d?.id || '').trim();
            if (id && !docNameMap[id]) docNameMap[id] = String(d?.name || '').trim() || id;
        });
        Object.values(state.flatTasks || {}).forEach((t) => {
            const docId = String(t?.docId || t?.root_id || '').trim();
            if (!docId) return;
            if (!docNameMap[docId]) docNameMap[docId] = String(t?.docName || '').trim() || docId;
        });

        const statusOptions = Array.isArray(SettingsStore.data.customStatusOptions) ? SettingsStore.data.customStatusOptions : [];
        const statusMap = new Map();
        statusOptions.forEach((o) => {
            const id = String(o?.id || '').trim();
            if (!id) return;
            statusMap.set(id, String(o?.name || id));
        });

        const groups = Array.isArray(SettingsStore.data.docGroups) ? SettingsStore.data.docGroups : [];
        const groupNameMap = { '__all__': '全部分组', '__ungrouped__': '未分组' };
        groups.forEach((g) => {
            const gid = String(g?.id || '').trim();
            if (gid) groupNameMap[gid] = String(g?.name || gid);
        });

        const docToGroup = await __tmBuildSummaryDocToGroupMap();
        const allDocIds = await __tmSummaryResolveAllDocIds();
        const summaryTasks = await __tmSummaryLoadTasksByDocs(allDocIds);
        const docTaskCount = {};
        summaryTasks.forEach((t) => {
            const docId = String(t?.docId || t?.root_id || '').trim();
            if (!docId) return;
            docTaskCount[docId] = Number(docTaskCount[docId] || 0) + 1;
            if (!docNameMap[docId]) docNameMap[docId] = String(t?.docName || '').trim() || docId;
        });
        const groupOptions = [
            { id: '__all__', name: '全部分组' },
            ...groups.map((g) => ({ id: String(g?.id || '').trim(), name: String(g?.name || '').trim() || '未命名分组' })).filter(g => g.id),
            { id: '__ungrouped__', name: '未分组' }
        ];
        const statusSelectOptions = [
            { id: '__all__', name: '全部状态' },
            { id: '__done__', name: '已完成' },
            { id: '__undone__', name: '未完成' },
            ...Array.from(statusMap.keys()).map((id) => ({ id, name: statusMap.get(id) || id }))
        ];

        state.summaryModal = document.createElement('div');
        state.summaryModal.className = 'tm-modal';
        state.summaryModal.style.cssText = 'z-index: 200001;';
        const box = document.createElement('div');
        box.className = 'tm-box';
        box.style.cssText = 'width:min(960px,95vw);height:min(88vh,860px);display:flex;flex-direction:column;';
        box.innerHTML = `
            <div class="tm-header" style="padding:12px 16px;border-bottom:1px solid var(--tm-border-color);">
                <div style="font-size:16px;font-weight:600;">📝 任务摘要</div>
                <button class="tm-btn tm-btn-gray" data-tm-summary-action="close" style="padding:4px 8px;font-size:12px;">✕</button>
            </div>
            <div class="tm-body" style="padding:12px 16px;display:flex;flex-direction:column;gap:10px;overflow:auto;">
                <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
                    <select class="tm-rule-select" data-tm-summary="preset" style="min-width:110px;">
                        <option value="all">全部时间</option>
                        <option value="today">今天</option>
                        <option value="this_week" selected>本周</option>
                        <option value="this_month">本月</option>
                        <option value="last_month">上月</option>
                        <option value="custom">自定义</option>
                    </select>
                    <input class="tm-input" type="date" data-tm-summary="start" style="width:140px;">
                    <span style="color:var(--tm-secondary-text);">~</span>
                    <input class="tm-input" type="date" data-tm-summary="end" style="width:140px;">
                    <select class="tm-rule-select" data-tm-summary="group" style="min-width:140px;">
                        ${groupOptions.map(g => `<option value="${esc(g.id)}">${esc(g.name)}</option>`).join('')}
                    </select>
                    <select class="tm-rule-select" data-tm-summary="doc" style="min-width:160px;"></select>
                    <select class="tm-rule-select" data-tm-summary="status" style="min-width:130px;">
                        ${statusSelectOptions.map(s => `<option value="${esc(s.id)}">${esc(s.name)}</option>`).join('')}
                    </select>
                    <select class="tm-rule-select" data-tm-summary="priority" style="min-width:120px;">
                        <option value="__all__">全部重要性</option>
                        <option value="high">高</option>
                        <option value="medium">中</option>
                        <option value="low">低</option>
                        <option value="none">无</option>
                    </select>
                    <select class="tm-rule-select" data-tm-summary="groupBy" style="min-width:130px;">
                        <option value="status">按状态分组</option>
                        <option value="priority">按重要性分组</option>
                        <option value="doc">按文档分组</option>
                        <option value="h2">按二级标题分组</option>
                    </select>
                </div>
                <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;color:var(--tm-secondary-text);font-size:12px;">
                    <span>显示字段:</span>
                    <label style="display:inline-flex;align-items:center;gap:4px;"><input type="checkbox" data-tm-summary="fieldTaskName" checked>任务名称</label>
                    <label style="display:inline-flex;align-items:center;gap:4px;"><input type="checkbox" data-tm-summary="fieldDocName">文档名称</label>
                    <label style="display:inline-flex;align-items:center;gap:4px;"><input type="checkbox" data-tm-summary="fieldPriority">优先级</label>
                    <label style="display:inline-flex;align-items:center;gap:4px;"><input type="checkbox" data-tm-summary="fieldStatus">状态</label>
                    <label style="display:inline-flex;align-items:center;gap:4px;"><input type="checkbox" data-tm-summary="fieldDate">日期</label>
                </div>
                <textarea data-tm-summary="preview" style="width:100%;height:100%;min-height:420px;box-sizing:border-box;padding:12px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:13px;line-height:1.55;background:var(--tm-input-bg);color:var(--tm-text-color);border:1px solid var(--tm-input-border);border-radius:8px;resize:vertical;"></textarea>
            </div>
            <div class="tm-header" style="padding:12px 16px;border-top:1px solid var(--tm-border-color);justify-content:flex-end;gap:10px;">
                <button class="tm-btn tm-btn-secondary" data-tm-summary-action="refresh" style="padding:8px 16px;">生成</button>
                <button class="tm-btn tm-btn-primary" data-tm-summary-action="copy" style="padding:8px 16px;">复制</button>
            </div>
        `;
        state.summaryModal.appendChild(box);
        document.body.appendChild(state.summaryModal);

        const root = state.summaryModal;
        const ctx = { docNameMap, docTaskCount, docToGroup, statusMap, groupNameMap, summaryTasks };
        __tmSummaryRefreshDocOptions(root, ctx);
        __tmSummaryUpdatePreview(root, ctx);

        root.addEventListener('change', (e) => {
            const target = e.target;
            if (!(target instanceof Element)) return;
            const key = String(target.getAttribute('data-tm-summary') || '').trim();
            if (!key) return;
            if (key === 'group') __tmSummaryRefreshDocOptions(root, ctx);
            __tmSummaryUpdatePreview(root, ctx);
        });

        root.addEventListener('click', async (e) => {
            const target = e.target?.closest?.('[data-tm-summary-action]');
            if (!target) return;
            const action = String(target.getAttribute('data-tm-summary-action') || '').trim();
            if (action === 'close') {
                __tmCloseSummaryModal();
                return;
            }
            if (action === 'refresh') {
                __tmSummaryUpdatePreview(root, ctx);
                hint('✅ 已生成摘要', 'success');
                return;
            }
            if (action === 'copy') {
                const text = String(root.querySelector('[data-tm-summary="preview"]')?.value || '');
                if (!text.trim()) {
                    hint('⚠️ 没有可复制内容', 'warning');
                    return;
                }
                let ok = false;
                try {
                    if (navigator?.clipboard?.writeText) {
                        await navigator.clipboard.writeText(text);
                        ok = true;
                    }
                } catch (e2) {}
                if (!ok) {
                    try {
                        const ta = root.querySelector('[data-tm-summary="preview"]');
                        ta?.focus?.();
                        ta?.select?.();
                        ok = document.execCommand('copy');
                    } catch (e2) {}
                }
                hint(ok ? '✅ 已复制摘要 Markdown' : '❌ 复制失败', ok ? 'success' : 'error');
            }
        });
    };

    // 新增：导出当前分组任务
    window.exportCurrentGroup = async function() {
        // 从当前DOM中获取当前选中的分组ID
        const groupSelect = document.getElementById('groupSelector');
        const currentId = groupSelect ? groupSelect.value : (SettingsStore.data.currentGroupId || 'all');
        
        if (currentId === 'all') {
            hint('⚠️ 请先选择一个分组进行导出', 'error');
            return;
        }

        // 直接从 taskTree 获取当前页签显示的所有文档和任务
        // taskTree 包含了分组开启"包含子文档"后解析的所有子文档
        const docNames = {};
        const flatTasks = state.flatTasks || {};

        if (!Array.isArray(state.taskTree) || state.taskTree.length === 0) {
            hint('⚠️ 当前没有显示的文档', 'error');
            return;
        }

        // 遍历 taskTree 中当前显示的所有文档，获取文档名称
        state.taskTree.forEach(doc => {
            const docId = String(doc?.id || '').trim();
            if (!docId) return;
            docNames[docId] = doc.name || '未命名文档';
        });

        // 直接从 flatTasks 获取所有任务（包括子任务）
        const tasksByDoc = {};
        
        // 首先获取所有顶级任务（没有 parentTaskId 的）
        Object.values(flatTasks).forEach(task => {
            if (!task || !task.id) return;
            if (task.parentTaskId) return; // 先跳过子任务，稍后处理
            
            const docId = String(task.docId || task.root_id || '').trim();
            if (!docId || !docNames[docId]) return; // 只处理在当前分组的文档
            
            if (!tasksByDoc[docId]) {
                tasksByDoc[docId] = [];
            }
            
            // 添加顶级任务，设置二级标题信息
            const h2Id = task.h2Id || '';
            let h2Name = task.h2 || '';
            if (!h2Name && h2Id) {
                const h2Task = flatTasks[h2Id];
                if (h2Task) h2Name = h2Task.content || '';
            }
            
            tasksByDoc[docId].push({
                ...task,
                h2Id: h2Id,
                h2Name: h2Name,
                level: 0
            });
            
            // 递归收集所有子任务
            const collectChildren = (parentTask, parentH2Id, parentH2Name) => {
                const children = parentTask.children || [];
                children.forEach(child => {
                    if (child && child.id) {
                        // 子任务的h2Id使用父级的
                        tasksByDoc[docId].push({
                            ...child,
                            h2Id: parentH2Id,
                            h2Name: parentH2Name,
                            level: 1
                        });
                        // 递归收集更深层的子任务
                        if (child.children && child.children.length > 0) {
                            collectChildren(child, parentH2Id, parentH2Name);
                        }
                    }
                });
            };
            
            if (task.children && task.children.length > 0) {
                collectChildren(task, h2Id, h2Name);
            }
        });

        // 检查是否有任务
        let totalTasks = 0;
        Object.values(tasksByDoc).forEach(tasks => {
            totalTasks += tasks.length;
        });

        if (totalTasks === 0) {
            hint('⚠️ 当前分组没有任务可导出', 'error');
            return;
        }

        // 获取当前分组名称
        const groups = SettingsStore.data.docGroups || [];
        const group = groups.find(g => g.id === currentId);
        const groupName = group ? group.name : '当前分组';

        // 显示导出设置对话框
        __tmShowExportDialog(groupName, tasksByDoc, docNames);
    };

    // 导出对话框函数
    function __tmShowExportDialog(groupName, tasksByDoc, docNames) {
        // 关闭现有的导出对话框
        if (state.exportModal) {
            try { state.exportModal.remove(); } catch (e) {}
            state.exportModal = null;
        }

        state.exportModal = document.createElement('div');
        state.exportModal.className = 'tm-modal';
        state.exportModal.style.cssText = 'z-index: 200000;';

        const dialog = document.createElement('div');
        dialog.className = 'tm-box';
        dialog.style.cssText = 'width: 480px; max-width: 90vw; height: auto; flex: none;';

        dialog.innerHTML = `
            <div class="tm-header" style="padding: 16px 20px; border-bottom: 1px solid var(--tm-border-color); flex-shrink: 0;">
                <div style="font-size: 16px; font-weight: 600;">导出任务 - ${esc(groupName)}</div>
                <button class="tm-btn tm-btn-gray" data-tm-action="closeExportDialog" style="padding: 4px 8px; font-size: 12px;">✕</button>
            </div>
            <div class="tm-body" style="padding: 20px; flex: 1; overflow-y: auto;">
                <div style="margin-bottom: 16px;">
                    <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px;">导出格式</div>
                    <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; cursor: pointer;">
                        <input type="radio" name="exportFormat" value="markdown" checked>
                        <span style="font-size: 13px;">Markdown (推荐 AI 阅读)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; cursor: pointer;">
                        <input type="radio" name="exportFormat" value="json">
                        <span style="font-size: 13px;">JSON (结构化数据)</span>
                    </label>
                </div>
                <div style="margin-bottom: 16px;">
                    <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px;">文件名</div>
                    <input type="text" id="exportFilename" value="${esc(groupName)}_任务导出" 
                           style="width: 100%; padding: 8px 12px; border: 1px solid var(--tm-input-border); border-radius: 6px; background: var(--tm-input-bg); color: var(--tm-text-color); font-size: 13px; box-sizing: border-box;">
                </div>
                <div style="margin-bottom: 16px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="exportIncludeDone" checked>
                        <span style="font-size: 13px;">包含已完成任务</span>
                    </label>
                </div>
                <div style="font-size: 12px; color: var(--tm-secondary-text);">
                    共 ${Object.keys(tasksByDoc).length} 个文档，${Object.values(tasksByDoc).reduce((sum, tasks) => sum + tasks.length, 0)} 个任务
                </div>
            </div>
            <div class="tm-header" style="padding: 16px 20px; border-top: 1px solid var(--tm-border-color); justify-content: flex-end; gap: 10px; flex-shrink: 0;">
                <button class="tm-btn tm-btn-secondary" data-tm-action="closeExportDialog" style="padding: 8px 16px;">取消</button>
                <button class="tm-btn tm-btn-primary" data-tm-action="confirmExport" style="padding: 8px 16px;">导出</button>
            </div>
        `;

        state.exportModal.appendChild(dialog);
        document.body.appendChild(state.exportModal);

        // 绑定事件
        const root = state.exportModal;
        root.addEventListener('click', async (e) => {
            const target = e.target?.closest?.('[data-tm-action]');
            if (!target) return;

            const action = String(target.dataset.tmAction || '');
            if (action === 'closeExportDialog') {
                try { state.exportModal.remove(); } catch (e) {}
                state.exportModal = null;
            } else if (action === 'confirmExport') {
                const format = document.querySelector('input[name="exportFormat"]:checked')?.value || 'markdown';
                const filename = document.getElementById('exportFilename')?.value || groupName;
                const includeDone = document.getElementById('exportIncludeDone')?.checked !== false;

                // 执行导出
                __tmDoExport(groupName, tasksByDoc, docNames, format, filename, includeDone);

                try { state.exportModal.remove(); } catch (e) {}
                state.exportModal = null;
            }
        });
    }

    // 执行导出
    function __tmDoExport(groupName, tasksByDoc, docNames, format, filename, includeDone) {
        let content = '';
        let mimeType = 'text/plain';
        let extension = 'txt';

        if (format === 'markdown') {
            content = __tmGenerateMarkdownExport(groupName, tasksByDoc, docNames, includeDone);
            mimeType = 'text/markdown';
            extension = 'md';
        } else {
            content = __tmGenerateJSONExport(tasksByDoc, docNames, includeDone);
            mimeType = 'application/json';
            extension = 'json';
        }

        // 下载文件
        const blob = new Blob([content], { type: mimeType + ';charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${filename}.${extension}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        hint('✅ 任务导出成功', 'success');
    }

    // 生成 Markdown 格式导出
    function __tmGenerateMarkdownExport(groupName, tasksByDoc, docNames, includeDone) {
        const lines = [];
        const now = new Date().toISOString().split('T')[0];

        lines.push(`# ${groupName} - 任务导出`);
        lines.push('');
        lines.push(`> 导出时间：${now}`);
        lines.push('');

        // 按文档分组
        Object.entries(tasksByDoc).forEach(([docId, tasks]) => {
            // 过滤任务
            let filteredTasks = tasks;
            if (!includeDone) {
                filteredTasks = tasks.filter(t => !t.done);
            }

            if (filteredTasks.length === 0) return;

            const docName = docNames[docId] || '未命名文档';
            lines.push(`## 📄 ${docName}`);
            lines.push('');

            // 按二级文档分组
            const tasksByH2 = {};
            filteredTasks.forEach(task => {
                const h2Key = task.h2Id || '__no_h2__';
                const h2Name = task.h2Name || '无二级标题';
                if (!tasksByH2[h2Key]) {
                    tasksByH2[h2Key] = {
                        name: h2Name,
                        tasks: []
                    };
                }
                tasksByH2[h2Key].tasks.push(task);
            });

            // 输出任务
            Object.values(tasksByH2).forEach(h2Group => {
                if (h2Group.name !== '无二级标题') {
                    lines.push(`### ${h2Group.name}`);
                    lines.push('');
                }

                h2Group.tasks.forEach(task => {
                    const checkbox = task.done ? '[x]' : '[ ]';
                    
                    // 根据层级计算缩进
                    const level = task.level || 0;
                    const indent = '  '.repeat(level + 1); // 顶级任务2空格，子任务4空格
                    
                    // 任务内容行
                    let line = `${indent}- ${checkbox} ${task.content || '无内容'}`;

                    // 添加标签信息
                    const tags = [];
                    if (task.priority) {
                        const priorityText = task.priority === 'high' ? '高' : task.priority === 'medium' ? '中' : task.priority === 'low' ? '低' : task.priority;
                        tags.push(`**优先级：${priorityText}**`);
                    }
                    if (task.startDate) {
                        tags.push(`📅 开始：${task.startDate}`);
                    }
                    if (task.completionTime) {
                        tags.push(`🎯 截止：${task.completionTime}`);
                    }
                    if (task.done && task.completionTime) {
                        tags.push(`✨ 已完成：${task.completionTime}`);
                    }
                    if (task.status) {
                        tags.push(`📌 状态：${task.status}`);
                    }

                    if (tags.length > 0) {
                        line += ` ${tags.join(' | ')}`;
                    }

                    lines.push(line);

                    // 添加备注（如果存在）
                    if (task.remark) {
                        lines.push(`${indent}  > 备注：${task.remark}`);
                    }
                });

                lines.push('');
            });
        });

        // 添加汇总信息
        const totalTasks = Object.values(tasksByDoc).reduce((sum, tasks) => sum + tasks.length, 0);
        const doneTasks = Object.values(tasksByDoc).reduce((sum, tasks) => sum + tasks.filter(t => t.done).length, 0);
        const pendingTasks = totalTasks - doneTasks;

        lines.push('---');
        lines.push('');
        lines.push('## 📊 汇总统计');
        lines.push('');
        lines.push(`- 总任务数：${totalTasks}`);
        lines.push(`- 已完成：${doneTasks}`);
        lines.push(`- 待完成：${pendingTasks}`);
        lines.push(`- 完成率：${totalTasks > 0 ? Math.round(doneTasks / totalTasks * 100) : 0}%`);
        lines.push('');

        return lines.join('\n');
    }

    // 生成 JSON 格式导出
    function __tmGenerateJSONExport(tasksByDoc, docNames, includeDone) {
        const exportData = {
            exportTime: new Date().toISOString(),
            documents: []
        };

        Object.entries(tasksByDoc).forEach(([docId, tasks]) => {
            let filteredTasks = tasks;
            if (!includeDone) {
                filteredTasks = tasks.filter(t => !t.done);
            }

            if (filteredTasks.length === 0) return;

            const docData = {
                docId: docId,
                docName: docNames[docId] || '未命名文档',
                tasks: filteredTasks.map(task => ({
                    content: task.content || '',
                    done: !!task.done,
                    priority: task.priority || null,
                    status: task.status || null,
                    startDate: task.startDate || null,
                    completionTime: task.completionTime || null,
                    duration: task.duration || null,
                    remark: task.remark || null,
                    h2Id: task.h2Id || null,
                    h2Name: task.h2Name || null,
                    id: task.id || null
                }))
            };

            exportData.documents.push(docData);
        });

        // 添加统计信息
        const totalTasks = exportData.documents.reduce((sum, doc) => sum + doc.tasks.length, 0);
        const doneTasks = exportData.documents.reduce((sum, doc) => sum + doc.tasks.filter(t => t.done).length, 0);
        exportData.stats = {
            total: totalTasks,
            done: doneTasks,
            pending: totalTasks - doneTasks,
            completionRate: totalTasks > 0 ? Math.round(doneTasks / totalTasks * 100) : 0
        };

        return JSON.stringify(exportData, null, 2);
    };

    // 新增：清空当前分组文档
    window.clearCurrentGroupDocs = async function() {
        if (!confirm('确定要清空当前分组的所有文档吗？')) return;
        
        const currentId = SettingsStore.data.currentGroupId;
        if (currentId === 'all') return;
        
        const groups = SettingsStore.data.docGroups || [];
        const group = groups.find(g => g.id === currentId);
        if (group) {
            group.docs = [];
            await SettingsStore.updateDocGroups(groups);
            showSettings();
        }
    };

    // 新增：从分组移除文档
    window.removeDocFromGroup = async function(index) {
        const currentId = SettingsStore.data.currentGroupId;
        if (currentId === 'all') return;
        
        const groups = SettingsStore.data.docGroups || [];
        const group = groups.find(g => g.id === currentId);
        if (group && group.docs) {
            group.docs.splice(index, 1);
            await SettingsStore.updateDocGroups(groups);
            showSettings();
        }
    };

    window.removeDocFromAll = async function(docId) {
        const id = String(docId || '').trim();
        if (!id) return;

        let changed = false;

        try {
            const legacy = Array.isArray(SettingsStore.data.selectedDocIds) ? SettingsStore.data.selectedDocIds : [];
            const nextLegacy = legacy.filter(x => String(x) !== id);
            if (nextLegacy.length !== legacy.length) {
                SettingsStore.data.selectedDocIds = nextLegacy;
                changed = true;
            }
        } catch (e) {}

        try {
            const groups = Array.isArray(SettingsStore.data.docGroups) ? SettingsStore.data.docGroups : [];
            let groupsChanged = false;
            groups.forEach(g => {
                if (!g || !Array.isArray(g.docs)) return;
                const before = g.docs.length;
                g.docs = g.docs.filter(d => String((typeof d === 'object' ? d?.id : d) || '') !== id);
                if (g.docs.length !== before) groupsChanged = true;
            });
            if (groupsChanged) {
                SettingsStore.data.docGroups = groups;
                changed = true;
            }
        } catch (e) {}

        try {
            const pinMap = (SettingsStore.data.docPinnedByGroup && typeof SettingsStore.data.docPinnedByGroup === 'object')
                ? SettingsStore.data.docPinnedByGroup
                : {};
            let pinChanged = false;
            Object.keys(pinMap).forEach((gid) => {
                const arr = Array.isArray(pinMap[gid]) ? pinMap[gid] : [];
                const next = arr.map(x => String(x || '').trim()).filter(Boolean).filter(x => x !== id);
                if (next.length !== arr.length) {
                    pinMap[gid] = next;
                    pinChanged = true;
                }
            });
            if (pinChanged) {
                SettingsStore.data.docPinnedByGroup = pinMap;
                changed = true;
            }
        } catch (e) {}

        if (!changed) {
            hint('⚠ 未找到该文档', 'warning');
            return;
        }

        await SettingsStore.save();
        state.selectedDocIds = SettingsStore.data.selectedDocIds;
        showSettings();
    };

    // 手动添加文档ID（增强版）
    window.addManualDoc = async function() {
        const input = document.getElementById('manualDocId');
        const recursiveCheck = document.getElementById('recursiveCheck');
        const docId = input.value.trim();
        const isRecursive = recursiveCheck ? recursiveCheck.checked : false;

        if (!docId) {
            hint('⚠ 请输入文档ID', 'warning');
            return;
        }

        // 验证ID格式（思源笔记ID格式：数字-字母数字组合）
        if (!/^[0-9]+-[a-zA-Z0-9]+$/.test(docId)) {
            hint('⚠ 文档ID格式不正确，格式应为：数字-字母数字组合', 'warning');
            return;
        }

        const currentGroupId = SettingsStore.data.currentGroupId || 'all';
        
        if (currentGroupId === 'all') {
            // 添加到旧版列表（不支持递归标志，或者我们需要升级旧版列表结构）
            // 为了兼容，我们在 "全部" 模式下只操作 selectedDocIds
            if (isRecursive) {
                hint('⚠ "全部文档"模式下不支持递归选项，请先创建或选择一个分组', 'warning');
                return;
            }
            if (SettingsStore.data.selectedDocIds.includes(docId)) {
                hint('⚠ 该文档已被添加', 'warning');
                return;
            }
            await SettingsStore.addDocId(docId);
        } else {
            // 添加到当前分组
            const groups = SettingsStore.data.docGroups || [];
            const group = groups.find(g => g.id === currentGroupId);
            if (group) {
                if (!group.docs) group.docs = [];
                // 检查重复
                if (group.docs.some(d => d.id === docId)) {
                    hint('⚠ 该文档已在当前分组中', 'warning');
                    return;
                }
                group.docs.push({ id: docId, recursive: isRecursive });
                await SettingsStore.updateDocGroups(groups);
            }
        }

        // 尝试获取文档名称
        fetchDocName(docId).then(docName => {
            if (docName) {
                state.allDocuments.push({ id: docId, name: docName, path: '', taskCount: 0 });
            }
            showSettings(); // 重新渲染设置界面
        });

        input.value = '';
        if (recursiveCheck) recursiveCheck.checked = false;
        hint('✅ 已添加文档', 'success');
    };

    // 根据ID获取文档名称
    async function fetchDocName(docId) {
        try {
            const sql = `SELECT content, hpath FROM blocks WHERE id = '${docId}' AND type = 'd'`;
            const res = await API.call('/api/query/sql', { stmt: sql });
            if (res.code === 0 && res.data && res.data.length > 0) {
                return res.data[0].content || '未命名文档';
            }
        } catch (e) {
        }
        return null;
    }

    // 根据索引移除文档
    window.removeDocByIndex = async function(index) {
        await SettingsStore.removeDocId(index);
        state.selectedDocIds = SettingsStore.data.selectedDocIds;
        showSettings(); // 重新渲染设置界面
    };

    // 清空所有文档
    window.clearAllDocs = async function() {
        if (!confirm('确定要清空所有已选文档吗？')) return;
        await SettingsStore.clearDocIds();
        state.selectedDocIds = SettingsStore.data.selectedDocIds;
        showSettings(); // 重新渲染设置界面
    };

    window.updateQueryLimit = async function(value) {
        state.queryLimit = parseInt(value) || 500;
        SettingsStore.data.queryLimit = state.queryLimit;
        await SettingsStore.save();
    };

    window.updateEnableQuickbar = async function(enabled) {
        SettingsStore.data.enableQuickbar = !!enabled;
        await SettingsStore.save();
        try { globalThis.__taskHorizonQuickbarToggle?.(!!enabled); } catch (e) {}
        showSettings();
    };

    window.updateEnableTomatoIntegration = async function(enabled) {
        SettingsStore.data.enableTomatoIntegration = !!enabled;
        await SettingsStore.save();
        if (!enabled) state.timerFocusTaskId = '';
        showSettings();
        if (state.modal && document.body.contains(state.modal)) {
            try { render(); } catch (e) {}
        }
    };

    window.updateTomatoSpentAttrMode = async function(mode) {
        const v = String(mode || '').trim();
        SettingsStore.data.tomatoSpentAttrMode = (v === 'hours') ? 'hours' : 'minutes';
        await SettingsStore.save();
        showSettings();
        if (state.modal && document.body.contains(state.modal)) {
            loadSelectedDocuments();
        }
    };

    window.updateTomatoSpentAttrKeyMinutes = async function(value) {
        SettingsStore.data.tomatoSpentAttrKeyMinutes = String(value || '').trim();
        await SettingsStore.save();
        if (state.modal && document.body.contains(state.modal)) {
            loadSelectedDocuments();
        }
    };

    window.updateTomatoSpentAttrKeyHours = async function(value) {
        SettingsStore.data.tomatoSpentAttrKeyHours = String(value || '').trim();
        await SettingsStore.save();
        if (state.modal && document.body.contains(state.modal)) {
            loadSelectedDocuments();
        }
    };

    window.updateExcludeCompletedTasks = async function(enabled) {
        SettingsStore.data.excludeCompletedTasks = !!enabled;
        await SettingsStore.save();
        state.excludeCompletedTasks = !!enabled;
        showSettings();
        if (state.modal && document.body.contains(state.modal)) {
            loadSelectedDocuments();
        }
    };

    window.updateDefaultViewMode = async function(mode) {
        const m0 = String(mode || '').trim();
        const allow = new Set(['list', 'timeline', 'kanban', 'calendar', 'whiteboard']);
        const next = allow.has(m0) ? m0 : 'list';
        SettingsStore.data.defaultViewMode = next;
        await SettingsStore.save();
        showSettings();
    };

    window.updateKanbanCompactMode = async function(enabled) {
        SettingsStore.data.kanbanCompactMode = !!enabled;
        await SettingsStore.save();
        showSettings();
        if (state.modal && document.body.contains(state.modal)) {
            render();
        }
    };

    window.updateKanbanColumnWidth = async function(width) {
        const n = Number(width);
        SettingsStore.data.kanbanColumnWidth = Number.isFinite(n) ? Math.max(220, Math.min(520, Math.round(n))) : 320;
        await SettingsStore.save();
        showSettings();
        if (state.modal && document.body.contains(state.modal)) {
            render();
        }
    };

    window.updateKanbanShowDoneColumn = async function(enabled) {
        SettingsStore.data.kanbanShowDoneColumn = !!enabled;
        await SettingsStore.save();
        showSettings();
        if (state.modal && document.body.contains(state.modal)) {
            render();
        }
    };

    window.updateDocH2SubgroupEnabled = async function(enabled) {
        SettingsStore.data.docH2SubgroupEnabled = !!enabled;
        await SettingsStore.save();
        showSettings();
        if (state.modal && document.body.contains(state.modal)) {
            render();
        }
    };

    window.updateGroupByTaskName = async function(enabled) {
        SettingsStore.data.groupByTaskName = !!enabled;
        if (enabled) {
            SettingsStore.data.groupMode = 'task';
            SettingsStore.data.groupByDocName = false;
            SettingsStore.data.groupByTime = false;
            SettingsStore.data.quadrantConfig = SettingsStore.data.quadrantConfig || {};
            SettingsStore.data.quadrantConfig.enabled = false;
        } else {
            SettingsStore.data.groupMode = 'none';
        }
        await SettingsStore.save();
        state.groupByDocName = SettingsStore.data.groupByDocName;
        state.groupByTaskName = SettingsStore.data.groupByTaskName;
        state.groupByTime = SettingsStore.data.groupByTime;
        state.quadrantEnabled = !!(SettingsStore.data.quadrantConfig && SettingsStore.data.quadrantConfig.enabled);
        showSettings();
        if (state.modal && document.body.contains(state.modal)) {
            render();
        }
    };

    window.updateDurationFormat = async function(format) {
        const v = String(format || '').trim();
        SettingsStore.data.durationFormat = (v === 'minutes') ? 'minutes' : 'hours';
        state.durationFormat = SettingsStore.data.durationFormat;
        await SettingsStore.save();
        showSettings();
        if (state.modal && document.body.contains(state.modal)) {
            render();
        }
    };

    window.updatePinNewTasksByDefault = async function(enabled) {
        SettingsStore.data.pinNewTasksByDefault = !!enabled;
        await SettingsStore.save();
        showSettings();
    };

    window.updateNewTaskDocId = async function(value, options) {
        const v = String(value || '').trim();
        SettingsStore.data.newTaskDocId = v;
        await SettingsStore.save();
        const opt = (options && typeof options === 'object') ? options : {};
        if (opt.refreshQuickAdd !== false) {
            const qa = state.quickAdd;
            if (qa) {
                if (v === '__dailyNote__') {
                    qa.docMode = 'dailyNote';
                    qa.docId = qa.docId || __tmResolveDefaultDocId();
                } else {
                    qa.docMode = 'doc';
                    qa.docId = v || __tmResolveDefaultDocId();
                }
                try { window.tmQuickAddRenderMeta?.(); } catch (e) {}
            }
        }
        if (opt.refreshPicker !== false) {
            if (state.quickAddDocPicker) {
                try { window.tmQuickAddOpenDocPicker?.(); } catch (e) {}
            }
        }
    };

    window.updateNewTaskDocIdFromSelect = async function(value) {
        await updateNewTaskDocId(value);
        try {
            const input = document.getElementById('tmNewTaskDocIdInput');
            const v = String(value || '').trim();
            if (input) input.value = v === '__dailyNote__' ? '' : v;
        } catch (e) {}
    };

    window.tmApplyNewTaskDocIdInput = async function() {
        const input = document.getElementById('tmNewTaskDocIdInput');
        const v = String(input?.value || '').trim();
        await updateNewTaskDocId(v);
        showSettings();
    };

    window.tmClearNewTaskDocIdInput = async function() {
        await updateNewTaskDocId('');
        showSettings();
    };

    window.updateDefaultDocId = async function(value) {
        const v = String(value || '').trim();
        const groupId = String(SettingsStore.data.currentGroupId || 'all').trim() || 'all';
        if (groupId === 'all') {
            SettingsStore.data.defaultDocId = v;
        } else {
            const map = (SettingsStore.data.defaultDocIdByGroup && typeof SettingsStore.data.defaultDocIdByGroup === 'object')
                ? { ...SettingsStore.data.defaultDocIdByGroup }
                : {};
            map[groupId] = v;
            SettingsStore.data.defaultDocIdByGroup = map;
        }
        await SettingsStore.save();
    };

    window.updateDefaultDocIdFromSelect = async function(value) {
        await updateDefaultDocId(value);
        try {
            const input = document.getElementById('tmDefaultDocIdInput');
            if (input) input.value = String(value || '').trim();
        } catch (e) {}
    };

    window.tmApplyDefaultDocIdInput = async function() {
        const input = document.getElementById('tmDefaultDocIdInput');
        const v = String(input?.value || '').trim();
        await updateDefaultDocId(v);
        hint(v ? '✅ 默认文档ID已更新' : '✅ 默认文档已清空', 'success');
        showSettings();
    };

    window.tmClearDefaultDocIdInput = async function() {
        const input = document.getElementById('tmDefaultDocIdInput');
        if (input) input.value = '';
        await updateDefaultDocId('');
        hint('✅ 默认文档已清空', 'success');
        showSettings();
    };

    window.toggleGroupByTime = async function(checked) {
        state.groupByTime = !!checked;
        if (state.groupByTime) {
            // 开启按时间分组时，需要将其他分组标志位设置为 false
            // 但不要修改 SettingsStore.data.groupByTaskName，以保留设置开关的状态
            state.groupByDocName = false;
            state.groupByTaskName = false;
            state.quadrantEnabled = false;
            SettingsStore.data.groupByDocName = false;
            SettingsStore.data.groupByTime = true;
            SettingsStore.data.groupMode = 'time';
            SettingsStore.data.quadrantConfig = SettingsStore.data.quadrantConfig || {};
            SettingsStore.data.quadrantConfig.enabled = false;
        } else {
            // 关闭分组模式时，需要将所有分组标志位设置为 false
            // 但不要修改 SettingsStore.data.groupByTaskName，以保留设置开关的状态
            state.groupByDocName = false;
            state.groupByTime = false;
            state.groupByTaskName = false;
            state.quadrantEnabled = false;
            SettingsStore.data.groupByDocName = false;
            SettingsStore.data.groupByTime = false;
            SettingsStore.data.groupMode = 'none';
            SettingsStore.data.quadrantConfig = SettingsStore.data.quadrantConfig || {};
            SettingsStore.data.quadrantConfig.enabled = false;
        }
        try { SettingsStore.syncToLocal(); } catch (e) {}
        await SettingsStore.save();
        applyFilters();
        render();
    };

    window.toggleGroupByDocName = async function(checked) {
        state.groupByDocName = !!checked;
        if (state.groupByDocName) {
            // 开启按文档分组时，需要将其他分组标志位设置为 false
            // 但不要修改 SettingsStore.data.groupByTaskName，以保留设置开关的状态
            state.groupByTime = false;
            state.groupByTaskName = false;
            state.quadrantEnabled = false;
            SettingsStore.data.groupByTime = false;
            SettingsStore.data.groupByDocName = true;
            SettingsStore.data.groupMode = 'doc';
            SettingsStore.data.quadrantConfig = SettingsStore.data.quadrantConfig || {};
            SettingsStore.data.quadrantConfig.enabled = false;
        } else {
            // 关闭分组模式时，需要将所有分组标志位设置为 false
            // 但不要修改 SettingsStore.data.groupByTaskName，以保留设置开关的状态
            state.groupByDocName = false;
            state.groupByTime = false;
            state.groupByTaskName = false;
            state.quadrantEnabled = false;
            SettingsStore.data.groupByDocName = false;
            SettingsStore.data.groupByTime = false;
            SettingsStore.data.groupMode = 'none';
            SettingsStore.data.quadrantConfig = SettingsStore.data.quadrantConfig || {};
            SettingsStore.data.quadrantConfig.enabled = false;
        }
        try { SettingsStore.syncToLocal(); } catch (e) {}
        await SettingsStore.save();
        applyFilters();
        render();
    };

    window.toggleGroupByTaskName = async function(checked) {
        state.groupByTaskName = !!checked;
        if (state.groupByTaskName) {
            state.groupByDocName = false;
            state.groupByTime = false;
            state.quadrantEnabled = false;
            SettingsStore.data.groupByDocName = false;
            SettingsStore.data.groupByTime = false;
            SettingsStore.data.groupByTaskName = true;
            SettingsStore.data.groupMode = 'task';
            SettingsStore.data.quadrantConfig = SettingsStore.data.quadrantConfig || {};
            SettingsStore.data.quadrantConfig.enabled = false;
        } else {
            SettingsStore.data.groupByTaskName = false;
            SettingsStore.data.groupMode = 'none';
        }
        try { SettingsStore.syncToLocal(); } catch (e) {}
        await SettingsStore.save();
        applyFilters();
        render();
    };

    window.toggleQuadrantGroup = async function(checked) {
        state.quadrantEnabled = !!checked;
        if (state.quadrantEnabled) {
            state.groupByDocName = false;
            state.groupByTime = false;
            state.groupByTaskName = false;
            SettingsStore.data.groupByDocName = false;
            SettingsStore.data.groupByTime = false;
            SettingsStore.data.groupMode = 'quadrant';
            SettingsStore.data.quadrantConfig = SettingsStore.data.quadrantConfig || {};
            SettingsStore.data.quadrantConfig.enabled = true;
        } else {
            // 关闭四象限时，需要将所有分组标志位设置为 false
            // 但不要修改 SettingsStore.data.groupByTaskName，以保留设置开关的状态
            state.groupByDocName = false;
            state.groupByTime = false;
            state.groupByTaskName = false;
            state.quadrantEnabled = false;
            SettingsStore.data.quadrantConfig = SettingsStore.data.quadrantConfig || {};
            SettingsStore.data.quadrantConfig.enabled = false;
            SettingsStore.data.groupMode = 'none';
        }
        try { SettingsStore.syncToLocal(); } catch (e) {}
        await SettingsStore.save();
        applyFilters();
        render();
    };

    window.tmSwitchGroupMode = async function(mode) {
        const m = String(mode || '').trim();
        if (m === 'doc') return toggleGroupByDocName(true);
        if (m === 'time') return toggleGroupByTime(true);
        if (m === 'task') return toggleGroupByTaskName(true);
        if (m === 'quadrant') return toggleQuadrantGroup(true);
        // 只修改当前视图状态，不修改设置开关
        state.groupByDocName = false;
        // 切换到不分组时，设置 state.groupByTaskName 为 false
        // 但不修改 SettingsStore.data.groupByTaskName，以保留设置开关的状态
        state.groupByTaskName = false;
        state.groupByTime = false;
        state.quadrantEnabled = false;
        SettingsStore.data.groupMode = 'none';
        SettingsStore.data.quadrantConfig = SettingsStore.data.quadrantConfig || {};
        SettingsStore.data.quadrantConfig.enabled = false;
        try { SettingsStore.syncToLocal(); } catch (e) {}
        await SettingsStore.save();
        applyFilters();
        render();
    };

    window.tmToggleGroupCollapse = async function(groupKey, ev) {
        try {
            ev?.stopPropagation?.();
            ev?.preventDefault?.();
        } catch (e) {}

        const k0 = String(groupKey || '').trim();
        const action = state.collapsedGroups.has(k0) ? 'expand' : 'collapse';
        const flipOpts = { kind: 'group', key: k0, action };
        let skipAnim = false;
        try {
            const tbody = __tmGetActiveTbody(state.modal);
            const n = __tmCountAffectedRowsForCollapse(tbody, flipOpts, 161);
            skipAnim = n > 160;
        } catch (e) {}
        if (!skipAnim) {
            try { __tmPrepareFlipAnimation(flipOpts); } catch (e) {}
        } else {
            try { __tmResetFlipState(state.modal); } catch (e) {}
        }
        
        if (state.collapsedGroups.has(groupKey)) state.collapsedGroups.delete(groupKey);
        else state.collapsedGroups.add(groupKey);

        SettingsStore.data.collapsedGroups = [...state.collapsedGroups];
        // 直接同步到本地存储，不等待云端同步，避免延迟
        try { Storage.set('tm_collapsed_groups', SettingsStore.data.collapsedGroups); } catch (e) {}
        try { __tmUpdateToggleGlyphInDom({ kind: 'group', key: k0, action }); } catch (e) {}
        if (action === 'collapse') {
            if (state.modal && __tmApplyVisibilityFromState(state.modal)) {
                if (!skipAnim) {
                    try { queueMicrotask(() => { try { __tmRunFlipAnimation(state.modal); } catch (e) {} }); } catch (e) {}
                }
                return;
            }
            __tmScheduleCollapseRerender();
            return;
        }
        __tmScheduleCollapseRerender();
    };

    window.tmToggleCollapse = async function(id, ev) {
        try {
            ev?.stopPropagation?.();
            ev?.preventDefault?.();
        } catch (e) {}
        const key = String(id || '');
        if (!key) return;

        const action = state.collapsedTaskIds.has(key) ? 'expand' : 'collapse';
        const flipOpts = { kind: 'task', key, action };
        let skipAnim = false;
        try {
            const tbody = __tmGetActiveTbody(state.modal);
            const n = __tmCountAffectedRowsForCollapse(tbody, flipOpts, 161);
            skipAnim = n > 160;
        } catch (e) {}
        if (!skipAnim) {
            try { __tmPrepareFlipAnimation(flipOpts); } catch (e) {}
        } else {
            try { __tmResetFlipState(state.modal); } catch (e) {}
        }
        if (state.collapsedTaskIds.has(key)) state.collapsedTaskIds.delete(key);
        else state.collapsedTaskIds.add(key);

        // 直接同步到本地存储，不等待云端同步，避免延迟
        SettingsStore.data.collapsedTaskIds = [...state.collapsedTaskIds];
        try { Storage.set('tm_collapsed_task_ids', SettingsStore.data.collapsedTaskIds); } catch (e) {}
        try { __tmUpdateToggleGlyphInDom({ kind: 'task', key, action }); } catch (e) {}
        if (action === 'collapse') {
            if (state.modal && __tmApplyVisibilityFromState(state.modal)) {
                if (!skipAnim) {
                    try { queueMicrotask(() => { try { __tmRunFlipAnimation(state.modal); } catch (e) {} }); } catch (e) {}
                }
                return;
            }
            __tmScheduleCollapseRerender();
            return;
        }
        __tmScheduleCollapseRerender();
    };

    window.tmCollapseAllTasks = async function() {
        if (state.viewMode === 'kanban' || state.viewMode === 'whiteboard') {
            const filtered = Array.isArray(state.filteredTasks) ? state.filteredTasks : [];
            const filteredIdSet = new Set(filtered.map(t => String(t?.id || '').trim()).filter(Boolean));
            const colKey = (t) => (t?.done ? '__done__' : (String(t?.customStatus || '').trim() || 'todo'));
            const collapsed = __tmKanbanGetCollapsedSet();
            filtered.forEach(t => {
                const id = String(t?.id || '').trim();
                if (!id) return;
                const kids = Array.isArray(t?.children) ? t.children : [];
                if (!kids.length) return;
                const k0 = colKey(t);
                const hasSameColChild = kids.some(c => {
                    const cid = String(c?.id || '').trim();
                    if (!cid || !filteredIdSet.has(cid)) return false;
                    const ct = state.flatTasks[cid] || c;
                    return colKey(ct) === k0;
                });
                if (hasSameColChild) collapsed.add(id);
            });
            __tmKanbanPersistCollapsed();
            render();
            return;
        }
        const filteredSet = new Set(state.filteredTasks.map(t => t.id));
        const next = new Set(state.collapsedTaskIds || []);
        const applyCollapse = (list) => {
            list.forEach(t => {
                const hasVisibleChild = (t.children || []).some(c => filteredSet.has(c.id));
                if (filteredSet.has(t.id) && hasVisibleChild) {
                    next.add(String(t.id));
                }
                if (t.children && t.children.length > 0) applyCollapse(t.children);
            });
        };
        state.taskTree.forEach(doc => {
            if (state.activeDocId !== 'all' && doc.id !== state.activeDocId) return;
            applyCollapse(doc.tasks || []);
        });
        state.collapsedTaskIds = next;
        SettingsStore.data.collapsedTaskIds = [...next];
        try { Storage.set('tm_collapsed_task_ids', SettingsStore.data.collapsedTaskIds); } catch (e) {}
        try { __tmResetFlipState(state.modal); } catch (e) {}
        if (!(state.modal && __tmApplyVisibilityFromState(state.modal))) {
            if (!__tmRerenderCollapseInPlace()) render();
        }
        await SettingsStore.save();
    };

    window.tmExpandAllTasks = async function() {
        if (state.viewMode === 'kanban' || state.viewMode === 'whiteboard') {
            __tmKanbanGetCollapsedSet().clear();
            __tmKanbanPersistCollapsed();
            render();
            return;
        }
        state.collapsedTaskIds = new Set();
        SettingsStore.data.collapsedTaskIds = [];
        try { Storage.set('tm_collapsed_task_ids', []); } catch (e) {}
        try { __tmResetFlipState(state.modal); } catch (e) {}
        if (!__tmRerenderCollapseInPlace()) render();
        await SettingsStore.save();
    };

    window.closeSettings = function() {
        if (state.settingsModal) {
            state.settingsModal.remove();
            state.settingsModal = null;
        }
    };

    window.saveSettings = async function() {
        // 同步到 SettingsStore 并保存到本地插件存储
        SettingsStore.data.selectedDocIds = state.selectedDocIds;
        SettingsStore.data.queryLimit = state.queryLimit;
        SettingsStore.data.showCompletionTime = state.showCompletionTime;
        SettingsStore.data.groupByDocName = state.groupByDocName;
        SettingsStore.data.groupByTime = state.groupByTime;
        await SettingsStore.save();
        hint('✅ 设置已保存', 'success');
        render();
        closeSettings();
    };

    // 全局点击监听器，用于点击窗口外关闭
    __tmGlobalClickHandler = (e) => {
        // 关闭主模态框
        if (state.modal && e.target === state.modal) {
            tmClose();
        }
        // 关闭设置模态框
        if (state.settingsModal && e.target === state.settingsModal) {
            closeSettings();
        }
        // 关闭规则管理模态框
        if (state.rulesModal && e.target === state.rulesModal) {
            closeRulesManager();
        }
        // 关闭提示框
        const promptModal = document.querySelector('.tm-prompt-modal');
        if (promptModal && e.target === promptModal) {
            // 取消操作
            promptModal.remove();
            if (window._tmPromptResolve) {
                window._tmPromptResolve(null);
                window._tmPromptResolve = null;
            }
        }
    };
    window.addEventListener('click', __tmGlobalClickHandler);

    // 初始化
    /**
     * 在移动端面包屑栏右上角添加任务管理按钮
     * 支持多窗口（分屏）
     */
    let breadcrumbTimer = null;
    let breadcrumbTries = 0;
    function addBreadcrumbButton() {
        if (breadcrumbTimer != null) return;

        const scheduleTry = (delayMs) => {
            if (breadcrumbTimer != null) return;
            const d = Math.max(0, Number(delayMs) || 0);
            breadcrumbTimer = setTimeout(() => {
                breadcrumbTimer = null;
                tryAddButton();
            }, d);
        };

        const tryAddButton = () => {
            const breadcrumbs = document.querySelectorAll('.protyle-breadcrumb');
            if (breadcrumbs.length === 0) {
                breadcrumbTries += 1;
                if (breadcrumbTries <= 60) scheduleTry(500);
                return;
            }

            breadcrumbs.forEach(breadcrumb => {
                // 检查该面包屑下是否已存在按钮
                if (breadcrumb.querySelector('.tm-breadcrumb-btn')) return;

                // 创建任务管理按钮
                const tmBtn = document.createElement('button');
                tmBtn.className = 'tm-breadcrumb-btn'; // 使用 class 标识
                tmBtn.innerHTML = '<span style="display:flex;align-items:center;justify-content:center;width:100%;height:100%;line-height:0"><svg viewBox="0 0 24 24" width="14" height="14" style="display:block;fill:none;flex:0 0 auto;transform:translateY(1px)"><use xlink:href="#iconTaskHorizon"></use></svg></span>';
                tmBtn.title = '打开任务管理器';
                tmBtn.style.cssText = `
                    width: 28px;
                    height: 28px;
                    padding: 0 !important;
                    margin: 0 4px;
                    background: transparent;
                    color: var(--b3-theme-on-surface, inherit);
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 0;
                    line-height: 0;
                    display: flex !important;
                    align-items: center !important;
                    justify-content: center !important;
                    text-align: center !important;
                    flex-shrink: 0;
                    transition: all 0.2s;
                    z-index: 10;
                `;

                tmBtn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (tmBtn.__tmLongPressFired) {
                        tmBtn.__tmLongPressFired = false;
                        return;
                    }
                    try { window.tmQuickAddOpen?.(); } catch (e2) {}
                };

                try {
                    let pressTimer = null;
                    const startHandler = (e) => {
                        tmBtn.__tmLongPressFired = false;
                        if (pressTimer) clearTimeout(pressTimer);
                        pressTimer = setTimeout(() => {
                            tmBtn.__tmLongPressFired = true;
                            try { openManager({ preserveViewMode: true }); } catch (e) {}
                        }, 450);
                    };
                    const cancelHandler = () => {
                        if (pressTimer) clearTimeout(pressTimer);
                        pressTimer = null;
                    };
                    const endHandler = (e) => {
                        if (pressTimer) clearTimeout(pressTimer);
                        pressTimer = null;
                        if (tmBtn.__tmLongPressFired) {
                            try { e.preventDefault(); } catch (e2) {}
                            try { e.stopPropagation(); } catch (e2) {}
                        }
                    };

                    tmBtn.addEventListener('touchstart', startHandler, { passive: true });
                    tmBtn.addEventListener('touchmove', cancelHandler, { passive: true });
                    tmBtn.addEventListener('touchend', endHandler, { passive: false });
                    
                    tmBtn.addEventListener('mousedown', startHandler);
                    tmBtn.addEventListener('mouseleave', cancelHandler);
                    tmBtn.addEventListener('mouseup', endHandler);
                } catch (e) {}

                breadcrumb.appendChild(tmBtn);
            });
            
            breadcrumbTries = 0;
        };

        // 延迟执行
        scheduleTry(0);
    }

    /**
     * 注册顶栏图标
     */
    function __tmSetUseIcon(root, iconId) {
        if (!root) return false;
        const use = root.querySelector?.('use');
        if (!use) return false;
        const href = `#${iconId}`;
        try { use.setAttribute('href', href); } catch (e) {}
        try { use.setAttribute('xlink:href', href); } catch (e) {}
        try { use.setAttributeNS('http://www.w3.org/1999/xlink', 'href', href); } catch (e) {}
        return true;
    }

    function __tmPatchTaskHorizonTabIcon() {
        const iconId = 'iconTaskHorizon';
        const tabId = globalThis.__taskHorizonCustomTabId;
        const uses = Array.from(document.querySelectorAll('use[href], use[xlink\\:href]'));
        let ok = false;
        for (const use of uses) {
            try {
                const href = use.getAttribute('href') || use.getAttribute('xlink:href') || '';
                if (!href.includes('iconList') && !href.includes(iconId)) continue;
                const owner = tabId
                    ? (use.closest?.(`[data-id="${tabId}"], [data-key="${tabId}"]`) || use.closest?.('[data-id], [data-key], li, button, div'))
                    : (use.closest?.('[data-id], [data-key], li, button, div'));
                if (!owner) continue;
                if ((tabId && (owner.getAttribute?.('data-id') === tabId || owner.getAttribute?.('data-key') === tabId)) || String(owner.textContent || '').includes('任务管理器')) {
                    const root = owner.closest?.(`[data-id="${tabId}"], [data-key="${tabId}"]`) || owner;
                    if (__tmSetUseIcon(root, iconId)) ok = true;
                }
            } catch (e) {}
        }
        return ok;
    }

    function __tmFocusExistingTaskHorizonTab() {
        try {
            const tabId = globalThis.__taskHorizonCustomTabId;
            if (!tabId) return false;
            try {
                const tab = __tmFindExistingTaskManagerTab?.();
                if (tab && window.siyuan?.layout?.centerLayout?.switchTab) {
                    window.siyuan.layout.centerLayout.switchTab(tab);
                    return true;
                }
            } catch (e) {}

            const els = Array.from(document.querySelectorAll(`[data-id="${tabId}"], [data-key="${tabId}"]`));
            if (els.length === 0) return false;
            const el = els.find(x => x && x.querySelector && x.querySelector('.tm-tab-root')) || els[0];
            try {
                el.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true }));
            } catch (e) {
                try { el.click(); } catch (e2) {}
            }
            return true;
        } catch (e) {}
        return false;
    }

    let __tmEnsureTabPromise = null;

    function __tmBindTopBarClickCapture(topBarEl) {
        const el = topBarEl || __tmTopBarEl;
        if (!el) return;
        if (__tmTopBarEl && __tmTopBarEl !== el && __tmTopBarClickCaptureHandler) {
            try { __tmTopBarEl.removeEventListener('click', __tmTopBarClickCaptureHandler, true); } catch (e) {}
        }
        __tmTopBarEl = el;
        if (__tmTopBarClickCaptureHandler) return;
        __tmTopBarClickCaptureHandler = (e) => {
            if (__tmTopBarClickInFlight) return;
            __tmTopBarClickInFlight = true;
            try {
                try { e.preventDefault?.(); } catch (e2) {}
                try { e.stopImmediatePropagation?.(); } catch (e2) {}
                try { e.stopPropagation?.(); } catch (e2) {}
                try { openManager({ preserveViewMode: true }); } catch (e2) {}
            } finally {
                setTimeout(() => { __tmTopBarClickInFlight = false; }, 0);
            }
        };
        try { el.addEventListener('click', __tmTopBarClickCaptureHandler, true); } catch (e) {}
    }

    function addTopBarIcon() {
        if (__tmTopBarAdded) {
            try {
                const exists = document.querySelector('[aria-label="任务管理器"], [aria-label="任务管理"]');
                if (exists) __tmBindTopBarClickCapture(exists);
            } catch (e) {}
            return;
        }
        if (__tmIsMobileDevice()) return;
        // 尝试通过全局插件实例添加
        const pluginInstance = globalThis.__taskHorizonPluginInstance || globalThis.__tomatoPluginInstance;
        if (pluginInstance && typeof pluginInstance.addTopBar === 'function') {
            // 检查是否已添加（避免重复）
            // addTopBar 通常由插件管理，我们这里只是尝试调用
            // 如果已经添加过，思源可能会处理，或者我们可以检查 DOM
            // 但是 addTopBar 没有 ID 参数，不好检查。
            // 我们可以检查 aria-label 或 title
            const exists = document.querySelector('[aria-label="任务管理器"], [aria-label="任务管理"]');
            if (exists) {
                __tmSetUseIcon(exists, 'iconTaskHorizon');
                try { __tmBindTopBarClickCapture(exists); } catch (e) {}
                __tmTopBarAdded = true;
                return;
            }

            const topBarEl = pluginInstance.addTopBar({
                icon: "iconTaskHorizon",
                title: "任务管理器",
                position: "right",
                callback: () => {}
            });
            try { __tmBindTopBarClickCapture(topBarEl || document.querySelector('[aria-label="任务管理器"], [aria-label="任务管理"]')); } catch (e) {}
            __tmTopBarAdded = true;
            setTimeout(() => { try { __tmSetUseIcon(document.querySelector('[aria-label="任务管理器"], [aria-label="任务管理"]'), 'iconTaskHorizon'); } catch (e) {} }, 0);
        } else {
        }
    }

    function __tmFindExistingTaskHorizonCustomModel() {
        const tabType = String(globalThis.__taskHorizonTabType || 'task-horizon');
        const tabId = String(globalThis.__taskHorizonCustomTabId || '');
        try {
            const inst = globalThis.__taskHorizonPluginInstance;
            if (inst && typeof inst.getOpenedTab === 'function') {
                const opened = inst.getOpenedTab();
                if (opened && typeof opened === 'object') {
                    const customs = [];
                    Object.values(opened).forEach((arr) => {
                        if (Array.isArray(arr)) arr.forEach((c) => customs.push(c));
                    });
                    for (const c of customs) {
                        if (!c) continue;
                        if (c.type === tabType) return c;
                        if (tabId && c?.tab?.id === tabId) return c;
                        if (c.tab?.title === '任务管理器' || c.title === '任务管理器') return c;
                        if (__tmMountEl && c.element && c.element.contains(__tmMountEl)) return c;
                    }
                }
            }
        } catch (e) {}
        try {
            if (window.siyuan && typeof window.siyuan.getAllModels === 'function') {
                const models = window.siyuan.getAllModels();
                const list = Array.isArray(models?.custom) ? models.custom : [];
                for (const c of list) {
                    if (!c) continue;
                    if (c.type === tabType) return c;
                    if (tabId && c?.tab?.id === tabId) return c;
                    if (c.tab?.title === '任务管理器' || c.title === '任务管理器') return c;
                    if (__tmMountEl && c.element && c.element.contains(__tmMountEl)) return c;
                }
            }
        } catch (e) {}
        return null;
    }

    /**
     * 监听面包屑栏变化
     */
    function observeBreadcrumb() {
        // 先尝试添加一次
        addBreadcrumbButton();
        if (!__tmIsMobileDevice()) {
            addTopBarIcon();
        }

        // 使用 MutationObserver 监听面包屑栏变化
        if (__tmBreadcrumbObserver) {
            try { __tmBreadcrumbObserver.disconnect(); } catch (e) {}
            __tmBreadcrumbObserver = null;
        }
        const observer = new MutationObserver(() => {
            addBreadcrumbButton();
        });

        // 监听整个文档的子节点变化
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
        __tmBreadcrumbObserver = observer;
        
        // 额外监听顶栏图标注入（如果插件实例加载较晚）
        if (!__tmIsMobileDevice()) __tmTopBarTimer = setTimeout(addTopBarIcon, 1000);
    }

    async function init() {
        try { __tmBindWakeReload(); } catch (e) {}

        // 1. 先加载设置（包括文档ID）
        try {
            await SettingsStore.load();
            await WhiteboardStore.load();

            // 初始化状态
            state.selectedDocIds = SettingsStore.data.selectedDocIds;
            state.queryLimit = SettingsStore.data.queryLimit;
            const gm0 = String(SettingsStore.data.groupMode || '').trim();
            const validModes = new Set(['none', 'doc', 'time', 'quadrant', 'task']);
            if (!validModes.has(gm0)) {
                // groupMode 无效时，使用已加载的标志位
                state.groupByDocName = SettingsStore.data.groupByDocName;
                state.groupByTaskName = SettingsStore.data.groupByTaskName;
                state.groupByTime = SettingsStore.data.groupByTime;
                state.quadrantEnabled = SettingsStore.data.quadrantConfig?.enabled || false;
            }
            // 根据 groupMode 设置标志位，但 groupByTaskName 只在 groupMode === 'task' 时才设置为 true
            if (gm0 === 'doc') {
                state.groupByDocName = true;
                state.groupByTime = false;
                state.quadrantEnabled = false;
            } else if (gm0 === 'time') {
                state.groupByDocName = false;
                state.groupByTime = true;
                state.quadrantEnabled = false;
            } else if (gm0 === 'task') {
                state.groupByDocName = false;
                state.groupByTaskName = true;
                state.groupByTime = false;
                state.quadrantEnabled = false;
            } else if (gm0 === 'quadrant') {
                state.groupByDocName = false;
                state.groupByTime = false;
                state.quadrantEnabled = true;
            } else {
                // 当 groupMode 为 'none' 时（用户选择了"不分组"），将 state.groupByTaskName 设置为 false
                // 这样可以正确显示"不分组"选项为选中状态
                // 注意：这里不检查 SettingsStore.data.groupByTaskName，因为它只控制开关显示，不影响当前分组模式
                state.groupByDocName = false;
                state.groupByTaskName = false;
                state.groupByTime = false;
                state.quadrantEnabled = false;
            }
            state.collapsedTaskIds = new Set(SettingsStore.data.collapsedTaskIds || []);
            state.collapsedGroups = new Set(SettingsStore.data.collapsedGroups || []);
            state.currentRule = SettingsStore.data.currentRule;
            state.columnWidths = SettingsStore.data.columnWidths;
            state.docTabsHidden = !!Storage.get('tm_doc_tabs_hidden', false);

            // 加载筛选规则
            state.filterRules = await RuleManager.initRules();
        } catch (e) {
            console.error('[初始化] 加载设置失败:', e);
        }

        try {
            if (__tmThemeModeObserver) {
                __tmThemeModeObserver.disconnect();
                __tmThemeModeObserver = null;
            }
            __tmThemeModeObserver = new MutationObserver(() => {
                try { __tmApplyAppearanceThemeVars(); } catch (e) {}
                try { if (state.modal) render(); } catch (e) {}
            });
            __tmThemeModeObserver.observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme-mode'] });
        } catch (e) {}
        try { __tmApplyAppearanceThemeVars(); } catch (e) {}

        // 2. 获取所有文档列表
        try {
            state.allDocuments = await API.getAllDocuments();
        } catch (e) {
            console.error('[初始化] 加载文档列表失败:', e);
        }

        // 3. 创建浮动按钮 (已禁用)
        /*
        const fab = document.createElement('button');
        fab.className = 'tm-fab';
        fab.innerHTML = '📋 任务管理';
        fab.onclick = openManager;
        document.body.appendChild(fab);

        // 显示已选文档数量
        if (state.selectedDocIds.length > 0) {
            fab.title = `任务管理 (已选 ${state.selectedDocIds.length} 个文档)`;
        }
        */

        // 启动面包屑按钮观察者
        observeBreadcrumb();
    }

    async function __tmEnsureTabOpened(maxWaitMs = 1500) {
        if (typeof globalThis.__taskHorizonOpenTabView !== 'function') return;
        try {
            if (window.siyuan?.config?.isMobile) return;
        } catch (e) {}
        if (__tmIsMobileDevice()) return;
        __tmEnsureMount();
        // Removed aggressive openTabView call if mount exists, relying on findExistingModel logic instead
        
        try {
            const custom = __tmFindExistingTaskHorizonCustomModel();
            if (custom) {
                try {
                    const tab = custom.tab || custom;
                    if (tab && window.siyuan?.layout?.centerLayout?.switchTab) {
                        window.siyuan.layout.centerLayout.switchTab(tab);
                    } else if (tab?.headElement?.click) {
                        tab.headElement.click();
                    }
                } catch (e2) {}
                try {
                    const el = custom.element;
                    if (el && document.body.contains(el)) {
                        try { globalThis.__taskHorizonTabElement = el; } catch (e3) {}
                        __tmSetMount(el);
                    }
                } catch (e2) {}
                return;
            }
        } catch (e) {}
        try {
            const existingTab = __tmFindExistingTaskManagerTab?.();
            if (existingTab) {
                try { __tmSwitchToTab(existingTab); } catch (e) {}
                try {
                    await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));
                } catch (e) {}
                __tmEnsureMount();
                if (__tmMountEl && document.body.contains(__tmMountEl)) return;
                const best = __tmFindBestTabRoot?.();
                if (best && document.body.contains(best)) {
                    try { globalThis.__taskHorizonTabElement = best; } catch (e) {}
                    __tmSetMount(best);
                }
                return;
            }
        } catch (e) {}
        
        // 尝试查找并点击标签页标题 (Fallback)
        try {
            const headers = document.querySelectorAll('.layout-tab-bar__item');
            for (const h of headers) {
                if ((h.innerText && h.innerText.includes('任务管理器')) || h.querySelector('[aria-label="任务管理器"]')) {
                    h.click();
                    
                    // 轮询等待内容加载 (最多 2 秒)
                    const start = Date.now();
                    while (Date.now() - start < 2000) {
                        await new Promise(r => setTimeout(r, 100));
                        __tmEnsureMount();
                        if (__tmMountEl && document.body.contains(__tmMountEl)) {
                            try { globalThis.__taskHorizonTabElement = __tmMountEl; } catch (e) {}
                            return;
                        }
                    }
                    // 即使超时，只要找到了 header，我们也认为不需要新建，避免重复
                    return;
                }
            }
        } catch(e) {}

        if (__tmEnsureTabPromise) return __tmEnsureTabPromise;
        __tmEnsureTabPromise = (async () => {
            try {
                try { globalThis.__taskHorizonOpenTabView(); } catch (e) {}
                const start = Date.now();
                while (!globalThis.__taskHorizonTabElement && Date.now() - start < (Number(maxWaitMs) || 1500)) {
                    try {
                        const tabId = globalThis.__taskHorizonCustomTabId;
                        if (tabId) {
                            const root = document.querySelector(`[data-id="${tabId}"] .tm-tab-root, [data-key="${tabId}"] .tm-tab-root`);
                            if (root) globalThis.__taskHorizonTabElement = root;
                        }
                    } catch (e) {}
                    await new Promise(r => setTimeout(r, 50));
                }
                __tmEnsureMount();
                if (globalThis.__taskHorizonTabElement && document.body.contains(globalThis.__taskHorizonTabElement)) {
                    __tmSetMount(globalThis.__taskHorizonTabElement);
                }
            } finally {
                __tmEnsureTabPromise = null;
            }
        })();
        return __tmEnsureTabPromise;
    }

    // 检查是否有任何分组包含文档（支持全部文档和自定义分组）
    async function checkAnyGroupHasDocs() {
        // 检查全部文档分组
        if (SettingsStore.data.selectedDocIds && SettingsStore.data.selectedDocIds.length > 0) {
            return true;
        }
        
        // 检查自定义分组
        const groups = SettingsStore.data.docGroups || [];
        for (const group of groups) {
            if (group.docs && group.docs.length > 0) {
                return true;
            }
        }
        
        return false;
    }

    // 查找已打开的任务管理器标签页
    function __tmFindExistingTaskManagerTab() {
        try {
            if (!window.siyuan || !window.siyuan.ws || !window.siyuan.ws.apps) return null;
            
            const apps = window.siyuan.ws.apps;
            for (const app of apps) {
                if (app && app.custom && app.custom['task-horizon']) {
                    return app;
                }
            }
        } catch (e) {}
        return null;
    }

    // 切换到指定标签页
    function __tmSwitchToTab(tab) {
        try {
            if (window.siyuan && window.siyuan.layout && window.siyuan.layout.centerLayout) {
                window.siyuan.layout.centerLayout.switchTab(tab);
            }
        } catch (e) {
            // 如果切换失败，则打开新标签页
            openManager({ preserveViewMode: true });
        }
    }

    async function openManager(options) {
        state.openToken = (Number(state.openToken) || 0) + 1;
        const token = Number(state.openToken) || 0;
        try { __tmListenPinnedChanged(); } catch (e) {}

        if (!__tmIsMobileDevice()) {
            if (!options || !options.skipEnsureTabOpened) {
                await __tmEnsureTabOpened();
            } else {
                __tmEnsureMount();
            }
            try {
                setTimeout(() => { try { __tmPatchTaskHorizonTabIcon(); } catch (e) {} }, 0);
                setTimeout(() => { try { __tmPatchTaskHorizonTabIcon(); } catch (e) {} }, 250);
                setTimeout(() => { try { __tmPatchTaskHorizonTabIcon(); } catch (e) {} }, 900);
            } catch (e) {}
        }

        // 强制重新渲染，确保 DOM 存在
        try { render(); } catch (e) {
            console.error('[OpenManager] Render failed:', e);
        }

        // 仅在主动打开时显示加载提示；页签挂载恢复/静默恢复不提示
        const shouldShowLoadingHint = !state.wasHidden
            && !(options && options.skipLoadingHint)
            && !(options && options.skipEnsureTabOpened);
        if (shouldShowLoadingHint) {
            hint('🔄 加载任务中...', 'info');
        }
        state.wasHidden = false;

        await SettingsStore.load();
        try {
            const allow = new Set(['list', 'timeline', 'kanban', 'calendar', 'whiteboard']);
            const isMobileDevice = __tmIsMobileDevice();
            const preserve = !!(options && options.preserveViewMode);
            const current = String(state.viewMode || '').trim();
            if (preserve && allow.has(current)) {
                state.viewMode = (isMobileDevice && current === 'timeline') ? 'list' : current;
            } else {
                const m0 = String(SettingsStore.data.defaultViewMode || 'list').trim();
                const m1 = (isMobileDevice && m0 === 'timeline') ? 'list' : m0;
                state.viewMode = allow.has(m1) ? m1 : 'list';
            }
        } catch (e) {
            state.viewMode = 'list';
        }
        try {
            const ids = Array.isArray(SettingsStore.data.kanbanCollapsedTaskIds) ? SettingsStore.data.kanbanCollapsedTaskIds : [];
            state.__tmKanbanCollapsedIds = new Set(ids.map(x => String(x || '').trim()).filter(Boolean));
        } catch (e) {
            state.__tmKanbanCollapsedIds = new Set();
        }
        if (SettingsStore.data.enableTomatoIntegration) {
            try { __tmHookTomatoTimer(); } catch (e) {}
            try { __tmListenTomatoAssociationCleared(); } catch (e) {}
        }
        state.selectedDocIds = SettingsStore.data.selectedDocIds;

        // 检查是否至少有一个分组包含文档
        const hasDocs = await checkAnyGroupHasDocs();
        if (!hasDocs) {
            hint('⚠ 请先在设置中添加要显示的文档', 'warning');
            if (state.modal && token === (Number(state.openToken) || 0)) showSettings();
            return;
        }

        if (!state.modal || token !== (Number(state.openToken) || 0)) return;
        try {
            await new Promise(resolve => {
                requestAnimationFrame(() => requestAnimationFrame(resolve));
            });
        } catch (e) {}
        loadSelectedDocuments().catch(e => hint(`❌ 加载失败: ${e.message}`, 'error'));
    }

    // ... 保留原有的 loadSelectedDocuments 和其他函数 ...

    // 插件卸载清理
    function __tmCleanup() {
        try {
            if (__tmVisibilityHandler) {
                document.removeEventListener('visibilitychange', __tmVisibilityHandler);
                __tmVisibilityHandler = null;
            }
        } catch (e) {}
        try {
            if (__tmFocusHandler) {
                window.removeEventListener('focus', __tmFocusHandler);
                __tmFocusHandler = null;
            }
        } catch (e) {}
        try {
            if (__tmGlobalClickHandler) {
                window.removeEventListener('click', __tmGlobalClickHandler);
                __tmGlobalClickHandler = null;
            }
        } catch (e) {}
        try {
            if (__tmTopBarClickCaptureHandler) {
                try { __tmTopBarEl?.removeEventListener?.('click', __tmTopBarClickCaptureHandler, true); } catch (e2) {}
                __tmTopBarClickCaptureHandler = null;
            }
            __tmTopBarEl = null;
            __tmTopBarClickInFlight = false;
        } catch (e) {}
        try {
            if (__tmQuickAddGlobalClickHandler) {
                document.removeEventListener('click', __tmQuickAddGlobalClickHandler);
                __tmQuickAddGlobalClickHandler = null;
            }
            try { if (window.tmQuickAddEventsBound) window.tmQuickAddEventsBound = false; } catch (e2) {}
        } catch (e) {}
        try {
            if (__tmWakeReloadTimer) {
                clearTimeout(__tmWakeReloadTimer);
                __tmWakeReloadTimer = null;
            }
            __tmWakeReloadInFlight = false;
            __tmWakeReloadBound = false;
            __tmWasHiddenAt = 0;
        } catch (e) {}
        try {
            if (__tmTomatoAssociationHandler) {
                window.removeEventListener('tomato:association-cleared', __tmTomatoAssociationHandler);
                __tmTomatoAssociationHandler = null;
            }
        } catch (e) {}
        try {
            const timer = globalThis.__tomatoTimer;
            if (timer && typeof timer === 'object' && __tmTomatoOriginalTimerFns) {
                Object.entries(__tmTomatoOriginalTimerFns).forEach(([k, fn]) => {
                    if (typeof fn === 'function') {
                        try { timer[k] = fn; } catch (e) {}
                    }
                });
            }
            __tmTomatoOriginalTimerFns = null;
            __tmTomatoTimerHooked = false;
        } catch (e) {}
        try {
            if (globalThis.__taskHorizonOnTomatoAssociationCleared) delete globalThis.__taskHorizonOnTomatoAssociationCleared;
            __tmTomatoAssociationListenerAdded = false;
        } catch (e) {}
        try {
            if (globalThis.__taskHorizonOnPinnedChanged) delete globalThis.__taskHorizonOnPinnedChanged;
            __tmPinnedListenerAdded = false;
        } catch (e) {}

        try {
            if (__tmDomReadyHandler) {
                document.removeEventListener('DOMContentLoaded', __tmDomReadyHandler);
                __tmDomReadyHandler = null;
            }
        } catch (e) {}

        try {
            if (breadcrumbTimer != null) {
                clearTimeout(breadcrumbTimer);
                breadcrumbTimer = null;
            }
        } catch (e) {}

        try {
            if (__tmTopBarTimer != null) {
                clearTimeout(__tmTopBarTimer);
                __tmTopBarTimer = null;
            }
        } catch (e) {}
        try {
            if (__tmMountRetryTimer != null) {
                clearTimeout(__tmMountRetryTimer);
                __tmMountRetryTimer = null;
            }
        } catch (e) {}

        try {
            if (__tmBreadcrumbObserver) {
                __tmBreadcrumbObserver.disconnect();
                __tmBreadcrumbObserver = null;
            }
        } catch (e) {}

        try {
            if (__tmThemeModeObserver) {
                __tmThemeModeObserver.disconnect();
                __tmThemeModeObserver = null;
            }
        } catch (e) {}

        try {
            if (__tmResizeState) {
                document.removeEventListener('mousemove', __tmOnResize);
                document.removeEventListener('mouseup', __tmStopResize);
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                __tmResizeState = null;
            }
        } catch (e) {}
        try {
            if (__tmTimelineSplitResizeOnMove) document.removeEventListener('mousemove', __tmTimelineSplitResizeOnMove);
            if (__tmTimelineSplitResizeOnUp) document.removeEventListener('mouseup', __tmTimelineSplitResizeOnUp);
            __tmTimelineSplitResizeOnMove = null;
            __tmTimelineSplitResizeOnUp = null;
            __tmTimelineSplitResizeState = null;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        } catch (e) {}
        try {
            if (__tmTimelineContentResizeOnMove) document.removeEventListener('mousemove', __tmTimelineContentResizeOnMove);
            if (__tmTimelineContentResizeOnUp) document.removeEventListener('mouseup', __tmTimelineContentResizeOnUp);
            __tmTimelineContentResizeOnMove = null;
            __tmTimelineContentResizeOnUp = null;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        } catch (e) {}
        try {
            if (__tmWhiteboardSidebarResizeOnMove) document.removeEventListener('mousemove', __tmWhiteboardSidebarResizeOnMove);
            if (__tmWhiteboardSidebarResizeOnUp) document.removeEventListener('mouseup', __tmWhiteboardSidebarResizeOnUp);
            __tmWhiteboardSidebarResizeOnMove = null;
            __tmWhiteboardSidebarResizeOnUp = null;
            __tmWhiteboardSidebarResizeState = null;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        } catch (e) {}

        try { __tmHideMobileMenu?.(); } catch (e) {}
        try {
            if (state.desktopMenuCloseTimer) {
                clearTimeout(state.desktopMenuCloseTimer);
                state.desktopMenuCloseTimer = null;
            }
            if (state.desktopMenuCloseHandler) {
                document.removeEventListener('click', state.desktopMenuCloseHandler);
                state.desktopMenuCloseHandler = null;
            }
        } catch (e) {}
        try {
            if (state.taskContextMenuCloseHandler) {
                document.removeEventListener('click', state.taskContextMenuCloseHandler);
                document.removeEventListener('contextmenu', state.taskContextMenuCloseHandler);
                state.taskContextMenuCloseHandler = null;
            }
        } catch (e) {}
        try {
            if (state.ganttContextMenuCloseBindTimer) {
                clearTimeout(state.ganttContextMenuCloseBindTimer);
                state.ganttContextMenuCloseBindTimer = null;
            }
            if (state.ganttContextMenuCloseHandler) {
                document.removeEventListener('click', state.ganttContextMenuCloseHandler);
                document.removeEventListener('contextmenu', state.ganttContextMenuCloseHandler);
                state.ganttContextMenuCloseHandler = null;
            }
        } catch (e) {}
        try { __tmCloseInlineEditor(); } catch (e) {}
        try { __tmCloseCellEditor(false); } catch (e) {}
        try { globalThis.__tmCalendar?.cleanup?.(); } catch (e) {}
        try { delete globalThis.__tmCalendar; } catch (e) {}

        try {
            if (state.modal) {
                state.modal.remove();
                state.modal = null;
            }
            if (state.settingsModal) {
                state.settingsModal.remove();
                state.settingsModal = null;
            }
            if (state.rulesModal) {
                state.rulesModal.remove();
                state.rulesModal = null;
            }
            if (state.priorityModal) {
                state.priorityModal.remove();
                state.priorityModal = null;
            }
        } catch (e) {}

        try {
            const promptModal = document.querySelector('.tm-prompt-modal');
            if (promptModal) promptModal.remove();
        } catch (e) {}

        try {
            const ctxMenu = document.getElementById('tm-task-context-menu');
            if (ctxMenu) ctxMenu.remove();
        } catch (e) {}
        try {
            const desktopMenu = document.getElementById('tmDesktopMenu');
            if (desktopMenu) desktopMenu.remove();
        } catch (e) {}
        try { __tmHideDocTabMenu?.(); } catch (e) {}
        try {
            const h = state.docTabTouchDelegationHandlers;
            const opts = state.docTabTouchDelegationOptions || { passive: true };
            if (h) {
                try { document.removeEventListener('touchstart', h.start, opts); } catch (e2) {}
                try { document.removeEventListener('touchmove', h.move, opts); } catch (e2) {}
                try { document.removeEventListener('touchend', h.end, opts); } catch (e2) {}
                try { document.removeEventListener('touchcancel', h.end, opts); } catch (e2) {}
            }
            state.docTabTouchDelegationHandlers = null;
            state.docTabTouchDelegationOptions = null;
            state.docTabTouchDelegationBound = false;
            state.docTabTouchActive = false;
            state.docTabTouchActiveDocId = null;
            if (state.docTabLongPressTimer) {
                clearTimeout(state.docTabLongPressTimer);
                state.docTabLongPressTimer = null;
            }
            state.docTabTouchMoved = false;
        } catch (e) {}

        try {
            document.querySelectorAll('.tm-breadcrumb-btn').forEach(btn => btn.remove());
        } catch (e) {}

        try {
            if (MetaStore.saveTimer) {
                clearTimeout(MetaStore.saveTimer);
                MetaStore.saveTimer = null;
            }
        } catch (e) {}
        try {
            if (WhiteboardStore?.saveTimer) {
                clearTimeout(WhiteboardStore.saveTimer);
                WhiteboardStore.saveTimer = null;
            }
            try {
                if (WhiteboardStore?.saveDirty && typeof WhiteboardStore.saveNow === 'function') {
                    WhiteboardStore.saveNow();
                }
            } catch (e2) {}
        } catch (e) {}
        try {
            if (SettingsStore?.saveTimer) {
                clearTimeout(SettingsStore.saveTimer);
                SettingsStore.saveTimer = null;
            }
            try {
                if (SettingsStore?.saveDirty && typeof SettingsStore.syncToLocal === 'function') {
                    SettingsStore.syncToLocal();
                }
            } catch (e2) {}
            try { SettingsStore?.savePromiseResolve?.(); } catch (e2) {}
            try {
                SettingsStore.savePromise = null;
                SettingsStore.savePromiseResolve = null;
                SettingsStore.saveDirty = false;
                SettingsStore.saving = false;
            } catch (e2) {}
        } catch (e) {}

        try { __tmStyleEl?.remove?.(); } catch (e) {}
        try { document.getElementById('sy-custom-props-floatbar-style')?.remove?.(); } catch (e) {}
        try { document.querySelectorAll('.sy-custom-props-floatbar, .sy-custom-props-floatbar__select, .sy-custom-props-floatbar__input-editor').forEach(el => el.remove()); } catch (e) {}

        try { delete globalThis.__taskHorizonMount; } catch (e) {}
        try {
            const ns = window?.[__tmNsKey];
            const keys = Array.isArray(ns?.__exportKeys) ? ns.__exportKeys : [];
            keys.forEach((k) => {
                if (!k) return;
                try { delete window[k]; } catch (e) {
                    try { window[k] = undefined; } catch (e2) {}
                }
            });
        } catch (e) {}
        try { delete window[__tmNsKey]; } catch (e) {
            try { window[__tmNsKey] = undefined; } catch (e2) {}
        }
        try { delete globalThis.__TaskManagerCleanup; } catch (e) {}
    }

    // 暴露清理函数给插件卸载调用
    globalThis.__TaskManagerCleanup = __tmCleanup;
    // 暴露挂载函数供自定义 Tab 使用
    globalThis.__taskHorizonMount = (el) => {
        __tmSetMount(el);
        openManager({ skipEnsureTabOpened: true, preserveViewMode: true }).catch((e) => {
            try { console.error('[task-horizon] openManager failed:', e); } catch (e2) {}
            try { hint(`❌ 加载失败: ${e?.message || String(e)}`, 'error'); } catch (e3) {}
            try {
                try { if (__tmMountRetryTimer) { clearTimeout(__tmMountRetryTimer); __tmMountRetryTimer = null; } } catch (e4) {}
                __tmMountRetryTimer = setTimeout(() => {
                    if (document.visibilityState === 'hidden') return;
                    __tmSafeOpenManager('mount-retry');
                }, 900);
            } catch (e4) {}
        });
    };

    try {
        const now = Object.getOwnPropertyNames(window);
        const added = now.filter(k => !__tmWindowKeysBefore.has(k));
        const exportKeys = [];
        added.forEach((k) => {
            if (!k) return;
            const v = window[k];
            if (typeof v !== 'function') return;
            try { __tmNs[k] = v; } catch (e) {}
            exportKeys.push(k);
        });
        __tmNs.__exportKeys = exportKeys;
    } catch (e) {}

    __tmNs.uninstallCleanup = async function() {
        try {
            await fetch('/api/file/removeFile', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ path: SETTINGS_FILE_PATH }),
            }).catch(() => null);
        } catch (e) {}

        try {
            await fetch('/api/file/removeFile', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ path: META_FILE_PATH }),
            }).catch(() => null);
        } catch (e) {}

        try {
            await fetch('/api/file/removeFile', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ path: WHITEBOARD_DATA_FILE_PATH }),
            }).catch(() => null);
        } catch (e) {}

        try {
            [
                'tm_selected_doc_ids',
                'tm_query_limit',
                'tm_group_by_docname',
                'tm_group_by_taskname',
                'tm_group_by_time',
                'tm_group_mode',
                'tm_doc_h2_subgroup_enabled',
                'tm_collapsed_task_ids',
                'tm_collapsed_groups',
                'tm_current_rule',
                'tm_filter_rules',
                'tm_font_size',
                'tm_font_size_mobile',
                'tm_row_height_mode',
                'tm_row_height_px',
                'tm_enable_quickbar',
                'tm_pin_new_tasks_by_default',
                'tm_new_task_doc_id',
                'tm_enable_tomato_integration',
                'tm_tomato_spent_attr_mode',
                'tm_tomato_spent_attr_key_minutes',
                'tm_tomato_spent_attr_key_hours',
                'tm_default_doc_id',
                'tm_default_doc_id_by_group',
                'tm_priority_score_config',
                'tm_quadrant_config',
                'tm_doc_groups',
                'tm_current_group_id',
                'tm_custom_status_options',
                'tm_column_widths',
                'tm_column_order',
                'tm_topbar_gradient_light_start',
                'tm_topbar_gradient_light_end',
                'tm_topbar_gradient_dark_start',
                'tm_topbar_gradient_dark_end',
                'tm_topbar_text_color_light',
                'tm_topbar_text_color_dark',
                'tm_task_content_color_light',
                'tm_task_content_color_dark',
                'tm_group_doc_label_color_light',
                'tm_group_doc_label_color_dark',
                'tm_time_group_base_color_light',
                'tm_time_group_base_color_dark',
                'tm_time_group_overdue_color_light',
                'tm_time_group_overdue_color_dark',
                'tm_table_border_color_light',
                'tm_table_border_color_dark',
                'tm_meta_cache',
                'tm_whiteboard_data_cache',
            ].forEach((k) => {
                try { Storage.remove(k); } catch (e) {}
            });
        } catch (e) {}
    };

    (function () {
        const DAY_MS = 86400000;
        const cleanupMap = new WeakMap();
    
        function clamp(n, min, max) {
            return Math.max(min, Math.min(max, n));
        }
    
        function parseDateOnlyToTs(value) {
            const s = String(value || '').trim();
            if (!s) return 0;
            if (/^\d{4}-\d{2}-\d{2}$/.test(s)) {
                const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(s);
                const y = Number(m[1]);
                const mon = Number(m[2]) - 1;
                const d = Number(m[3]);
                const dt = new Date(y, mon, d, 12, 0, 0, 0);
                return Number.isNaN(dt.getTime()) ? 0 : dt.getTime();
            }
            const t = new Date(s).getTime();
            return Number.isNaN(t) ? 0 : t;
        }
    
        function formatDateOnlyFromTs(ts) {
            const d = new Date(ts);
            if (Number.isNaN(d.getTime())) return '';
            const pad = (n) => String(n).padStart(2, '0');
            return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
        }
    
        function startOfDayTs(ts) {
            const d = new Date(ts);
            if (Number.isNaN(d.getTime())) return 0;
            return new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0).getTime();
        }
    
        function computeAutoRangeTs(taskItems, paddingDays) {
            let minTs = 0;
            let maxTs = 0;
            for (const t of taskItems) {
                const sTs = parseDateOnlyToTs(t?.startDate);
                const eTs = parseDateOnlyToTs(t?.completionTime);
                const a = sTs || eTs;
                const b = eTs || sTs;
                if (!a || !b) continue;
                if (!minTs || a < minTs) minTs = a;
                if (!maxTs || b > maxTs) maxTs = b;
            }
            const now = Date.now();
            if (!minTs || !maxTs) {
                const today = startOfDayTs(now);
                const start = today - 7 * DAY_MS;
                const end = today + 21 * DAY_MS;
                return { startTs: start, endTs: end };
            }
            const pad = Math.max(0, Number(paddingDays) || 0) * DAY_MS;
            const startTs = startOfDayTs(minTs - pad);
            const endTs = startOfDayTs(maxTs + pad);
            return { startTs, endTs };
        }
    
        function buildDayCellsHtml(startTs, dayCount, dayWidth) {
            const cells = [];
            let lastMonthKey = '';
            for (let i = 0; i < dayCount; i++) {
                const ts = startTs + i * DAY_MS;
                const d = new Date(ts);
                const monthKey = `${d.getFullYear()}-${d.getMonth() + 1}`;
                const isNewMonth = monthKey !== lastMonthKey;
                if (isNewMonth) lastMonthKey = monthKey;
                const day = d.getDate();
                const isWeekend = d.getDay() === 0 || d.getDay() === 6;
                const cls = `tm-gantt-day${isWeekend ? ' tm-gantt-day--weekend' : ''}${isNewMonth ? ' tm-gantt-day--month-start' : ''}`;
                cells.push(`<div class="${cls}" style="width:${dayWidth}px">${day}</div>`);
            }
            return cells.join('');
        }
    
        function buildMonthHeaderHtml(startTs, dayCount, dayWidth) {
            const parts = [];
            let i = 0;
            while (i < dayCount) {
                const ts = startTs + i * DAY_MS;
                const d = new Date(ts);
                const y = d.getFullYear();
                const m = d.getMonth();
                const monthStartTs = new Date(y, m, 1, 0, 0, 0, 0).getTime();
                const nextMonthTs = new Date(y, m + 1, 1, 0, 0, 0, 0).getTime();
                const monthEndTs = nextMonthTs - DAY_MS;
                const startIndex = Math.max(0, Math.floor((monthStartTs - startTs) / DAY_MS));
                const endIndex = Math.min(dayCount - 1, Math.floor((monthEndTs - startTs) / DAY_MS));
                const spanDays = endIndex - startIndex + 1;
                const width = spanDays * dayWidth;
                const label = `${y}-${String(m + 1).padStart(2, '0')}`;
                parts.push(`<div class="tm-gantt-month" style="width:${width}px">${label}</div>`);
                i = endIndex + 1;
            }
            return parts.join('');
        }
    
        function getDayIndexByTs(startTs, ts) {
            return Math.round((startOfDayTs(ts) - startTs) / DAY_MS);
        }
    
        function renderGantt(opts) {
            const headerEl = opts?.headerEl;
            const bodyEl = opts?.bodyEl;
            const rowModel = Array.isArray(opts?.rowModel) ? opts.rowModel : [];
            const getTaskById = typeof opts?.getTaskById === 'function' ? opts.getTaskById : null;
            const onUpdateTaskDates = typeof opts?.onUpdateTaskDates === 'function' ? opts.onUpdateTaskDates : null;
            const onUpdateTaskMeta = typeof opts?.onUpdateTaskMeta === 'function' ? opts.onUpdateTaskMeta : null;
            if (!headerEl || !bodyEl || !getTaskById) return;
    
            try { cleanupMap.get(bodyEl)?.(); } catch (e) {}
    
            const viewState = (opts.viewState && typeof opts.viewState === 'object') ? opts.viewState : {};
            const paddingDays = Number.isFinite(Number(viewState.paddingDays)) ? Number(viewState.paddingDays) : 7;
            const dayWidth = clamp(Number(viewState.dayWidth) || 24, 10, 60);
            const escSq = (s) => String(s || '').replace(/\\/g, '\\\\').replace(/'/g, "\\'");
    
            const tasks = [];
            for (const r of rowModel) {
                if (r?.type !== 'task') continue;
                const t = getTaskById(r.id);
                if (t) tasks.push(t);
            }
    
            const range = computeAutoRangeTs(tasks, paddingDays);
            const startTs = range.startTs;
            const endTs = range.endTs;
            const dayCount = clamp(Math.round((endTs - startTs) / DAY_MS) + 1, 1, 366);
            const totalWidth = dayCount * dayWidth;
            const timelineMultiSelectedSet = new Set(
                (Array.isArray(state.timelineMultiSelectedTaskIds) ? state.timelineMultiSelectedTaskIds : [])
                    .map((x) => String(x || '').trim())
                    .filter(Boolean)
            );
            try { bodyEl.dataset.tmGanttStartTs = String(startTs); } catch (e) {}
            try { bodyEl.dataset.tmGanttDayWidth = String(dayWidth); } catch (e) {}
            try { bodyEl.dataset.tmGanttDayCount = String(dayCount); } catch (e) {}
            try { bodyEl.dataset.tmGanttTotalWidth = String(totalWidth); } catch (e) {}
    
            headerEl.innerHTML = `
                <div class="tm-gantt-header-inner" style="width:${totalWidth}px">
                    <div class="tm-gantt-month-row">${buildMonthHeaderHtml(startTs, dayCount, dayWidth)}</div>
                    <div class="tm-gantt-day-row">${buildDayCellsHtml(startTs, dayCount, dayWidth)}</div>
                </div>
            `;
    
            const nowIdx = getDayIndexByTs(startTs, Date.now());
            const todayIdx = clamp(nowIdx, 0, dayCount - 1);
            const todayLeft = todayIdx * dayWidth + dayWidth * 0.5;
            const rowsHtml = [];
            const enableGroupBg = !!SettingsStore.data.enableGroupTaskBgByGroupColor;
            const isDark = __tmIsDarkMode();
            let currentGroupBg = '';
            for (const r of rowModel) {
                if (r?.type === 'group') {
                    let labelColor = '';
                    if (r.kind === 'doc') labelColor = String(r.labelColor || 'var(--tm-group-doc-label-color)');
                    else if (r.kind === 'task') labelColor = String(r.labelColor || 'var(--tm-primary-color)');
                    else if (r.kind === 'time') labelColor = String(r.labelColor || 'var(--tm-text-color)');
                    else if (r.kind === 'h2') labelColor = 'var(--tm-secondary-text)';
                    else if (r.kind === 'quadrant') {
                        const colorMap = { red: 'var(--tm-quadrant-red)', yellow: 'var(--tm-quadrant-yellow)', blue: 'var(--tm-quadrant-blue)', green: 'var(--tm-quadrant-green)' };
                        labelColor = colorMap[String(r.color || '')] || 'var(--tm-text-color)';
                    } else {
                        labelColor = 'var(--tm-text-color)';
                    }
                    // 按任务名分组时使用文档颜色作为分组背景
                    if (r.kind === 'task' && r.groupDocColor) {
                        currentGroupBg = enableGroupBg ? (__tmGroupBgFromLabelColor(r.groupDocColor, isDark) || '') : '';
                    } else {
                        currentGroupBg = enableGroupBg ? (__tmGroupBgFromLabelColor(labelColor, isDark) || '') : '';
                    }
                    rowsHtml.push(`<div class="tm-gantt-row tm-gantt-row--group" data-group-key="${String(r?.key || '')}" style="width:${totalWidth}px;cursor:pointer"></div>`);
                    continue;
                }
                if (r?.type !== 'task') continue;
                const task = getTaskById(r.id);
                const docId = String(task?.docId || task?.root_id || '').trim();
                
                // 按任务名分组时，每个任务使用自己文档的颜色
                if (state.groupByTaskName && docId) {
                    const taskDocColor = __tmGetDocColorHex(docId, isDark);
                    currentGroupBg = (enableGroupBg && taskDocColor) ? (__tmGroupBgFromLabelColor(taskDocColor, isDark) || '') : '';
                }
                
                const baseColor = __tmGetDocColorHex(docId, isDark);
                const done = !!task?.done;
                const barColor = done
                    ? __tmDesaturateHex(__tmDarkenHex(baseColor, isDark ? 0.48 : 0.36), isDark ? 0.36 : 0.26)
                    : baseColor;
                const sTs0 = parseDateOnlyToTs(task?.startDate);
                const eTs0 = parseDateOnlyToTs(task?.completionTime);
                const aTs = sTs0 || eTs0;
                const bTs = eTs0 || sTs0;
                const milestoneRaw = task?.milestone;
                const isMilestone = typeof milestoneRaw === 'boolean'
                    ? milestoneRaw
                    : ['1', 'true'].includes(String(milestoneRaw || '').trim().toLowerCase());
                const rowBgStyle = (enableGroupBg && currentGroupBg) ? `background:${currentGroupBg};` : '';
                const dotOpenCls = String(state.timelineDotPinnedTaskId || '').trim() === String(r.id) ? ' tm-gantt-row--dot-open' : '';
                const dotHoverCls = String(state.timelineLinkHoverTaskId || '').trim() === String(r.id) ? ' tm-gantt-row--link-hover' : '';
                const multiSelCls = timelineMultiSelectedSet.has(String(r.id)) ? ' tm-gantt-row--multi-selected' : '';
                if (!aTs && !bTs) {
                    rowsHtml.push(`<div class="tm-gantt-row${dotOpenCls}${dotHoverCls}${multiSelCls}" data-id="${String(r.id)}" data-doc-id="${docId}" style="width:${totalWidth}px;${rowBgStyle}" ondragenter="tmTimelineLinkRowDragOver(event, '${escSq(String(r.id))}', '${escSq(docId)}')" ondragover="tmTimelineLinkRowDragOver(event, '${escSq(String(r.id))}', '${escSq(docId)}')" ondragleave="tmTimelineLinkRowDragLeave(event, '${escSq(String(r.id))}')"></div>`);
                    continue;
                }
                if (isMilestone && eTs0) {
                    const endIdx0 = clamp(getDayIndexByTs(startTs, eTs0), 0, dayCount - 1);
                    const markerLeft = endIdx0 * dayWidth + (dayWidth * 0.5);
                    const inLeft = Math.max(6, markerLeft - 16);
                    const outLeft = Math.min(totalWidth - 6, markerLeft + 16);
                    rowsHtml.push(`
                        <div class="tm-gantt-row${dotOpenCls}${dotHoverCls}${multiSelCls}" data-id="${String(r.id)}" data-doc-id="${docId}" style="width:${totalWidth}px;${rowBgStyle}" ondragenter="tmTimelineLinkRowDragOver(event, '${escSq(String(r.id))}', '${escSq(docId)}')" ondragover="tmTimelineLinkRowDragOver(event, '${escSq(String(r.id))}', '${escSq(docId)}')" ondragleave="tmTimelineLinkRowDragLeave(event, '${escSq(String(r.id))}')">
                            <div class="tm-gantt-milestone" style="left:${markerLeft}px;" title="${esc(String(task?.content || '').trim())}\\n里程碑：${esc(formatDateOnlyFromTs(eTs0))}">🚩</div>
                            <span class="tm-task-link-dot tm-task-link-dot--timeline tm-task-link-dot--in${state.whiteboardLinkFromTaskId === String(r.id) ? ' tm-task-link-dot--active' : ''}" style="left:${inLeft}px;" draggable="true" onmousedown="tmTaskLinkDotPressStart(event, '${escSq(String(r.id))}', '${escSq(docId)}')" ondragstart="tmTaskLinkDotDragStart(event, '${escSq(String(r.id))}', '${escSq(docId)}')" ondragend="tmTaskLinkDotDragEnd(event)" ondragover="tmTaskLinkDotDragOver(event, '${escSq(String(r.id))}', '${escSq(docId)}')" ondrop="tmTaskLinkDotDrop(event, '${escSq(String(r.id))}', '${escSq(docId)}')" title="连接输入点"></span>
                            <span class="tm-task-link-dot tm-task-link-dot--timeline tm-task-link-dot--out${state.whiteboardLinkFromTaskId === String(r.id) ? ' tm-task-link-dot--active' : ''}" style="left:${outLeft}px;" draggable="true" onmousedown="tmTaskLinkDotPressStart(event, '${escSq(String(r.id))}', '${escSq(docId)}')" ondragstart="tmTaskLinkDotDragStart(event, '${escSq(String(r.id))}', '${escSq(docId)}')" ondragend="tmTaskLinkDotDragEnd(event)" ondragover="tmTaskLinkDotDragOver(event, '${escSq(String(r.id))}', '${escSq(docId)}')" ondrop="tmTaskLinkDotDrop(event, '${escSq(String(r.id))}', '${escSq(docId)}')" title="连接输出点"></span>
                        </div>
                    `);
                    continue;
                }
                const startIdx = clamp(getDayIndexByTs(startTs, aTs), 0, dayCount - 1);
                const endIdx = clamp(getDayIndexByTs(startTs, bTs), 0, dayCount - 1);
                const left = Math.min(startIdx, endIdx) * dayWidth;
                const width = (Math.abs(endIdx - startIdx) + 1) * dayWidth;
                const inLeft = left;
                const outLeft = left + width;
                rowsHtml.push(`
                    <div class="tm-gantt-row${dotOpenCls}${dotHoverCls}${multiSelCls}" data-id="${String(r.id)}" data-doc-id="${docId}" style="width:${totalWidth}px;${rowBgStyle}" ondragenter="tmTimelineLinkRowDragOver(event, '${escSq(String(r.id))}', '${escSq(docId)}')" ondragover="tmTimelineLinkRowDragOver(event, '${escSq(String(r.id))}', '${escSq(docId)}')" ondragleave="tmTimelineLinkRowDragLeave(event, '${escSq(String(r.id))}')">
                        <div class="tm-gantt-bar" style="left:${left}px;width:${width}px;background:${barColor};" title="${esc(String(task?.content || '').trim())}\\n${esc(formatDateOnlyFromTs(aTs))} ~ ${esc(formatDateOnlyFromTs(bTs))}">
                            <div class="tm-gantt-bar-handle tm-gantt-bar-handle--start" data-handle="start"></div>
                            <div class="tm-gantt-bar-handle tm-gantt-bar-handle--end" data-handle="end"></div>
                        </div>
                        <span class="tm-task-link-dot tm-task-link-dot--timeline tm-task-link-dot--in${state.whiteboardLinkFromTaskId === String(r.id) ? ' tm-task-link-dot--active' : ''}" style="left:${inLeft}px;" draggable="true" onmousedown="tmTaskLinkDotPressStart(event, '${escSq(String(r.id))}', '${escSq(docId)}')" ondragstart="tmTaskLinkDotDragStart(event, '${escSq(String(r.id))}', '${escSq(docId)}')" ondragend="tmTaskLinkDotDragEnd(event)" ondragover="tmTaskLinkDotDragOver(event, '${escSq(String(r.id))}', '${escSq(docId)}')" ondrop="tmTaskLinkDotDrop(event, '${escSq(String(r.id))}', '${escSq(docId)}')" title="连接输入点"></span>
                        <span class="tm-task-link-dot tm-task-link-dot--timeline tm-task-link-dot--out${state.whiteboardLinkFromTaskId === String(r.id) ? ' tm-task-link-dot--active' : ''}" style="left:${outLeft}px;" draggable="true" onmousedown="tmTaskLinkDotPressStart(event, '${escSq(String(r.id))}', '${escSq(docId)}')" ondragstart="tmTaskLinkDotDragStart(event, '${escSq(String(r.id))}', '${escSq(docId)}')" ondragend="tmTaskLinkDotDragEnd(event)" ondragover="tmTaskLinkDotDragOver(event, '${escSq(String(r.id))}', '${escSq(docId)}')" ondrop="tmTaskLinkDotDrop(event, '${escSq(String(r.id))}', '${escSq(docId)}')" title="连接输出点"></span>
                    </div>
                `);
            }
    
            bodyEl.innerHTML = `
                <div class="tm-gantt-body-inner" style="width:${totalWidth}px">
                    <svg class="tm-gantt-deps" aria-hidden="true"></svg>
                    <div class="tm-gantt-today" style="left:${todayLeft}px"></div>
                    ${rowsHtml.join('')}
                </div>
            `;

            const renderDependencies = () => {
                const inner = bodyEl.querySelector('.tm-gantt-body-inner');
                if (!(inner instanceof Element)) return;
                const svg = inner.querySelector('.tm-gantt-deps');
                if (!(svg instanceof SVGElement)) return;
                const width = Math.max(Math.ceil(inner.scrollWidth), Math.ceil(inner.clientWidth), 1);
                const height = Math.max(Math.ceil(inner.scrollHeight), Math.ceil(inner.clientHeight), 1);
                try { svg.setAttribute('width', String(width)); } catch (e) {}
                try { svg.setAttribute('height', String(height)); } catch (e) {}
                try { svg.setAttribute('viewBox', `0 0 ${width} ${height}`); } catch (e) {}

                const links = __tmGetAllTaskLinks({ includeAuto: true });
                const rootRect = inner.getBoundingClientRect();
                const getPt = (taskId, kind) => {
                    const id = String(taskId || '').trim();
                    if (!id) return null;
                    const row = inner.querySelector(`.tm-gantt-row[data-id="${CSS.escape(id)}"]`);
                    if (!(row instanceof Element)) return null;
                    const sel = kind === 'from'
                        ? '.tm-task-link-dot--timeline.tm-task-link-dot--out'
                        : '.tm-task-link-dot--timeline.tm-task-link-dot--in';
                    const dot = row.querySelector(sel);
                    if (!(dot instanceof Element)) return null;
                    const rect = dot.getBoundingClientRect();
                    return {
                        x: rect.left - rootRect.left + (rect.width / 2),
                        y: rect.top - rootRect.top + (rect.height / 2),
                    };
                };
                const markerIdIn = `tmTlArrowIn`;
                const markerIdOut = `tmTlArrowOut`;
                const defs = `
                    <defs>
                        <marker id="${markerIdOut}" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto" markerUnits="strokeWidth">
                            <path d="M0,0 L8,3 L0,6 Z" fill="#2f6fed"></path>
                        </marker>
                        <marker id="${markerIdIn}" markerWidth="8" markerHeight="6" refX="1" refY="3" orient="auto-start-reverse" markerUnits="strokeWidth">
                            <path d="M8,0 L0,3 L8,6 Z" fill="#2f6fed"></path>
                        </marker>
                    </defs>
                `;
                const paths = links.map((link) => {
                    const from = getPt(link.from, 'from');
                    const to = getPt(link.to, 'to');
                    if (!from || !to) return '';
                    const gap = Math.max(10, Math.min(24, Math.abs(to.x - from.x) * 0.35));
                    const x1 = from.x + gap;
                    const x2 = to.x - gap;
                    const d = `M ${from.x.toFixed(2)} ${from.y.toFixed(2)} L ${x1.toFixed(2)} ${from.y.toFixed(2)} L ${x2.toFixed(2)} ${to.y.toFixed(2)} L ${to.x.toFixed(2)} ${to.y.toFixed(2)}`;
                    const cls = link.manual ? 'tm-gantt-dep tm-gantt-dep--manual' : 'tm-gantt-dep tm-gantt-dep--auto';
                    return `<path class="${cls}" d="${d}" marker-end="url(#${markerIdOut})"></path>`;
                }).join('');
                let previewPath = '';
                const fromTaskId = String(state.whiteboardLinkFromTaskId || '').trim();
                const preview = state.whiteboardLinkPreview && typeof state.whiteboardLinkPreview === 'object' ? state.whiteboardLinkPreview : null;
                if (fromTaskId && preview) {
                    const from = getPt(fromTaskId, 'from');
                    if (from) {
                        let to = null;
                        const targetTaskId = String(preview.targetTaskId || '').trim();
                        if (targetTaskId) to = getPt(targetTaskId, 'to');
                        if (!to) {
                            const cx = Number(preview.clientX);
                            const cy = Number(preview.clientY);
                            if (Number.isFinite(cx) && Number.isFinite(cy)) {
                                to = { x: cx - rootRect.left, y: cy - rootRect.top };
                            }
                        }
                        if (to) {
                            const gap = Math.max(10, Math.min(24, Math.abs(to.x - from.x) * 0.35));
                            const x1 = from.x + gap;
                            const x2 = to.x - gap;
                            const d = `M ${from.x.toFixed(2)} ${from.y.toFixed(2)} L ${x1.toFixed(2)} ${from.y.toFixed(2)} L ${x2.toFixed(2)} ${to.y.toFixed(2)} L ${to.x.toFixed(2)} ${to.y.toFixed(2)}`;
                            previewPath = `<path class="tm-gantt-dep tm-gantt-dep--manual" d="${d}" marker-end="url(#${markerIdOut})"></path>`;
                        }
                    }
                }
                svg.innerHTML = defs + paths + previewPath;
            };
            renderDependencies();
            state.__tmTimelineRenderDeps = renderDependencies;
            let suppressCtrlClickSelectionToggle = null;
            const setTimelineDraggingX = (on) => {
                try { bodyEl.classList.toggle('tm-gantt-body--dragging-x', !!on); } catch (e) {}
            };
    
            const onPointerDown = (e) => {
                if (!onUpdateTaskDates) return;
                const target = e.target;
                if (!(target instanceof Element)) return;
                if (target.closest('.tm-task-link-dot')) return;
                const handleEl = target.closest('.tm-gantt-bar-handle');
                const barEl = target.closest('.tm-gantt-bar');
                if (!barEl) return;
                const rowEl = barEl.closest('.tm-gantt-row');
                const taskId = String(rowEl?.getAttribute?.('data-id') || '').trim();
                if (!taskId) return;

                const handleType = handleEl?.getAttribute?.('data-handle');
                const action = handleType === 'start' ? 'start' : handleType === 'end' ? 'end' : 'move';
                const withMultiModifier = (action === 'move') && !!(e?.ctrlKey || e?.metaKey) && Number(e?.button) === 0;

                const startTsStr = String(bodyEl.dataset?.tmGanttStartTs || '');
                const dayWidthStr = String(bodyEl.dataset?.tmGanttDayWidth || '');
                const dayCountStr = String(bodyEl.dataset?.tmGanttDayCount || '');
                const startTs0 = Number(startTsStr);
                const dayWidth0 = Number(dayWidthStr);
                const dayCount0 = Number(dayCountStr);
                if (!Number.isFinite(startTs0) || !Number.isFinite(dayWidth0) || !Number.isFinite(dayCount0) || dayWidth0 <= 0) return;

                const selectedSet = new Set(
                    (Array.isArray(state.timelineMultiSelectedTaskIds) ? state.timelineMultiSelectedTaskIds : [])
                        .map((x) => String(x || '').trim())
                        .filter(Boolean)
                );

                if (withMultiModifier && !selectedSet.has(taskId)) {
                    selectedSet.add(taskId);
                    state.timelineMultiSelectedTaskIds = Array.from(selectedSet);
                    suppressCtrlClickSelectionToggle = { taskId, at: Date.now() };
                    try { rowEl.classList.add('tm-gantt-row--multi-selected'); } catch (e2) {}
                    try { e.preventDefault(); } catch (e3) {}
                    try { e.stopPropagation(); } catch (e3) {}
                    return;
                }

                const rect = bodyEl.getBoundingClientRect();
                const startX = e.clientX;
                const baseScrollLeft = bodyEl.scrollLeft;
                const initialLeftPx = Number.parseFloat(String(barEl.style.left || '').replace('px', '')) || 0;
                const initialWidthPx = Number.parseFloat(String(barEl.style.width || '').replace('px', '')) || dayWidth0;
                const initialStartIdx = clamp(Math.round(initialLeftPx / dayWidth0), 0, dayCount0 - 1);
                const initialLen = Math.max(1, Math.round(initialWidthPx / dayWidth0));
                const initialEndIdx = clamp(initialStartIdx + initialLen - 1, 0, dayCount0 - 1);

                let lastStartIdx = initialStartIdx;
                let lastEndIdx = initialEndIdx;
                let raf = 0;
                let dragging = true;

                const groupItems = [];
                const groupMove = (action === 'move') && selectedSet.size > 1 && selectedSet.has(taskId);
                if (groupMove) {
                    selectedSet.forEach((sid) => {
                        const row = bodyEl.querySelector(`.tm-gantt-row[data-id="${CSS.escape(sid)}"]`);
                        if (!(row instanceof Element)) return;
                        const bar = row.querySelector('.tm-gantt-bar');
                        if (!(bar instanceof HTMLElement)) return;
                        const leftPx = Number.parseFloat(String(bar.style.left || '').replace('px', '')) || 0;
                        const widthPx = Number.parseFloat(String(bar.style.width || '').replace('px', '')) || dayWidth0;
                        const sIdx = clamp(Math.round(leftPx / dayWidth0), 0, dayCount0 - 1);
                        const len = Math.max(1, Math.round(widthPx / dayWidth0));
                        const eIdx = clamp(sIdx + len - 1, 0, dayCount0 - 1);
                        groupItems.push({ taskId: sid, barEl: bar, initialStartIdx: sIdx, initialEndIdx: eIdx, lastStartIdx: sIdx, lastEndIdx: eIdx });
                    });
                }

                const applyBar = (sIdx, eIdx) => {
                    const s = clamp(Math.min(sIdx, eIdx), 0, dayCount0 - 1);
                    const e2 = clamp(Math.max(sIdx, eIdx), 0, dayCount0 - 1);
                    lastStartIdx = s;
                    lastEndIdx = e2;
                    const left = s * dayWidth0;
                    const width = (e2 - s + 1) * dayWidth0;
                    barEl.style.left = `${left}px`;
                    barEl.style.width = `${width}px`;
                };

                const onMove = (ev) => {
                    if (!dragging) return;
                    const dx = (ev.clientX - startX);
                    const deltaDays = Math.round(dx / dayWidth0);
                    if (groupMove && groupItems.length > 1) {
                        groupItems.forEach((it) => {
                            const len = Math.max(1, it.initialEndIdx - it.initialStartIdx + 1);
                            let nextStart = it.initialStartIdx + deltaDays;
                            let nextEnd = nextStart + len - 1;
                            if (nextStart < 0) { nextStart = 0; nextEnd = len - 1; }
                            if (nextEnd > dayCount0 - 1) { nextEnd = dayCount0 - 1; nextStart = nextEnd - len + 1; }
                            it.lastStartIdx = nextStart;
                            it.lastEndIdx = nextEnd;
                            it.barEl.style.left = `${nextStart * dayWidth0}px`;
                            it.barEl.style.width = `${(nextEnd - nextStart + 1) * dayWidth0}px`;
                        });
                        return;
                    }
                    if (action === 'start') {
                        applyBar(initialStartIdx + deltaDays, initialEndIdx);
                    } else if (action === 'end') {
                        applyBar(initialStartIdx, initialEndIdx + deltaDays);
                    } else {
                        const len = Math.max(1, initialEndIdx - initialStartIdx + 1);
                        let nextStart = initialStartIdx + deltaDays;
                        let nextEnd = nextStart + len - 1;
                        if (nextStart < 0) { nextStart = 0; nextEnd = len - 1; }
                        if (nextEnd > dayCount0 - 1) { nextEnd = dayCount0 - 1; nextStart = nextEnd - len + 1; }
                        applyBar(nextStart, nextEnd);
                    }
                };

                const tip = document.createElement('div');
                tip.className = 'tm-gantt-drag-tip';
                tip.textContent = '';
                try {
                    tip.style.position = 'fixed';
                    tip.style.zIndex = '1000002';
                    tip.style.padding = '6px 10px';
                    tip.style.borderRadius = '8px';
                    tip.style.background = 'rgba(0, 0, 0, 0.78)';
                    tip.style.color = '#fff';
                    tip.style.fontSize = '12px';
                    tip.style.lineHeight = '1';
                    tip.style.pointerEvents = 'none';
                    tip.style.transform = 'translate(10px, -18px)';
                    tip.style.whiteSpace = 'nowrap';
                    tip.style.fontVariantNumeric = 'tabular-nums';
                } catch (e4) {}
                try {
                    const host = bodyEl?.ownerDocument?.body || document.body || bodyEl;
                    host.appendChild(tip);
                } catch (e4) {}

                const updateTip = (ev) => {
                    if (groupMove && groupItems.length > 1) {
                        const first = groupItems[0];
                        const delta = first.lastStartIdx - first.initialStartIdx;
                        tip.textContent = `整体偏移 ${delta >= 0 ? '+' : ''}${delta} 天`;
                    } else {
                        const sDate = formatDateOnlyFromTs(startTs0 + lastStartIdx * DAY_MS);
                        const eDate = formatDateOnlyFromTs(startTs0 + lastEndIdx * DAY_MS);
                        tip.textContent = action === 'start' ? sDate : action === 'end' ? eDate : `${sDate} ~ ${eDate}`;
                    }
                    tip.style.left = `${ev.clientX}px`;
                    tip.style.top = `${ev.clientY}px`;
                };

                const onWinPointerMove = (ev) => {
                    if (!dragging) return;
                    if (raf) return;
                    raf = requestAnimationFrame(() => {
                        raf = 0;
                        onMove(ev);
                        updateTip(ev);
                    });
                };

                const onUp = async () => {
                    if (!dragging) return;
                    dragging = false;
                    setTimelineDraggingX(false);
                    try { window.removeEventListener('pointermove', onWinPointerMove, true); } catch (e) {}
                    try { window.removeEventListener('pointerup', onUp, true); } catch (e) {}
                    try { window.removeEventListener('pointercancel', onUp, true); } catch (e) {}
                    try { window.removeEventListener('blur', onUp, true); } catch (e) {}
                    if (raf) cancelAnimationFrame(raf);
                    try { tip.remove(); } catch (e) {}

                    if (groupMove && groupItems.length > 1) {
                        for (const it of groupItems) {
                            const t = getTaskById(it.taskId);
                            const rawStart = String(t?.startDate || '').trim();
                            const rawEnd = String(t?.completionTime || '').trim();
                            if (!rawStart && !rawEnd) continue;
                            const nextStart = rawStart ? formatDateOnlyFromTs(startTs0 + it.lastStartIdx * DAY_MS) : '';
                            const nextEnd = rawEnd ? formatDateOnlyFromTs(startTs0 + it.lastEndIdx * DAY_MS) : '';
                            try {
                                await onUpdateTaskDates(String(it.taskId), { startDate: nextStart, completionTime: nextEnd });
                            } catch (e2) {}
                        }
                        return;
                    }

                    const startDate = formatDateOnlyFromTs(startTs0 + lastStartIdx * DAY_MS);
                    const completionTime = formatDateOnlyFromTs(startTs0 + lastEndIdx * DAY_MS);
                    try {
                        await onUpdateTaskDates(String(taskId), { startDate, completionTime });
                    } catch (e2) {}
                };

                try {
                    barEl.setPointerCapture?.(e.pointerId);
                } catch (e2) {}

                window.addEventListener('pointermove', onWinPointerMove, true);
                window.addEventListener('pointerup', onUp, true);
                window.addEventListener('pointercancel', onUp, true);
                window.addEventListener('blur', onUp, true);
                setTimelineDraggingX(true);

                try { e.preventDefault(); } catch (e3) {}
                try { e.stopPropagation(); } catch (e3) {}

                if (action === 'move') {
                    const relX = e.clientX - rect.left + baseScrollLeft;
                    const anchor = clamp(relX, 0, totalWidth);
                    const newScroll = clamp(anchor - bodyEl.clientWidth * 0.5, 0, Math.max(0, totalWidth - bodyEl.clientWidth));
                    bodyEl.scrollLeft = newScroll;
                }

                updateTip(e);
            };
    
            const onPanPointerDown = (e) => {
                const target = e.target;
                if (!(target instanceof Element)) return;
                if (e && typeof e.button === 'number' && e.button !== 0) return;
                if (target.closest('.tm-task-link-dot')) return;
                if (target.closest('.tm-gantt-bar, .tm-gantt-bar-handle')) return;
    
                const startX = e.clientX;
                const startY = e.clientY;
                const baseScrollLeft = bodyEl.scrollLeft;
                let active = false;
                let ended = false;
                let winMoveBound = false;
                const threshold = 6;
    
                const cleanup = () => {
                    if (ended) return;
                    ended = true;
                    if (winMoveBound) {
                        try { window.removeEventListener('pointermove', onWinMove, true); } catch (e2) {}
                        try { window.removeEventListener('pointerup', onWinUp, true); } catch (e2) {}
                        try { window.removeEventListener('pointercancel', onWinUp, true); } catch (e2) {}
                        try { window.removeEventListener('blur', onWinUp, true); } catch (e2) {}
                    }
                    setTimelineDraggingX(false);
                    try { bodyEl.style.cursor = ''; } catch (e2) {}
                };
    
                const onWinMove = (ev) => {
                    if (ended) return;
                    const dx = ev.clientX - startX;
                    const dy = ev.clientY - startY;
                    if (!active) {
                        if (Math.abs(dx) < threshold) return;
                        if (Math.abs(dx) <= Math.abs(dy)) return;
                        active = true;
                        setTimelineDraggingX(true);
                        try { bodyEl.setPointerCapture?.(e.pointerId); } catch (e2) {}
                        try { bodyEl.style.cursor = 'grabbing'; } catch (e2) {}
                    }
                    const totalWidth0 = Number(bodyEl.dataset?.tmGanttTotalWidth || 0) || totalWidth;
                    const maxLeft = Math.max(0, totalWidth0 - bodyEl.clientWidth);
                    bodyEl.scrollLeft = clamp(baseScrollLeft - dx, 0, maxLeft);
                    try { ev.preventDefault(); } catch (e2) {}
                };
    
                const onWinUp = () => {
                    cleanup();
                };
    
                winMoveBound = true;
                window.addEventListener('pointermove', onWinMove, true);
                window.addEventListener('pointerup', onWinUp, true);
                window.addEventListener('pointercancel', onWinUp, true);
                window.addEventListener('blur', onWinUp, true);
            };

            const onDblClick = async (e) => {
                if (!onUpdateTaskDates) return;
                const target = e.target;
                if (!(target instanceof Element)) return;
                if (target.closest('.tm-gantt-bar, .tm-gantt-bar-handle, .tm-task-link-dot')) return;
                const rowEl = target.closest('.tm-gantt-row');
                const taskId = rowEl?.getAttribute?.('data-id');
                if (!taskId) return;

                const startTsStr = String(bodyEl.dataset?.tmGanttStartTs || '');
                const dayWidthStr = String(bodyEl.dataset?.tmGanttDayWidth || '');
                const dayCountStr = String(bodyEl.dataset?.tmGanttDayCount || '');
                const startTs0 = Number(startTsStr);
                const dayWidth0 = Number(dayWidthStr);
                const dayCount0 = Number(dayCountStr);
                if (!Number.isFinite(startTs0) || !Number.isFinite(dayWidth0) || !Number.isFinite(dayCount0) || dayWidth0 <= 0) return;

                const rect = bodyEl.getBoundingClientRect();
                const relX = e.clientX - rect.left + bodyEl.scrollLeft;
                const dayIdx = clamp(Math.floor(relX / dayWidth0), 0, dayCount0 - 1);
                const completionTs = startTs0 + dayIdx * DAY_MS;
                const completionTime = formatDateOnlyFromTs(completionTs);
                if (!completionTime) return;

                const task = getTaskById(taskId);
                const startDateRaw = String(task?.startDate || '').trim();
                const startTs = parseDateOnlyToTs(startDateRaw);
                let startDate = startDateRaw;
                if (!startDate) startDate = completionTime;
                else if (Number.isFinite(startTs) && startTs > completionTs) startDate = completionTime;

                try {
                    await onUpdateTaskDates(String(taskId), { startDate, completionTime });
                    try { hint(`✅ 完成日期：${completionTime}`, 'success'); } catch (e3) {}
                } catch (e2) {}
            };

            const onContextMenu = (e) => {
                if (!onUpdateTaskDates && !onUpdateTaskMeta) return;
                const target = e.target;
                if (!(target instanceof Element)) return;
                if (target.closest('.tm-task-link-dot')) return;
                const rowEl = target.closest('.tm-gantt-row');
                const taskId = rowEl?.getAttribute?.('data-id');
                if (!taskId) return;
                if (rowEl.classList.contains('tm-gantt-row--group')) return;
                const task = getTaskById(taskId);
                if (!task) return;
                const milestoneRaw = task?.milestone;
                const isMilestone = typeof milestoneRaw === 'boolean'
                    ? milestoneRaw
                    : ['1', 'true'].includes(String(milestoneRaw || '').trim().toLowerCase());

                try { e.preventDefault(); } catch (e2) {}
                try { e.stopPropagation(); } catch (e2) {}

                const existingMenu = document.getElementById('tm-task-context-menu');
                if (existingMenu) existingMenu.remove();
                try { window.tmHideDocTabMenu?.(); } catch (e2) {}
                try {
                    if (state.ganttContextMenuCloseBindTimer) {
                        clearTimeout(state.ganttContextMenuCloseBindTimer);
                        state.ganttContextMenuCloseBindTimer = null;
                    }
                    if (state.ganttContextMenuCloseHandler) {
                        document.removeEventListener('click', state.ganttContextMenuCloseHandler);
                        document.removeEventListener('contextmenu', state.ganttContextMenuCloseHandler);
                        state.ganttContextMenuCloseHandler = null;
                    }
                } catch (e2) {}

                const menu = document.createElement('div');
                menu.id = 'tm-task-context-menu';
                menu.style.cssText = `
                    position: fixed;
                    top: ${e.clientY}px;
                    left: ${e.clientX}px;
                    background: var(--b3-theme-background);
                    border: 1px solid var(--b3-theme-surface-light);
                    border-radius: 4px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                    padding: 4px 0;
                    z-index: 200000;
                    min-width: 160px;
                    user-select: none;
                `;

                const createItem = (label, onClick, isDanger) => {
                    const item = document.createElement('div');
                    item.textContent = label;
                    item.style.cssText = `
                        padding: 6px 12px;
                        cursor: pointer;
                        font-size: 13px;
                        color: ${isDanger ? 'var(--b3-theme-error)' : 'var(--b3-theme-on-background)'};
                        display: flex;
                        align-items: center;
                        gap: 8px;
                    `;
                    item.onmouseenter = () => item.style.backgroundColor = 'var(--b3-theme-surface-light)';
                    item.onmouseleave = () => item.style.backgroundColor = 'transparent';
                    item.onclick = (ev) => {
                        ev.stopPropagation();
                        menu.remove();
                        onClick?.();
                    };
                    return item;
                };

                menu.appendChild(createItem('🧹 清除时间轴（清空起止）', async () => {
                    try {
                        await onUpdateTaskDates(String(taskId), { startDate: '', completionTime: '' });
                        try { hint('✅ 已清除时间轴', 'success'); } catch (e3) {}
                    } catch (e2) {
                        try { hint(`❌ 清除失败: ${e2?.message || String(e2)}`, 'error'); } catch (e3) {}
                    }
                }, true));

                if (onUpdateTaskMeta && !isMilestone) {
                    menu.appendChild(createItem('🚩 设为里程碑事件', async () => {
                        try {
                            const endDate = String(task?.completionTime || '').trim();
                            if (!endDate) {
                                hint('⚠️ 请先设置完成日期后再设为里程碑', 'error');
                                return;
                            }
                            await onUpdateTaskMeta(String(taskId), { milestone: true });
                            try { hint('✅ 已设为里程碑', 'success'); } catch (e3) {}
                        } catch (e2) {
                            try { hint(`❌ 设置失败: ${e2?.message || String(e2)}`, 'error'); } catch (e3) {}
                        }
                    }));
                }

                if (onUpdateTaskMeta && isMilestone) {
                    menu.appendChild(createItem('↩ 还原普通时间轴', async () => {
                        try {
                            await onUpdateTaskMeta(String(taskId), { milestone: false });
                            try { hint('✅ 已还原普通时间轴', 'success'); } catch (e3) {}
                        } catch (e2) {
                            try { hint(`❌ 还原失败: ${e2?.message || String(e2)}`, 'error'); } catch (e3) {}
                        }
                    }));
                }

                document.body.appendChild(menu);

                const closeHandler = () => {
                    try { menu.remove(); } catch (e2) {}
                    try { document.removeEventListener('click', closeHandler); } catch (e2) {}
                    try { document.removeEventListener('contextmenu', closeHandler); } catch (e2) {}
                    if (state.ganttContextMenuCloseHandler === closeHandler) state.ganttContextMenuCloseHandler = null;
                    if (state.ganttContextMenuCloseBindTimer) {
                        try { clearTimeout(state.ganttContextMenuCloseBindTimer); } catch (e2) {}
                        state.ganttContextMenuCloseBindTimer = null;
                    }
                };
                state.ganttContextMenuCloseHandler = closeHandler;
                state.ganttContextMenuCloseBindTimer = setTimeout(() => {
                    document.addEventListener('click', closeHandler);
                    document.addEventListener('contextmenu', closeHandler);
                }, 0);
            };

            const onClick = (e) => {
                const target = e.target;
                if (!(target instanceof Element)) return;
                if (target.closest('.tm-task-link-dot')) return;
                const withMultiModifier = !!(e?.ctrlKey || e?.metaKey);
                const rowEl = target.closest('.tm-gantt-row');
                if (!(rowEl instanceof Element) || rowEl.classList.contains('tm-gantt-row--group')) {
                    if (String(state.timelineDotPinnedTaskId || '').trim()) {
                        state.timelineDotPinnedTaskId = '';
                        try { bodyEl.querySelectorAll('.tm-gantt-row--dot-open').forEach(el => el.classList.remove('tm-gantt-row--dot-open')); } catch (e2) {}
                    }
                    return;
                }
                const taskId = String(rowEl.getAttribute('data-id') || '').trim();
                if (!taskId) return;
                if (target.closest('.tm-gantt-bar-handle')) return;
                const isBarClick = !!target.closest('.tm-gantt-bar, .tm-gantt-milestone');
                if (!isBarClick) {
                    if (String(state.timelineDotPinnedTaskId || '').trim()) {
                        state.timelineDotPinnedTaskId = '';
                        try { bodyEl.querySelectorAll('.tm-gantt-row--dot-open').forEach(el => el.classList.remove('tm-gantt-row--dot-open')); } catch (e2) {}
                    }
                    if (!withMultiModifier) {
                        state.timelineMultiSelectedTaskIds = [];
                        try { bodyEl.querySelectorAll('.tm-gantt-row--multi-selected').forEach((el) => el.classList.remove('tm-gantt-row--multi-selected')); } catch (e2) {}
                    }
                    return;
                }
                if (withMultiModifier) {
                    const suppress = suppressCtrlClickSelectionToggle;
                    if (suppress
                        && String(suppress.taskId || '').trim() === taskId
                        && (Date.now() - Number(suppress.at || 0)) < 500) {
                        suppressCtrlClickSelectionToggle = null;
                        try { e.preventDefault(); } catch (e2) {}
                        try { e.stopPropagation(); } catch (e2) {}
                        return;
                    }
                    const set = new Set(
                        (Array.isArray(state.timelineMultiSelectedTaskIds) ? state.timelineMultiSelectedTaskIds : [])
                            .map((x) => String(x || '').trim())
                            .filter(Boolean)
                    );
                    if (set.has(taskId)) set.delete(taskId);
                    else set.add(taskId);
                    state.timelineMultiSelectedTaskIds = Array.from(set);
                    try {
                        if (set.has(taskId)) rowEl.classList.add('tm-gantt-row--multi-selected');
                        else rowEl.classList.remove('tm-gantt-row--multi-selected');
                    } catch (e2) {}
                    try { e.preventDefault(); } catch (e2) {}
                    try { e.stopPropagation(); } catch (e2) {}
                    return;
                }
                if (Array.isArray(state.timelineMultiSelectedTaskIds) && state.timelineMultiSelectedTaskIds.length) {
                    state.timelineMultiSelectedTaskIds = [];
                    try { bodyEl.querySelectorAll('.tm-gantt-row--multi-selected').forEach((el) => el.classList.remove('tm-gantt-row--multi-selected')); } catch (e2) {}
                }
                const prev = String(state.timelineDotPinnedTaskId || '').trim();
                const next = prev === taskId ? '' : taskId;
                state.timelineDotPinnedTaskId = next;
                try { bodyEl.querySelectorAll('.tm-gantt-row--dot-open').forEach(el => el.classList.remove('tm-gantt-row--dot-open')); } catch (e2) {}
                if (next) {
                    try { rowEl.classList.add('tm-gantt-row--dot-open'); } catch (e2) {}
                }
            };
    
            bodyEl.addEventListener('pointerdown', onPointerDown, { passive: false });
            bodyEl.addEventListener('pointerdown', onPanPointerDown, { passive: false });
            bodyEl.addEventListener('dblclick', onDblClick);
            bodyEl.addEventListener('contextmenu', onContextMenu);
            bodyEl.addEventListener('click', onClick);
            cleanupMap.set(bodyEl, () => {
                try { bodyEl.removeEventListener('pointerdown', onPointerDown, { passive: false }); } catch (e) {
                    try { bodyEl.removeEventListener('pointerdown', onPointerDown); } catch (e2) {}
                }
                try { bodyEl.removeEventListener('pointerdown', onPanPointerDown, { passive: false }); } catch (e) {
                    try { bodyEl.removeEventListener('pointerdown', onPanPointerDown); } catch (e2) {}
                }
                try { bodyEl.removeEventListener('dblclick', onDblClick); } catch (e) {}
                try { bodyEl.removeEventListener('contextmenu', onContextMenu); } catch (e) {}
                try { bodyEl.removeEventListener('click', onClick); } catch (e) {}
                if (state.__tmTimelineRenderDeps === renderDependencies) state.__tmTimelineRenderDeps = null;
            });
        }
    
        globalThis.__TaskHorizonGanttView = {
            render: renderGantt,
            parseDateOnlyToTs,
            formatDateOnlyFromTs,
            startOfDayTs,
            DAY_MS,
        };
    })();

    if (document.readyState === 'loading') {
        __tmDomReadyHandler = init;
        document.addEventListener('DOMContentLoaded', __tmDomReadyHandler);
    } else {
        init();
    }
})();
